!function(modules) {
    function __webpack_require__(moduleId) {
        if (installedModules[moduleId]) return installedModules[moduleId].exports;
        var module = installedModules[moduleId] = {
            exports: {},
            id: moduleId,
            loaded: !1
        };
        return modules[moduleId].call(module.exports, module, module.exports, __webpack_require__), 
        module.loaded = !0, module.exports;
    }
    var installedModules = {};
    return __webpack_require__.m = modules, __webpack_require__.c = installedModules, 
    __webpack_require__.p = "", __webpack_require__(0);
}([ function(module, exports, __webpack_require__) {
    module.exports = __webpack_require__(13);
}, , , , , , , , , , , , , function(module, exports, __webpack_require__) {
    function requireAll(requireContext) {
        return requireContext.keys().map(requireContext);
    }
    window.jsCommon, window.powerbi, window.powerbitests, window.InJs, window.debug, 
    window.jasmine, window.Microsoft;
    window.jsCommon = window.jsCommon || {}, window.powerbi = window.powerbi || {}, 
    window.debug = window.debug || {}, window.InJs = window.InJs || {}, requireAll(__webpack_require__(14)), 
    __webpack_require__(37);
}, function(module, exports, __webpack_require__) {
    function webpackContext(req) {
        return __webpack_require__(webpackContextResolve(req));
    }
    function webpackContextResolve(req) {
        return map[req] || function() {
            throw new Error("Cannot find module '" + req + "'.");
        }();
    }
    var map = {
        "./styles/styles.less": 15,
        "./visuals/asterPlot/visual/styles/asterPlot.less": 17,
        "./visuals/bulletChart/visual/styles/bulletChart.less": 18,
        "./visuals/chicletSlicer/visual/styles/chicletSlicer.less": 19,
        "./visuals/chordChart/visual/styles/chordChart.less": 20,
        "./visuals/dotPlot/visual/styles/dotPlot.less": 21,
        "./visuals/enhancedScatterChart/visual/styles/enhancedScatterChart.less": 22,
        "./visuals/forceGraph/visual/styles/forceGraph.less": 23,
        "./visuals/gantt/visual/styles/gantt.less": 24,
        "./visuals/globeMap/visual/styles/globeMap.less": 25,
        "./visuals/histogram/visual/styles/histogram.less": 26,
        "./visuals/lineDotChart/visual/styles/lineDotChart.less": 27,
        "./visuals/mekkoChart/visual/styles/mekkoChart.less": 28,
        "./visuals/pulseChart/visual/styles/pulseChart.less": 29,
        "./visuals/radarChart/visual/styles/radarChart.less": 30,
        "./visuals/sankeyDiagram/visual/styles/sankeyDiagram.less": 31,
        "./visuals/streamGraph/visual/styles/streamGraph.less": 32,
        "./visuals/sunburst/visual/styles/sunburst.less": 33,
        "./visuals/timeline/visual/styles/timeline.less": 34,
        "./visuals/tornadoChart/visual/styles/tornadoChart.less": 35,
        "./visuals/wordCloud/visual/styles/wordCloud.less": 36
    };
    webpackContext.keys = function() {
        return Object.keys(map);
    }, webpackContext.resolve = webpackContextResolve, module.exports = webpackContext, 
    webpackContext.id = 14;
}, function(module, exports) {}, , function(module, exports) {}, function(module, exports) {}, function(module, exports) {}, function(module, exports) {}, function(module, exports) {}, function(module, exports) {}, function(module, exports) {}, function(module, exports) {}, function(module, exports) {}, function(module, exports) {}, function(module, exports) {}, function(module, exports) {}, function(module, exports) {}, function(module, exports) {}, function(module, exports) {}, function(module, exports) {}, function(module, exports) {}, function(module, exports) {}, function(module, exports) {}, function(module, exports) {}, function(module, exports, __webpack_require__) {
    window.jsCommon, window.powerbi, window.powerbitests, window.InJs, window.debug, 
    window.jasmine, window.Microsoft;
    __webpack_require__(38), __webpack_require__(39), __webpack_require__(40), __webpack_require__(41), 
    __webpack_require__(42), __webpack_require__(43), __webpack_require__(44), __webpack_require__(45), 
    __webpack_require__(46), __webpack_require__(47), __webpack_require__(48), __webpack_require__(49), 
    __webpack_require__(50), __webpack_require__(51), __webpack_require__(52), __webpack_require__(53), 
    __webpack_require__(54), __webpack_require__(55), __webpack_require__(56), __webpack_require__(57), 
    __webpack_require__(58);
}, function(module, exports) {
    var powerbi, jsCommon = window.jsCommon, powerbi = window.powerbi;
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var samples;
            !function(samples) {
                var createClassAndSelector = jsCommon.CssConstants.createClassAndSelector, PixelConverter = jsCommon.PixelConverter, createEnumType = powerbi.createEnumType, DataViewObjects = powerbi.DataViewObjects, TextMeasurementService = powerbi.TextMeasurementService, DataLabelManager = powerbi.DataLabelManager, VisualDataRoleKind = powerbi.VisualDataRoleKind, ValueFormatter = powerbi.visuals.valueFormatter, LegendData = powerbi.visuals.LegendData, ObjectEnumerationBuilder = powerbi.visuals.ObjectEnumerationBuilder, LegendPosition = powerbi.visuals.LegendPosition, dataLabelUtils = powerbi.visuals.dataLabelUtils, converterHelper = powerbi.visuals.converterHelper, legendPosition = powerbi.visuals.legendPosition, ColorHelper = powerbi.visuals.ColorHelper, valueFormatter = powerbi.visuals.valueFormatter, TooltipBuilder = powerbi.visuals.TooltipBuilder, SelectionId = powerbi.visuals.SelectionId, LegendIcon = powerbi.visuals.LegendIcon, appendClearCatcher = powerbi.visuals.appendClearCatcher, createInteractivityService = powerbi.visuals.createInteractivityService, createLegend = powerbi.visuals.createLegend, MinervaAnimationDuration = powerbi.visuals.AnimatorCommon.MinervaAnimationDuration, SVGUtil = powerbi.visuals.SVGUtil, TooltipManager = powerbi.visuals.TooltipManager, Legend = powerbi.visuals.Legend, AsterPlotVisualClassName = "asterPlot", AsterRadiusRatio = .9, AsterConflictRatio = .9, AsterPlotWebBehavior = function() {
                    function AsterPlotWebBehavior() {}
                    return AsterPlotWebBehavior.prototype.bindEvents = function(options, selectionHandler) {
                        this.selection = options.selection, this.clearCatcher = options.clearCatcher, this.interactivityService = options.interactivityService, 
                        this.hasHighlights = options.hasHighlights, this.selection.on("click", function(d, i) {
                            selectionHandler.handleSelection(d.data, d3.event.ctrlKey);
                        }), this.clearCatcher.on("click", function() {
                            selectionHandler.handleClearSelection();
                        }), this.renderSelection(this.interactivityService.hasSelection());
                    }, AsterPlotWebBehavior.prototype.renderSelection = function(hasSelection) {
                        var _this = this;
                        this.selection.style("fill-opacity", function(d) {
                            return asterPlotUtils.getFillOpacity(d.data.selected, d.data.highlight, hasSelection, _this.hasHighlights);
                        });
                    }, AsterPlotWebBehavior;
                }(), AsterPlotWarning = function() {
                    function AsterPlotWarning(message) {
                        this.message = message;
                    }
                    return Object.defineProperty(AsterPlotWarning.prototype, "code", {
                        get: function() {
                            return "AsterPlotWarning";
                        },
                        enumerable: !0,
                        configurable: !0
                    }), AsterPlotWarning.prototype.getMessages = function(resourceProvider) {
                        return {
                            message: this.message,
                            title: resourceProvider.get(""),
                            detail: resourceProvider.get("")
                        };
                    }, AsterPlotWarning;
                }();
                samples.AsterPlotWarning = AsterPlotWarning;
                var VisualLayout = function() {
                    function VisualLayout(defaultViewport, defaultMargin) {
                        this.defaultViewport = defaultViewport || {
                            width: 0,
                            height: 0
                        }, this.defaultMargin = defaultMargin || {
                            top: 0,
                            bottom: 0,
                            right: 0,
                            left: 0
                        };
                    }
                    return Object.defineProperty(VisualLayout.prototype, "viewport", {
                        get: function() {
                            return this.viewportValue || (this.viewportValue = this.defaultViewport);
                        },
                        set: function(value) {
                            var _this = this;
                            this.previousOriginalViewportValue = _.clone(this.originalViewportValue), this.originalViewportValue = _.clone(value), 
                            this.setUpdateObject(value, function(v) {
                                return _this.viewportValue = v;
                            }, function(o) {
                                return VisualLayout.restrictToMinMax(o, _this.minViewport);
                            });
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(VisualLayout.prototype, "viewportCopy", {
                        get: function() {
                            return _.clone(this.viewport);
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(VisualLayout.prototype, "viewportIn", {
                        get: function() {
                            return this.viewportInValue || this.viewport;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(VisualLayout.prototype, "minViewport", {
                        get: function() {
                            return this.minViewportValue || {
                                width: 0,
                                height: 0
                            };
                        },
                        set: function(value) {
                            var _this = this;
                            this.setUpdateObject(value, function(v) {
                                return _this.minViewportValue = v;
                            }, VisualLayout.restrictToMinMax);
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(VisualLayout.prototype, "margin", {
                        get: function() {
                            return this.marginValue || (this.marginValue = this.defaultMargin);
                        },
                        set: function(value) {
                            var _this = this;
                            this.setUpdateObject(value, function(v) {
                                return _this.marginValue = v;
                            }, VisualLayout.restrictToMinMax);
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(VisualLayout.prototype, "viewportChanged", {
                        get: function() {
                            return !(!this.originalViewportValue || this.previousOriginalViewportValue && this.previousOriginalViewportValue.height === this.originalViewportValue.height && this.previousOriginalViewportValue.width === this.originalViewportValue.width);
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(VisualLayout.prototype, "viewportInIsZero", {
                        get: function() {
                            return 0 === this.viewportIn.width || 0 === this.viewportIn.height;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), VisualLayout.prototype.resetMargin = function() {
                        this.margin = this.defaultMargin;
                    }, VisualLayout.prototype.update = function() {
                        this.viewportInValue = VisualLayout.restrictToMinMax({
                            width: this.viewport.width - (this.margin.left + this.margin.right),
                            height: this.viewport.height - (this.margin.top + this.margin.bottom)
                        }, this.minViewportValue);
                    }, VisualLayout.prototype.setUpdateObject = function(object, setObjectFn, beforeUpdateFn) {
                        var _this = this;
                        object = _.clone(object), setObjectFn(VisualLayout.createNotifyChangedObject(object, function(o) {
                            beforeUpdateFn && beforeUpdateFn(object), _this.update();
                        })), beforeUpdateFn && beforeUpdateFn(object), this.update();
                    }, VisualLayout.createNotifyChangedObject = function(object, objectChanged) {
                        var result = {};
                        return _.keys(object).forEach(function(key) {
                            return Object.defineProperty(result, key, {
                                get: function() {
                                    return object[key];
                                },
                                set: function(value) {
                                    object[key] = value, objectChanged(object, key);
                                },
                                enumerable: !0,
                                configurable: !0
                            });
                        }), result;
                    }, VisualLayout.restrictToMinMax = function(value, minValue) {
                        return _.keys(value).forEach(function(x) {
                            return value[x] = Math.max(minValue && minValue[x] || 0, value[x]);
                        }), value;
                    }, VisualLayout;
                }(), Helpers = function() {
                    function Helpers() {}
                    return Helpers.setAttrThroughTransitionIfNotResized = function(element, setTransision, attrName, attrValue, attrTransitionValue, viewportChanged) {
                        viewportChanged ? element.attr(attrName, attrValue) : setTransision(element.transition()).attrTween(attrName, attrTransitionValue);
                    }, Helpers.interpolateArc = function(arc) {
                        return function(data) {
                            if (!this.oldData) return this.oldData = data, function() {
                                return arc(data);
                            };
                            var interpolation = d3.interpolate(this.oldData, data);
                            return this.oldData = interpolation(0), function(x) {
                                return arc(interpolation(x));
                            };
                        };
                    }, Helpers.addContext = function(context, fn) {
                        return function() {
                            return fn.apply(context, [ this ].concat(_.toArray(arguments)));
                        };
                    }, Helpers;
                }(), AsterPlotSettings = function() {
                    function AsterPlotSettings() {
                        this.legend = {
                            show: !1,
                            position: LegendPosition[LegendPosition.Top],
                            showTitle: !0,
                            titleText: "",
                            labelColor: LegendData.DefaultLegendLabelFillColor,
                            fontSize: 8
                        }, this.labels = {
                            show: !1,
                            color: dataLabelUtils.defaultLabelColor,
                            displayUnits: 0,
                            precision: dataLabelUtils.defaultLabelPrecision,
                            fontSize: dataLabelUtils.DefaultFontSizeInPt
                        }, this.outerLine = {
                            show: !1,
                            thickness: 1
                        };
                    }
                    return Object.defineProperty(AsterPlotSettings, "Default", {
                        get: function() {
                            return new this();
                        },
                        enumerable: !0,
                        configurable: !0
                    }), AsterPlotSettings.parse = function(dataView, capabilities) {
                        var settings = new this();
                        if (!dataView || !dataView.metadata || !dataView.metadata.objects) return settings;
                        var properties = this.getProperties(capabilities);
                        for (var objectKey in capabilities.objects) for (var propKey in capabilities.objects[objectKey].properties) if (settings[objectKey] && _.has(settings[objectKey], propKey)) {
                            var type = capabilities.objects[objectKey].properties[propKey].type, getValueFn = this.getValueFnByType(type);
                            settings[objectKey][propKey] = getValueFn(dataView.metadata.objects, properties[objectKey][propKey], settings[objectKey][propKey]);
                        }
                        return settings;
                    }, AsterPlotSettings.getProperties = function(capabilities) {
                        var objects = _.merge({
                            general: {
                                properties: {
                                    formatString: {}
                                }
                            }
                        }, capabilities.objects), properties = {};
                        for (var objectKey in objects) {
                            properties[objectKey] = {};
                            for (var propKey in objects[objectKey].properties) properties[objectKey][propKey] = {
                                objectName: objectKey,
                                propertyName: propKey
                            };
                        }
                        return properties;
                    }, AsterPlotSettings.createEnumTypeFromEnum = function(type) {
                        var even = !1;
                        return createEnumType(Object.keys(type).filter(function(key, i) {
                            return !!(i % 2) === even && type[key] === key && !void (even = !even) || !!(i % 2) !== even;
                        }).map(function(x) {
                            return {
                                value: x,
                                displayName: x
                            };
                        }));
                    }, AsterPlotSettings.getValueFnByType = function(type) {
                        switch (_.keys(type)[0]) {
                          case "fill":
                            return DataViewObjects.getFillColor;

                          default:
                            return DataViewObjects.getValue;
                        }
                    }, AsterPlotSettings.enumerateObjectInstances = function(settings, options, capabilities) {
                        void 0 === settings && (settings = new this());
                        var enumeration = new ObjectEnumerationBuilder(), object = settings && settings[options.objectName];
                        if (!object) return enumeration;
                        var instance = {
                            objectName: options.objectName,
                            selector: null,
                            properties: {}
                        };
                        for (var key in object) _.has(object, key) && (instance.properties[key] = object[key]);
                        return enumeration.pushInstance(instance), enumeration;
                    }, AsterPlotSettings.prototype.createOriginalSettings = function() {
                        this.originalSettings = _.cloneDeep(this);
                    }, AsterPlotSettings;
                }();
                samples.AsterPlotSettings = AsterPlotSettings;
                var AsterPlotColumns = function() {
                    function AsterPlotColumns() {
                        this.Category = null, this.Y = null;
                    }
                    return AsterPlotColumns.getColumnSources = function(dataView) {
                        return this.getColumnSourcesT(dataView);
                    }, AsterPlotColumns.getTableValues = function(dataView) {
                        var table = dataView && dataView.table, columns = this.getColumnSourcesT(dataView);
                        return columns && table && _.mapValues(columns, function(n, i) {
                            return n && table.rows.map(function(row) {
                                return row[n.index];
                            });
                        });
                    }, AsterPlotColumns.getTableRows = function(dataView) {
                        var table = dataView && dataView.table, columns = this.getColumnSourcesT(dataView);
                        return columns && table && table.rows.map(function(row) {
                            return _.mapValues(columns, function(n, i) {
                                return n && row[n.index];
                            });
                        });
                    }, AsterPlotColumns.getCategoricalValues = function(dataView) {
                        var categorical = dataView && dataView.categorical, categories = categorical && categorical.categories || [], values = categorical && categorical.values || [], series = categorical && values.source && this.getSeriesValues(dataView);
                        return categorical && _.mapValues(new this(), function(n, i) {
                            return _.toArray(categories).concat(_.toArray(values)).filter(function(x) {
                                return x.source.roles && x.source.roles[i];
                            }).map(function(x) {
                                return x.values;
                            })[0] || values.source && values.source.roles && values.source.roles[i] && series;
                        });
                    }, AsterPlotColumns.getSeriesValues = function(dataView) {
                        return dataView && dataView.categorical && dataView.categorical.values && dataView.categorical.values.map(function(x) {
                            return converterHelper.getSeriesName(x.source);
                        });
                    }, AsterPlotColumns.getCategoricalColumns = function(dataView) {
                        var categorical = dataView && dataView.categorical, categories = categorical && categorical.categories || [], values = categorical && categorical.values || [];
                        return categorical && _.mapValues(new this(), function(n, i) {
                            return categories.filter(function(x) {
                                return x.source.roles && x.source.roles[i];
                            })[0] || values.source && values.source.roles && values.source.roles[i] || values.filter(function(x) {
                                return x.source.roles && x.source.roles[i];
                            });
                        });
                    }, AsterPlotColumns.getColumnSourcesT = function(dataView) {
                        var columns = dataView && dataView.metadata && dataView.metadata.columns;
                        return columns && _.mapValues(new this(), function(n, i) {
                            return columns.filter(function(x) {
                                return x.roles && x.roles[i];
                            })[0];
                        });
                    }, AsterPlotColumns.Roles = Object.freeze(_.mapValues(new AsterPlotColumns(), function(x, i) {
                        return i;
                    })), AsterPlotColumns;
                }();
                samples.AsterPlotColumns = AsterPlotColumns;
                var AsterPlot = function() {
                    function AsterPlot() {}
                    return AsterPlot.converter = function(dataView, colors) {
                        var categorical = AsterPlotColumns.getCategoricalColumns(dataView), catValues = AsterPlotColumns.getCategoricalValues(dataView);
                        if (categorical && categorical.Category && !_.isEmpty(categorical.Category.values) && !_.isEmpty(categorical.Y) && !_.isEmpty(categorical.Y[0].values)) {
                            for (var settings = AsterPlot.parseSettings(dataView, categorical.Category.source), properties = AsterPlotSettings.getProperties(AsterPlot.capabilities), dataPoints = [], highlightedDataPoints = [], legendData = {
                                dataPoints: [],
                                title: null,
                                fontSize: AsterPlotSettings.Default.legend.fontSize,
                                labelColor: LegendData.DefaultLegendLabelFillColor
                            }, colorHelper = new ColorHelper(colors), hasHighlights = !!categorical.Y[0].highlights, maxValue = Math.max(d3.min(categorical.Y[0].values)), minValue = Math.min(0, d3.min(categorical.Y[0].values)), labelFormatter = ValueFormatter.create({
                                format: ValueFormatter.getFormatString(categorical.Y[0].source, properties.general.formatString),
                                precision: settings.labels.precision,
                                value: 0 === settings.labels.displayUnits && null != maxValue ? maxValue : settings.labels.displayUnits
                            }), categorySourceFormatString = valueFormatter.getFormatString(categorical.Category.source, properties.general.formatString), fontSizeInPx = PixelConverter.fromPoint(settings.labels.fontSize), i = 0; i < catValues.Category.length; i++) {
                                var formattedCategoryValue = valueFormatter.format(catValues.Category[i], categorySourceFormatString), currentValue = categorical.Y[0].values[i], tooltipInfo = TooltipBuilder.createTooltipInfo(properties.general.formatString, dataView.categorical, formattedCategoryValue, currentValue, null, null, 0);
                                if (categorical.Y.length > 1) {
                                    var toolTip = TooltipBuilder.createTooltipInfo(properties.general.formatString, dataView.categorical, formattedCategoryValue, categorical.Y[1].values[i], null, null, 1)[1];
                                    toolTip && tooltipInfo.push(toolTip), currentValue += categorical.Y[1].values[i];
                                }
                                var color, sliceWidth, identity = categorical.Category.identity[i];
                                color = colorHelper.getColorForMeasure(categorical.Category.objects && categorical.Category.objects[i], identity.key), 
                                sliceWidth = Math.max(0, categorical.Y.length > 1 ? categorical.Y[1].values[i] : 1);
                                var selectionId = SelectionId.createWithIdAndMeasureAndCategory(identity, identity.key, categorical.Category.source.queryName);
                                if (sliceWidth > 0 && dataPoints.push({
                                    sliceHeight: categorical.Y[0].values[i] - minValue,
                                    sliceWidth: sliceWidth,
                                    label: labelFormatter.format(currentValue),
                                    color: color,
                                    identity: selectionId,
                                    selected: !1,
                                    tooltipInfo: tooltipInfo,
                                    labelFontSize: fontSizeInPx,
                                    highlight: !1
                                }), settings.legend.show && legendData.dataPoints.push({
                                    label: formattedCategoryValue,
                                    color: color,
                                    icon: LegendIcon.Box,
                                    selected: !1,
                                    identity: selectionId
                                }), hasHighlights) {
                                    var highlightIdentity = SelectionId.createWithHighlight(selectionId), notNull = null != categorical.Y[0].highlights[i];
                                    if (currentValue = notNull ? categorical.Y[0].highlights[i] : 0, tooltipInfo = TooltipBuilder.createTooltipInfo(properties.general.formatString, dataView.categorical, formattedCategoryValue, currentValue, null, null, 0), 
                                    categorical.Y.length > 1) {
                                        var toolTip = TooltipBuilder.createTooltipInfo(properties.general.formatString, dataView.categorical, formattedCategoryValue, categorical.Y[1].highlights[i], null, null, 1)[1];
                                        toolTip && tooltipInfo.push(toolTip), currentValue += null !== categorical.Y[1].highlights[i] ? categorical.Y[1].highlights[i] : 0;
                                    }
                                    highlightedDataPoints.push({
                                        sliceHeight: notNull ? categorical.Y[0].highlights[i] - minValue : null,
                                        sliceWidth: Math.max(0, categorical.Y.length > 1 && null !== categorical.Y[1].highlights[i] ? categorical.Y[1].highlights[i] : sliceWidth),
                                        label: labelFormatter.format(currentValue),
                                        color: color,
                                        identity: highlightIdentity,
                                        selected: !1,
                                        tooltipInfo: tooltipInfo,
                                        labelFontSize: fontSizeInPx,
                                        highlight: !0
                                    });
                                }
                            }
                            return dataPoints.length && {
                                dataPoints: dataPoints,
                                settings: settings,
                                hasHighlights: hasHighlights,
                                legendData: legendData,
                                highlightedDataPoints: highlightedDataPoints,
                                labelFormatter: labelFormatter,
                                centerText: categorical.Category.source.displayName
                            };
                        }
                    }, AsterPlot.parseSettings = function(dataView, categorySource) {
                        var settings = AsterPlotSettings.parse(dataView, AsterPlot.capabilities);
                        return settings.labels.precision = Math.min(17, Math.max(0, settings.labels.precision)), 
                        settings.outerLine.thickness = Math.min(300, Math.max(1, settings.outerLine.thickness)), 
                        settings.createOriginalSettings(), _.isEmpty(settings.legend.titleText) && (settings.legend.titleText = categorySource.displayName), 
                        settings;
                    }, Object.defineProperty(AsterPlot.prototype, "settings", {
                        get: function() {
                            return this.data && this.data.settings;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), AsterPlot.prototype.init = function(options) {
                        this.hostServices = options.host, this.layout = new VisualLayout(options.viewport, {
                            top: 10,
                            right: 10,
                            bottom: 15,
                            left: 10
                        });
                        var element = options.element, svg = this.svg = d3.select(element.get(0)).append("svg").classed(AsterPlotVisualClassName, !0).style("position", "absolute");
                        this.colors = options.style.colorPalette.dataColors, this.mainGroupElement = svg.append("g"), 
                        this.mainLabelsElement = svg.append("g"), this.behavior = new AsterPlotWebBehavior(), 
                        this.clearCatcher = appendClearCatcher(this.mainGroupElement), this.slicesElement = this.mainGroupElement.append("g").classed(AsterPlot.AsterSlices.class, !0);
                        var interactivity = options.interactivity;
                        this.interactivityService = createInteractivityService(this.hostServices), this.legend = createLegend(element, interactivity && interactivity.isInteractiveLegend, this.interactivityService, !0);
                    }, AsterPlot.prototype.update = function(options) {
                        if (options && options.dataViews && options.dataViews[0]) {
                            this.layout.viewport = options.viewport;
                            var duration = options.suppressAnimations ? 0 : MinervaAnimationDuration, data = AsterPlot.converter(options.dataViews[0], this.colors);
                            if (!data) return void this.clear();
                            this.data = data, this.interactivityService && (this.interactivityService.applySelectionStateToData(this.data.dataPoints), 
                            this.interactivityService.applySelectionStateToData(this.data.highlightedDataPoints)), 
                            this.renderLegend(), this.updateViewPortAccordingToLegend(), this.svg.attr(this.layout.viewport);
                            var transformX = (this.layout.viewportIn.width + this.layout.margin.right) / 2, transformY = (this.layout.viewportIn.height + this.layout.margin.bottom) / 2;
                            if (this.mainGroupElement.attr("transform", SVGUtil.translate(transformX, transformY)), 
                            this.mainLabelsElement.attr("transform", SVGUtil.translate(transformX, transformY)), 
                            this.clearCatcher.attr("transform", SVGUtil.translate(-transformX, -transformY)), 
                            dataLabelUtils.cleanDataLabels(this.mainLabelsElement, !0), this.renderArcsAndLabels(duration), 
                            this.data.hasHighlights ? this.renderArcsAndLabels(duration, !0) : this.slicesElement.selectAll(AsterPlot.AsterHighlightedSlice.selector).remove(), 
                            this.interactivityService) {
                                var behaviorOptions = {
                                    selection: this.slicesElement.selectAll(AsterPlot.AsterSlice.selector + ", " + AsterPlot.AsterHighlightedSlice.selector),
                                    clearCatcher: this.clearCatcher,
                                    interactivityService: this.interactivityService,
                                    hasHighlights: this.data.hasHighlights
                                };
                                this.interactivityService.bind(this.data.dataPoints.concat(this.data.highlightedDataPoints), this.behavior, behaviorOptions);
                            }
                        }
                    }, AsterPlot.prototype.renderArcsAndLabels = function(duration, isHighlight) {
                        var _this = this;
                        void 0 === isHighlight && (isHighlight = !1);
                        var viewportRadius = Math.min(this.layout.viewportIn.width, this.layout.viewportIn.height) / 2, innerRadius = .3 * (this.settings.labels.show ? viewportRadius * AsterRadiusRatio : viewportRadius), maxScore = d3.max(this.data.dataPoints, function(d) {
                            return d.sliceHeight;
                        }), totalWeight = d3.sum(this.data.dataPoints, function(d) {
                            return d.sliceWidth;
                        }), pie = d3.layout.pie().sort(null).value(function(dataPoint) {
                            return totalWeight && dataPoint && !isNaN(dataPoint.sliceWidth) ? dataPoint.sliceWidth / totalWeight : 0;
                        }), arc = d3.svg.arc().innerRadius(innerRadius).outerRadius(function(arcDescriptor) {
                            var height = 0;
                            if (maxScore) {
                                var radius = viewportRadius - innerRadius, sliceHeight = 1;
                                sliceHeight = arcDescriptor && arcDescriptor.data && !isNaN(arcDescriptor.data.sliceHeight) ? arcDescriptor.data.sliceHeight : sliceHeight, 
                                height = radius * sliceHeight / maxScore;
                            }
                            var heightIsLabelsOn = innerRadius + (_this.settings.labels.show ? height * AsterRadiusRatio : height);
                            return Math.max(heightIsLabelsOn, innerRadius);
                        }), arcDescriptorDataPoints = pie(isHighlight ? this.data.highlightedDataPoints : this.data.dataPoints), classSelector = isHighlight ? AsterPlot.AsterHighlightedSlice : AsterPlot.AsterSlice, selection = this.slicesElement.selectAll(classSelector.selector).data(arcDescriptorDataPoints, function(d, i) {
                            return d.data ? d.data.identity.getKey() : i;
                        });
                        if (selection.enter().append("path").classed(classSelector.class, !0).attr("stroke", "#333"), 
                        selection.attr("fill", function(d) {
                            return d.data.color;
                        }).call(function(selection) {
                            return Helpers.setAttrThroughTransitionIfNotResized(selection, function(s) {
                                return s.duration(duration);
                            }, "d", arc, Helpers.interpolateArc(arc), _this.layout.viewportChanged);
                        }), selection.exit().remove(), TooltipManager.addTooltip(selection, function(tooltipEvent) {
                            return tooltipEvent.data.data.tooltipInfo;
                        }), this.settings.labels.show && (!this.data.hasHighlights || this.data.hasHighlights && isHighlight)) {
                            var labelRadCalc = function(d) {
                                var height = viewportRadius * (d && !isNaN(d.sliceHeight) ? d.sliceHeight : 1) / maxScore + innerRadius;
                                return Math.max(height, innerRadius);
                            }, labelArc = d3.svg.arc().innerRadius(function(d) {
                                return labelRadCalc(d.data);
                            }).outerRadius(function(d) {
                                return labelRadCalc(d.data);
                            }), lineRadCalc = function(d) {
                                var height = (viewportRadius - innerRadius) * (d && !isNaN(d.sliceHeight) ? d.sliceHeight : 1) / maxScore;
                                return height = innerRadius + height * AsterRadiusRatio, Math.max(height, innerRadius);
                            }, outlineArc = d3.svg.arc().innerRadius(function(d) {
                                return lineRadCalc(d.data);
                            }).outerRadius(function(d) {
                                return lineRadCalc(d.data);
                            }), labelLayout = this.getLabelLayout(labelArc, this.layout.viewport);
                            this.drawLabels(arcDescriptorDataPoints.filter(function(x) {
                                return !isHighlight || null !== x.data.sliceHeight;
                            }), this.mainLabelsElement, labelLayout, this.layout.viewport, outlineArc, labelArc);
                        } else dataLabelUtils.cleanDataLabels(this.mainLabelsElement, !0);
                        return isHighlight || (this.drawCenterText(innerRadius), this.drawOuterLine(innerRadius, _.max(arcDescriptorDataPoints.map(function(d) {
                            return arc.outerRadius()(d);
                        })), arcDescriptorDataPoints)), selection;
                    }, AsterPlot.prototype.getLabelLayout = function(arc, viewport) {
                        var midAngle = function(d) {
                            return d.startAngle + (d.endAngle - d.startAngle) / 2;
                        }, textProperties = {
                            fontFamily: dataLabelUtils.StandardFontFamily,
                            fontSize: PixelConverter.fromPoint(this.settings.labels.fontSize),
                            text: ""
                        }, isLabelsHasConflict = function(d) {
                            var pos = arc.centroid(d);
                            textProperties.text = d.data.label;
                            var textWidth = TextMeasurementService.measureSvgTextWidth(textProperties), horizontalSpaceAvaliableForLabels = viewport.width / 2 - Math.abs(pos[0]), textHeight = TextMeasurementService.estimateSvgTextHeight(textProperties), verticalSpaceAvaliableForLabels = viewport.height / 2 - Math.abs(pos[1]);
                            return d.isLabelHasConflict = textWidth > horizontalSpaceAvaliableForLabels || textHeight > verticalSpaceAvaliableForLabels, 
                            d.isLabelHasConflict;
                        };
                        return {
                            labelText: function(d) {
                                textProperties.text = d.data.label;
                                var pos = arc.centroid(d), xPos = isLabelsHasConflict(d) ? pos[0] * AsterConflictRatio : pos[0], spaceAvaliableForLabels = viewport.width / 2 - Math.abs(xPos);
                                return TextMeasurementService.getTailoredTextOrDefault(textProperties, spaceAvaliableForLabels);
                            },
                            labelLayout: {
                                x: function(d) {
                                    var pos = arc.centroid(d);
                                    textProperties.text = d.data.label;
                                    var xPos = d.isLabelHasConflict ? pos[0] * AsterConflictRatio : pos[0];
                                    return xPos;
                                },
                                y: function(d) {
                                    var pos = arc.centroid(d), yPos = d.isLabelHasConflict ? pos[1] * AsterConflictRatio : pos[1];
                                    return yPos;
                                }
                            },
                            filter: function(d) {
                                return null != d && !_.isEmpty(d.data.label);
                            },
                            style: {
                                fill: this.settings.labels.color,
                                "font-size": textProperties.fontSize,
                                "text-anchor": function(d) {
                                    return midAngle(d) < Math.PI ? "start" : "end";
                                }
                            }
                        };
                    }, AsterPlot.prototype.drawLabels = function(data, context, layout, viewport, outlineArc, labelArc) {
                        var _this = this, dataLabelManager = new DataLabelManager(), filteredData = dataLabelManager.hideCollidedLabels(viewport, data, layout, !0);
                        if (0 === filteredData.length) return void dataLabelUtils.cleanDataLabels(context, !0);
                        context.select(AsterPlot.labelGraphicsContextClass.selector).empty() && context.append("g").classed(AsterPlot.labelGraphicsContextClass.class, !0);
                        var labels = context.select(AsterPlot.labelGraphicsContextClass.selector).selectAll(".data-labels").data(filteredData, function(d) {
                            return d.data.identity.getKey();
                        });
                        if (labels.enter().append("text").classed("data-labels", !0), labels) {
                            labels.attr({
                                x: function(d) {
                                    return d.labelX;
                                },
                                y: function(d) {
                                    return d.labelY;
                                },
                                dy: ".35em"
                            }).text(function(d) {
                                return d.labeltext;
                            }).style(layout.style), labels.exit().remove(), context.select(AsterPlot.linesGraphicsContextClass.selector).empty() && context.append("g").classed(AsterPlot.linesGraphicsContextClass.class, !0), 
                            filteredData = _.filter(filteredData, function(d) {
                                return null !== d.data.sliceHeight && 0 !== d.data.sliceHeight;
                            });
                            var lines = context.select(AsterPlot.linesGraphicsContextClass.selector).selectAll("polyline").data(filteredData, function(d) {
                                return d.data.identity.getKey();
                            }), labelLinePadding = 4, chartLinePadding = 1.02, midAngle = function(d) {
                                return d.startAngle + (d.endAngle - d.startAngle) / 2;
                            };
                            lines.enter().append("polyline").classed("line-label", !0), lines.attr("points", function(d) {
                                var textPoint = [ d.labelX, d.labelY ];
                                textPoint[0] = textPoint[0] + (midAngle(d) < Math.PI ? -1 : 1) * labelLinePadding;
                                var chartPoint = outlineArc.centroid(d);
                                return chartPoint[0] *= chartLinePadding, chartPoint[1] *= chartLinePadding, [ chartPoint, textPoint ];
                            }).style({
                                opacity: .5,
                                "fill-opacity": 0,
                                stroke: function(d) {
                                    return _this.settings.labels.color;
                                }
                            }), lines.exit().remove();
                        }
                    }, AsterPlot.prototype.renderLegend = function() {
                        if (this.settings.legend.show) {
                            var legendObject = _.clone(this.settings.legend);
                            legendObject.labelColor = {
                                solid: {
                                    color: legendObject.labelColor
                                }
                            }, LegendData.update(this.data.legendData, legendObject), this.legend.changeOrientation(LegendPosition[this.settings.legend.position]);
                        }
                        this.legend.drawLegend(this.data.legendData, this.layout.viewportCopy), Legend.positionChartArea(this.svg, this.legend);
                    }, AsterPlot.prototype.updateViewPortAccordingToLegend = function() {
                        if (this.settings.legend.show) {
                            var legendMargins = this.legend.getMargins(), legendPosition = LegendPosition[this.settings.legend.position];
                            switch (legendPosition) {
                              case LegendPosition.Top:
                              case LegendPosition.TopCenter:
                              case LegendPosition.Bottom:
                              case LegendPosition.BottomCenter:
                                this.layout.viewport.height -= legendMargins.height;
                                break;

                              case LegendPosition.Left:
                              case LegendPosition.LeftCenter:
                              case LegendPosition.Right:
                              case LegendPosition.RightCenter:
                                this.layout.viewport.width -= legendMargins.width;
                            }
                        }
                    }, AsterPlot.prototype.drawOuterLine = function(innerRadius, radius, data) {
                        var mainGroup = this.mainGroupElement, outlineArc = d3.svg.arc().innerRadius(innerRadius).outerRadius(radius);
                        if (this.settings.outerLine.show) {
                            var OuterThickness = this.settings.outerLine.thickness + "px", outerLine = mainGroup.selectAll(AsterPlot.OuterLine.selector).data(data);
                            outerLine.enter().append("path"), outerLine.attr("fill", "none").attr({
                                stroke: "#333",
                                "stroke-width": OuterThickness,
                                d: outlineArc
                            }).style("opacity", 1).classed(AsterPlot.OuterLine.class, !0), outerLine.exit().remove();
                        } else mainGroup.selectAll(AsterPlot.OuterLine.selector).remove();
                    }, AsterPlot.prototype.drawCenterText = function(innerRadius) {
                        if (_.isEmpty(this.data.centerText)) return void this.mainGroupElement.select(AsterPlot.CenterLabelClass.selector).remove();
                        var centerTextProperties = {
                            fontFamily: dataLabelUtils.StandardFontFamily,
                            fontWeight: "bold",
                            fontSize: PixelConverter.toString(innerRadius * AsterPlot.CenterTextFontHeightCoefficient),
                            text: this.data.centerText
                        };
                        this.mainGroupElement.select(AsterPlot.CenterLabelClass.selector).empty() && (this.centerText = this.mainGroupElement.append("text").classed(AsterPlot.CenterLabelClass.class, !0)), 
                        this.centerText.style({
                            "line-height": 1,
                            "font-weight": centerTextProperties.fontWeight,
                            "font-size": centerTextProperties.fontSize,
                            fill: this.settings.labels.color
                        }).attr({
                            dy: "0.35em",
                            "text-anchor": "middle"
                        }).text(TextMeasurementService.getTailoredTextOrDefault(centerTextProperties, innerRadius * AsterPlot.CenterTextFontWidthCoefficient));
                    }, AsterPlot.prototype.clear = function() {
                        this.mainGroupElement.selectAll("path").remove(), this.mainGroupElement.select(AsterPlot.CenterLabelClass.selector).remove(), 
                        dataLabelUtils.cleanDataLabels(this.mainLabelsElement, !0), this.legend.drawLegend({
                            dataPoints: []
                        }, this.layout.viewportCopy);
                    }, AsterPlot.prototype.onClearSelection = function() {
                        this.interactivityService && this.interactivityService.clearSelection();
                    }, AsterPlot.prototype.enumerateObjectInstances = function(options) {
                        var instances = AsterPlotSettings.enumerateObjectInstances(this.settings && this.settings.originalSettings, options, AsterPlot.capabilities);
                        return instances.complete();
                    }, AsterPlot.capabilities = {
                        dataRoles: [ {
                            displayName: "Category",
                            name: AsterPlotColumns.Roles.Category,
                            kind: VisualDataRoleKind.Grouping
                        }, {
                            displayName: "Y Axis",
                            name: AsterPlotColumns.Roles.Y,
                            kind: VisualDataRoleKind.Measure
                        } ],
                        dataViewMappings: [ {
                            conditions: [ {
                                Category: {
                                    max: 1
                                },
                                Y: {
                                    max: 2
                                }
                            } ],
                            categorical: {
                                categories: {
                                    for: {
                                        in: "Category"
                                    },
                                    dataReductionAlgorithm: {
                                        top: {}
                                    }
                                },
                                values: {
                                    select: [ {
                                        bind: {
                                            to: "Y"
                                        }
                                    } ]
                                }
                            }
                        } ],
                        objects: {
                            general: {
                                displayName: "General",
                                properties: {
                                    formatString: {
                                        type: {
                                            formatting: {
                                                formatString: !0
                                            }
                                        }
                                    }
                                }
                            },
                            legend: {
                                displayName: "Legend",
                                description: "Display legend options",
                                properties: {
                                    show: {
                                        displayName: "Show",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    position: {
                                        displayName: "Position",
                                        description: "Select the location for the legend",
                                        type: {
                                            enumeration: legendPosition.type
                                        }
                                    },
                                    showTitle: {
                                        displayName: "Title",
                                        description: "Display a title for legend symbols",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    titleText: {
                                        displayName: "Legend Name",
                                        description: "Title text",
                                        type: {
                                            text: !0
                                        },
                                        suppressFormatPainterCopy: !0
                                    },
                                    labelColor: {
                                        displayName: "Color",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    fontSize: {
                                        displayName: "Text Size",
                                        type: {
                                            formatting: {
                                                fontSize: !0
                                            }
                                        }
                                    }
                                }
                            },
                            label: {
                                displayName: "Center Label",
                                properties: {
                                    fill: {
                                        displayName: "Fill",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    }
                                }
                            },
                            labels: {
                                displayName: "Detail Labels",
                                properties: {
                                    show: {
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    color: {
                                        displayName: "Color",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    displayUnits: {
                                        displayName: "Display Units",
                                        type: {
                                            formatting: {
                                                displayUnits: !0
                                            }
                                        }
                                    },
                                    precision: {
                                        displayName: "Decimal Places",
                                        placeHolderText: "Auto",
                                        type: {
                                            numeric: !0
                                        }
                                    },
                                    fontSize: {
                                        displayName: "Text Size",
                                        type: {
                                            formatting: {
                                                fontSize: !0
                                            }
                                        }
                                    }
                                }
                            },
                            outerLine: {
                                displayName: "Outer line",
                                properties: {
                                    show: {
                                        displayName: "Show",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    thickness: {
                                        displayName: "Thickness",
                                        type: {
                                            numeric: !0
                                        }
                                    }
                                }
                            }
                        },
                        supportsHighlight: !0
                    }, AsterPlot.AsterSlices = createClassAndSelector("asterSlices"), AsterPlot.AsterSlice = createClassAndSelector("asterSlice"), 
                    AsterPlot.AsterHighlightedSlice = createClassAndSelector("asterHighlightedSlice"), 
                    AsterPlot.OuterLine = createClassAndSelector("outerLine"), AsterPlot.labelGraphicsContextClass = createClassAndSelector("labels"), 
                    AsterPlot.linesGraphicsContextClass = createClassAndSelector("lines"), AsterPlot.CenterLabelClass = createClassAndSelector("centerLabel"), 
                    AsterPlot.CenterTextFontHeightCoefficient = .4, AsterPlot.CenterTextFontWidthCoefficient = 1.9, 
                    AsterPlot;
                }();
                samples.AsterPlot = AsterPlot;
                var asterPlotUtils;
                !function(asterPlotUtils) {
                    function getFillOpacity(selected, highlight, hasSelection, hasPartialHighlights) {
                        return hasPartialHighlights && !highlight || hasSelection && !selected ? asterPlotUtils.DimmedOpacity : asterPlotUtils.DefaultOpacity;
                    }
                    asterPlotUtils.DimmedOpacity = .4, asterPlotUtils.DefaultOpacity = 1, asterPlotUtils.getFillOpacity = getFillOpacity;
                }(asterPlotUtils = samples.asterPlotUtils || (samples.asterPlotUtils = {}));
            }(samples = visuals.samples || (visuals.samples = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, jsCommon = window.jsCommon, powerbi = window.powerbi;
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var samples;
            !function(samples) {
                function getTornadoChartWarning() {
                    return new TornadoChartWarning();
                }
                var PixelConverter = jsCommon.PixelConverter, SelectionId = powerbi.visuals.SelectionId, LegendData = powerbi.visuals.LegendData, DataViewObject = powerbi.DataViewObject, SVGUtil = powerbi.visuals.SVGUtil, VisualDataRoleKind = powerbi.VisualDataRoleKind, createDisplayNameGetter = powerbi.data.createDisplayNameGetter, legendPosition = powerbi.visuals.legendPosition, dataLabelUtils = powerbi.visuals.dataLabelUtils, TextMeasurementService = powerbi.TextMeasurementService, valueFormatter = powerbi.visuals.valueFormatter, SelectionIdBuilder = powerbi.visuals.SelectionIdBuilder, TooltipBuilder = powerbi.visuals.TooltipBuilder, DataViewObjects = powerbi.DataViewObjects, ColorHelper = powerbi.visuals.ColorHelper, createInteractivityService = powerbi.visuals.createInteractivityService, appendClearCatcher = powerbi.visuals.appendClearCatcher, createLegend = powerbi.visuals.createLegend, GetAnimationDuration = powerbi.visuals.AnimatorCommon.GetAnimationDuration, LegendIcon = powerbi.visuals.LegendIcon, LegendPosition = powerbi.visuals.LegendPosition, legendProps = powerbi.visuals.legendProps, TooltipManager = powerbi.visuals.TooltipManager, Legend = powerbi.visuals.Legend, ObjectEnumerationBuilder = powerbi.visuals.ObjectEnumerationBuilder, TornadoWebBehavior = function() {
                    function TornadoWebBehavior() {}
                    return TornadoWebBehavior.prototype.bindEvents = function(options, selectionHandler) {
                        this.columns = options.columns, this.clearCatcher = options.clearCatcher, this.interactivityService = options.interactivityService, 
                        this.columns.on("click", function(d, i) {
                            selectionHandler.handleSelection(d, d3.event.ctrlKey);
                        }), this.clearCatcher.on("click", function() {
                            selectionHandler.handleClearSelection();
                        });
                    }, TornadoWebBehavior.prototype.renderSelection = function(hasSelection) {
                        var hasHighlights = this.interactivityService.hasSelection();
                        this.columns.style("fill-opacity", function(d) {
                            return tornadoChartUtils.getFillOpacity(d.selected, d.highlight, !d.highlight && hasSelection, !d.selected && hasHighlights);
                        });
                    }, TornadoWebBehavior;
                }(), TornadoChartScrolling = function() {
                    function TornadoChartScrolling(getRoot, getViewport, getMargin, getPrefferedHeight, isScrollable) {
                        this.scrollYBrush = d3.svg.brush(), this.getRoot = getRoot, this.getViewport = getViewport, 
                        this.isScrollable = isScrollable, this.getPrefferedHeight = getPrefferedHeight;
                    }
                    return Object.defineProperty(TornadoChartScrolling.prototype, "scrollViewport", {
                        get: function() {
                            return {
                                height: this.viewport.height,
                                width: this.viewport.width - (this.isYScrollBarVisible && this.isScrollable ? TornadoChart.ScrollBarWidth : 0)
                            };
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(TornadoChartScrolling.prototype, "root", {
                        get: function() {
                            return this.getRoot();
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(TornadoChartScrolling.prototype, "viewport", {
                        get: function() {
                            return this.getViewport();
                        },
                        enumerable: !0,
                        configurable: !0
                    }), TornadoChartScrolling.prototype.renderY = function(data, onScroll) {
                        var _this = this;
                        if (this.isYScrollBarVisible = this.isScrollable && this.getPrefferedHeight() > this.viewport.height && this.viewport.height > 0 && this.viewport.width > 0, 
                        this.brushGraphicsContextY = this.createOrRemoveScrollbar(this.isYScrollBarVisible, this.brushGraphicsContextY, "y brush"), 
                        !this.isYScrollBarVisible) return void onScroll.call(this, jQuery.extend(!0, {}, data), 0, 1);
                        var scrollSpaceLength = this.viewport.height, extentData = this.getExtentData(this.getPrefferedHeight(), scrollSpaceLength), onRender = function(wheelDelta) {
                            void 0 === wheelDelta && (wheelDelta = 0);
                            var position = _this.scrollYBrush.extent();
                            if (0 !== wheelDelta) {
                                var halfScrollsize = (position[1] - position[0]) / 2;
                                if (position[0] += wheelDelta > 0 ? halfScrollsize : -halfScrollsize, position[1] += wheelDelta > 0 ? halfScrollsize : -halfScrollsize, 
                                position[0] < 0) {
                                    var offset = 0 - position[0];
                                    position[0] += offset, position[1] += offset;
                                }
                                if (position[1] > scrollSpaceLength) {
                                    var offset = position[1] - scrollSpaceLength;
                                    position[0] -= offset, position[1] -= offset;
                                }
                                _this.scrollYBrush.extent(position), _this.brushGraphicsContextY.select(".extent").attr("y", position[0]);
                            }
                            var scrollPosition = extentData.toScrollPosition(position, scrollSpaceLength);
                            onScroll.call(_this, jQuery.extend(!0, {}, data), scrollPosition[0], scrollPosition[1]), 
                            _this.setScrollBarSize(_this.brushGraphicsContextY, extentData.value[1], !0);
                        }, scrollYScale = d3.scale.ordinal().rangeBands([ 0, scrollSpaceLength ]);
                        this.scrollYBrush.y(scrollYScale).extent(extentData.value), this.renderScrollbar(this.scrollYBrush, this.brushGraphicsContextY, this.viewport.width, onRender), 
                        onRender();
                    }, TornadoChartScrolling.prototype.createOrRemoveScrollbar = function(isVisible, brushGraphicsContext, brushClass) {
                        return isVisible && this.isScrollable ? brushGraphicsContext || this.root.append("g").classed(brushClass, !0) : brushGraphicsContext ? void brushGraphicsContext.remove() : void 0;
                    }, TornadoChartScrolling.prototype.renderScrollbar = function(brush, brushGraphicsContext, brushX, onRender) {
                        var _this = this;
                        brush.on("brush", function() {
                            return window.requestAnimationFrame(function() {
                                return onRender(0);
                            });
                        }), this.root.on("wheel", function() {
                            if (_this.isYScrollBarVisible) {
                                var wheelEvent = d3.event;
                                onRender(wheelEvent.deltaY);
                            }
                        }), brushGraphicsContext.attr({
                            transform: SVGUtil.translate(brushX, 0),
                            "drag-resize-disabled": "true"
                        }), brushGraphicsContext.call(brush), brushGraphicsContext.selectAll(".resize").remove(), 
                        brushGraphicsContext.select(".background").remove(), brushGraphicsContext.selectAll(".extent").style({
                            "fill-opacity": .125,
                            cursor: "default"
                        });
                    }, TornadoChartScrolling.prototype.setScrollBarSize = function(brushGraphicsContext, minExtent, isVertical) {
                        brushGraphicsContext.selectAll("rect").attr(isVertical ? "width" : "height", TornadoChart.ScrollBarWidth), 
                        brushGraphicsContext.selectAll("rect").attr(isVertical ? "height" : "width", minExtent);
                    }, TornadoChartScrolling.prototype.getExtentData = function(svgLength, scrollSpaceLength) {
                        var value = scrollSpaceLength * scrollSpaceLength / svgLength, scaleMultipler = TornadoChartScrolling.ScrollBarMinLength <= value ? 1 : value / TornadoChartScrolling.ScrollBarMinLength;
                        value = Math.max(value, TornadoChartScrolling.ScrollBarMinLength);
                        var toScrollPosition = function(extent, scrollSpaceLength) {
                            var scrollSize = extent[1] - extent[0], scrollPosition = extent[0] / (scrollSpaceLength - scrollSize);
                            scrollSize *= scaleMultipler;
                            var start = scrollPosition * (scrollSpaceLength - scrollSize), end = start + scrollSize;
                            return [ start / scrollSpaceLength, end / scrollSpaceLength ];
                        };
                        return {
                            value: [ 0, value ],
                            toScrollPosition: toScrollPosition
                        };
                    }, TornadoChartScrolling.prototype.clearData = function() {
                        this.brushGraphicsContextY && this.brushGraphicsContextY.selectAll("*").remove();
                    }, TornadoChartScrolling.ScrollBarMinLength = 15, TornadoChartScrolling;
                }(), TornadoChartWarning = function() {
                    function TornadoChartWarning() {}
                    return Object.defineProperty(TornadoChartWarning.prototype, "code", {
                        get: function() {
                            return "TornadoChartWarning";
                        },
                        enumerable: !0,
                        configurable: !0
                    }), TornadoChartWarning.prototype.getMessages = function(resourceProvider) {
                        var visualMessage, message = "This visual requires two distinct values to be returned for the Legend field.", titleKey = "", detailKey = "";
                        return visualMessage = {
                            message: message,
                            title: resourceProvider.get(titleKey),
                            detail: resourceProvider.get(detailKey)
                        };
                    }, TornadoChartWarning;
                }();
                samples.TornadoChartWarning = TornadoChartWarning, samples.getTornadoChartWarning = getTornadoChartWarning;
                var TornadoChart = function() {
                    function TornadoChart(tornadoChartConstructorOptions) {
                        this.textOptions = {}, this.columnPadding = 5, this.leftLabelMargin = 4, this.InnerTextHeightDelta = 2, 
                        this.margin = {
                            top: 10,
                            right: 5,
                            bottom: 10,
                            left: 10
                        }, this.heightColumn = 0, tornadoChartConstructorOptions && (this.svg = tornadoChartConstructorOptions.svg || this.svg, 
                        this.margin = tornadoChartConstructorOptions.margin || this.margin, this.columnPadding = tornadoChartConstructorOptions.columnPadding || this.columnPadding, 
                        this.animator = tornadoChartConstructorOptions.animator);
                    }
                    return TornadoChart.getProperties = function(capabilities) {
                        var result = {};
                        for (var objectKey in capabilities.objects) {
                            result[objectKey] = {};
                            for (var propKey in capabilities.objects[objectKey].properties) result[objectKey][propKey] = {
                                objectName: objectKey,
                                propertyName: propKey
                            };
                        }
                        return result;
                    }, TornadoChart.converter = function(dataView, textOptions, colors) {
                        if (!(dataView && dataView.categorical && dataView.categorical.categories && dataView.categorical.categories[0] && dataView.categorical.categories[0].source && dataView.categorical.values && dataView.categorical.values[0])) return null;
                        var categorical = dataView.categorical, categories = categorical.categories || [], values = categorical.values, category = categories[0], formatStringProp = TornadoChart.Properties.general.formatString, maxValue = d3.max(values[0].values), settings = TornadoChart.parseSettings(dataView.metadata.objects, maxValue, colors), hasDynamicSeries = !!values.source, hasHighlights = !!(values.length > 0 && values[0].highlights), labelHeight = TextMeasurementService.estimateSvgTextHeight({
                            fontFamily: dataLabelUtils.StandardFontFamily,
                            fontSize: PixelConverter.fromPoint(settings.labelSettings.fontSize)
                        }), series = [], dataPoints = [], highlightedDataPoints = [], categorySourceFormatString = valueFormatter.getFormatString(category.source, formatStringProp), categoriesLabels = category.values.map(function(value) {
                            var formattedCategoryValue = valueFormatter.format(value, categorySourceFormatString);
                            return TornadoChart.getTextData(formattedCategoryValue, textOptions, !0);
                        }), groupedValues = values.grouped ? values.grouped() : null, minValue = Math.min(d3.min(values[0].values), 0);
                        values.length === TornadoChart.MaxSeries && (minValue = d3.min([ minValue, d3.min(values[1].values) ]), 
                        maxValue = d3.max([ maxValue, d3.max(values[1].values) ]));
                        for (var seriesIndex = 0; seriesIndex < values.length; seriesIndex++) {
                            var columnGroup = groupedValues && groupedValues.length > seriesIndex && groupedValues[seriesIndex].values ? groupedValues[seriesIndex] : null, parsedSeries = TornadoChart.parseSeries(values, seriesIndex, hasDynamicSeries, columnGroup, colors);
                            series.push(parsedSeries);
                            for (var currentSeries = values[seriesIndex], measureName = currentSeries.source.queryName, i = 0; i < category.values.length; i++) {
                                var tooltipInfo, value = null == currentSeries.values[i] || isNaN(currentSeries.values[i]) ? 0 : currentSeries.values[i], identity = SelectionIdBuilder.builder().withCategory(category, i).withSeries(values, columnGroup).withMeasure(measureName).createSelectionId(), formattedCategoryValue = categoriesLabels[i].text;
                                tooltipInfo = TooltipBuilder.createTooltipInfo(formatStringProp, categorical, formattedCategoryValue, value, null, null, seriesIndex, i, null);
                                var currentMaxValue = parsedSeries.categoryAxisEnd ? parsedSeries.categoryAxisEnd : maxValue, formatString = dataView.categorical.values[seriesIndex].source.format;
                                if (dataPoints.push({
                                    value: value,
                                    minValue: minValue,
                                    maxValue: currentMaxValue,
                                    formatString: formatString,
                                    color: parsedSeries.fill,
                                    selected: !1,
                                    identity: identity,
                                    tooltipData: tooltipInfo,
                                    categoryIndex: i
                                }), hasHighlights) {
                                    var highlightIdentity = SelectionId.createWithHighlight(identity), highlight = currentSeries.highlights[i], highlightedValue = null != highlight ? highlight : 0;
                                    tooltipInfo = TooltipBuilder.createTooltipInfo(formatStringProp, categorical, formattedCategoryValue, value, null, null, seriesIndex, i, highlightedValue), 
                                    highlightedDataPoints.push({
                                        value: highlightedValue,
                                        minValue: minValue,
                                        maxValue: currentMaxValue,
                                        formatString: formatString,
                                        color: parsedSeries.fill,
                                        selected: !1,
                                        identity: highlightIdentity,
                                        tooltipData: tooltipInfo,
                                        categoryIndex: i,
                                        highlight: !0
                                    });
                                }
                            }
                        }
                        return {
                            categories: categoriesLabels,
                            series: series,
                            settings: settings,
                            legend: TornadoChart.getLegendData(series, hasDynamicSeries),
                            dataPoints: dataPoints,
                            highlightedDataPoints: highlightedDataPoints,
                            maxLabelsWidth: _.max(categoriesLabels.map(function(x) {
                                return x.width;
                            })),
                            hasDynamicSeries: hasDynamicSeries,
                            hasHighlights: hasHighlights,
                            labelHeight: labelHeight,
                            legendObjectProperties: DataViewObjects.getObject(dataView.metadata.objects, "legend", {})
                        };
                    }, TornadoChart.parseSeries = function(dataViewValueColumns, index, isGrouped, columnGroup, colors) {
                        var objects, categoryAxisObject, dataViewValueColumn = dataViewValueColumns ? dataViewValueColumns[index] : null, source = dataViewValueColumn ? dataViewValueColumn.source : null, identity = columnGroup ? columnGroup.identity : null, queryName = source ? source.queryName : null, selectionId = identity ? SelectionId.createWithId(identity) : SelectionIdBuilder.builder().withSeries(dataViewValueColumns, columnGroup).withMeasure(queryName).createSelectionId(), displayName = source ? source.groupName ? source.groupName : source.displayName : null;
                        isGrouped && columnGroup ? (categoryAxisObject = columnGroup.objects ? columnGroup.objects.categoryAxis : null, 
                        objects = columnGroup.objects) : source && (objects = source.objects, categoryAxisObject = objects ? objects.categoryAxis : null);
                        var color = TornadoChart.getColor(TornadoChart.Properties.dataPoint.fill, [ "purple", "teal" ][index], objects, colors), categoryAxisEnd = categoryAxisObject ? categoryAxisObject.end : null;
                        return {
                            fill: color,
                            name: displayName,
                            selectionId: selectionId,
                            categoryAxisEnd: categoryAxisEnd
                        };
                    }, TornadoChart.getColor = function(properties, defaultColor, objects, colors) {
                        var colorHelper = new ColorHelper(colors, properties, defaultColor);
                        return colorHelper.getColorForMeasure(objects, "");
                    }, TornadoChart.getTextData = function(text, textOptions, measureWidth, measureHeight, overrideFontSize) {
                        void 0 === measureWidth && (measureWidth = !1), void 0 === measureHeight && (measureHeight = !1);
                        var fontSize, textProperties, width = 0, height = 0;
                        return text = text || "", fontSize = overrideFontSize ? PixelConverter.fromPoint(overrideFontSize) : "" + textOptions.fontSize + textOptions.sizeUnit, 
                        textProperties = {
                            text: text,
                            fontFamily: textOptions.fontFamily,
                            fontSize: fontSize
                        }, measureWidth && (width = TextMeasurementService.measureSvgTextWidth(textProperties)), 
                        measureHeight && (height = TextMeasurementService.estimateSvgTextHeight(textProperties)), 
                        {
                            text: text,
                            width: width,
                            height: height,
                            textProperties: textProperties
                        };
                    }, Object.defineProperty(TornadoChart.prototype, "allLabelsWidth", {
                        get: function() {
                            return (this.dataView.settings.showCategories ? Math.min(this.dataView.maxLabelsWidth, this.scrolling.scrollViewport.width / 2) : 3) + TornadoChart.CategoryLabelMargin;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(TornadoChart.prototype, "allColumnsWidth", {
                        get: function() {
                            return this.scrolling.scrollViewport.width - this.allLabelsWidth;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(TornadoChart.prototype, "columnWidth", {
                        get: function() {
                            return this.dataView.series.length === TornadoChart.MaxSeries ? this.allColumnsWidth / 2 : this.allColumnsWidth;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), TornadoChart.prototype.init = function(visualInitOptions) {
                        var fontSize, _this = this, style = visualInitOptions.style;
                        this.hostService = visualInitOptions.host;
                        var element = visualInitOptions.element;
                        this.colors = style.colorPalette.dataColors;
                        var interactivity = visualInitOptions.interactivity;
                        this.interactivityService = createInteractivityService(this.hostService);
                        var root;
                        this.svg ? this.root = root = this.svg : this.root = root = d3.select(element.get(0)).append("svg"), 
                        root.classed(TornadoChart.ClassName, !0).style("position", "absolute"), fontSize = root.style("font-size"), 
                        this.textOptions.sizeUnit = fontSize.slice(fontSize.length - 2), this.textOptions.fontSize = Number(fontSize.slice(0, fontSize.length - 2)), 
                        this.textOptions.fontFamily = root.style("font-family"), this.viewport = visualInitOptions.viewport, 
                        this.scrolling = new TornadoChartScrolling(function() {
                            return root;
                        }, function() {
                            return _this.viewport;
                        }, function() {
                            return _this.margin;
                        }, function() {
                            return _this.dataView.categories.length * TornadoChart.CategoryMinHeight;
                        }, (!0));
                        var main = this.main = root.append("g");
                        this.clearCatcher = appendClearCatcher(main), this.columns = main.append("g").classed(TornadoChart.Columns.class, !0), 
                        this.axes = main.append("g").classed(TornadoChart.Axes.class, !0), this.labels = main.append("g").classed(TornadoChart.Labels.class, !0), 
                        this.categories = main.append("g").classed(TornadoChart.Categories.class, !0), this.behavior = new TornadoWebBehavior(), 
                        this.legend = createLegend(element, interactivity && interactivity.isInteractiveLegend, this.interactivityService, !0);
                    }, TornadoChart.prototype.update = function(visualUpdateOptions) {
                        if (visualUpdateOptions && visualUpdateOptions.dataViews && visualUpdateOptions.dataViews[0]) {
                            if (this.viewport = {
                                height: Math.max(0, visualUpdateOptions.viewport.height - this.margin.top - this.margin.bottom),
                                width: Math.max(0, visualUpdateOptions.viewport.width - this.margin.left - this.margin.right)
                            }, this.animator ? this.durationAnimations = GetAnimationDuration(this.animator, visualUpdateOptions.suppressAnimations) : this.durationAnimations = visualUpdateOptions.suppressAnimations ? 0 : 250, 
                            this.dataView = TornadoChart.converter(this.validateDataView(visualUpdateOptions.dataViews[0]), this.textOptions, this.colors), 
                            !this.dataView || this.scrolling.scrollViewport.height < TornadoChart.CategoryMinHeight) return void this.clearData();
                            this.dataView && this.interactivityService && (this.interactivityService.applySelectionStateToData(this.dataView.dataPoints), 
                            this.interactivityService.applySelectionStateToData(this.dataView.highlightedDataPoints)), 
                            this.render();
                        }
                    }, TornadoChart.prototype.validateDataView = function(dataView) {
                        return dataView && dataView.categorical && dataView.categorical.values ? dataView.categorical.values.length > TornadoChart.MaxSeries ? (this.hostService.setWarnings([ getTornadoChartWarning() ]), 
                        null) : dataView : null;
                    }, TornadoChart.prototype.updateElements = function() {
                        var elementsTranslate = SVGUtil.translate(this.allLabelsWidth, 0);
                        this.root.attr({
                            height: this.viewport.height + this.margin.top + this.margin.bottom,
                            width: this.viewport.width + this.margin.left + this.margin.right
                        }), this.columns.attr("transform", elementsTranslate), this.labels.attr("transform", elementsTranslate), 
                        this.axes.attr("transform", elementsTranslate);
                    }, TornadoChart.parseSettings = function(objects, value, colors) {
                        var precision = TornadoChart.getPrecision(objects), displayUnits = DataViewObjects.getValue(objects, TornadoChart.Properties.labels.labelDisplayUnits, TornadoChart.DefaultTornadoChartSettings.labelSettings.displayUnits), labelSettings = TornadoChart.DefaultTornadoChartSettings.labelSettings, getLabelValueFormatter = function(formatString) {
                            return valueFormatter.create({
                                format: formatString,
                                precision: precision,
                                value: 0 === displayUnits && null != value ? value : displayUnits
                            });
                        };
                        return {
                            labelOutsideFillColor: TornadoChart.getColor(TornadoChart.Properties.labels.outsideFill, TornadoChart.DefaultTornadoChartSettings.labelOutsideFillColor, objects, colors),
                            labelSettings: {
                                show: DataViewObjects.getValue(objects, TornadoChart.Properties.labels.show, labelSettings.show),
                                precision: precision,
                                fontSize: DataViewObjects.getValue(objects, TornadoChart.Properties.labels.fontSize, labelSettings.fontSize),
                                displayUnits: displayUnits,
                                labelColor: TornadoChart.getColor(TornadoChart.Properties.labels.insideFill, labelSettings.labelColor, objects, colors)
                            },
                            showCategories: DataViewObjects.getValue(objects, TornadoChart.Properties.categories.show, TornadoChart.DefaultTornadoChartSettings.showCategories),
                            showLegend: DataViewObjects.getValue(objects, TornadoChart.Properties.legend.show, TornadoChart.DefaultTornadoChartSettings.showLegend),
                            legendFontSize: DataViewObjects.getValue(objects, TornadoChart.Properties.legend.fontSize, TornadoChart.DefaultTornadoChartSettings.legendFontSize),
                            legendColor: TornadoChart.getColor(TornadoChart.Properties.legend.labelColor, TornadoChart.DefaultTornadoChartSettings.legendColor, objects, colors),
                            categoriesFillColor: TornadoChart.getColor(TornadoChart.Properties.categories.fill, TornadoChart.DefaultTornadoChartSettings.categoriesFillColor, objects, colors),
                            getLabelValueFormatter: getLabelValueFormatter
                        };
                    }, TornadoChart.getPrecision = function(objects) {
                        var precision = DataViewObjects.getValue(objects, TornadoChart.Properties.labels.labelPrecision, TornadoChart.DefaultTornadoChartSettings.labelSettings.precision);
                        return Math.min(Math.max(0, precision), TornadoChart.MaxPrecision);
                    }, TornadoChart.getLegendData = function(series, hasDynamicSeries) {
                        var legendDataPoints = [];
                        return hasDynamicSeries && (legendDataPoints = series.map(function(series) {
                            return {
                                label: series.name,
                                color: series.fill,
                                icon: LegendIcon.Box,
                                selected: !1,
                                identity: series.selectionId
                            };
                        })), {
                            dataPoints: legendDataPoints
                        };
                    }, TornadoChart.prototype.render = function() {
                        this.updateElements(), this.renderLegend(), this.scrolling.renderY(this.dataView, this.renderWithScrolling.bind(this));
                    }, TornadoChart.prototype.clearData = function() {
                        this.columns.selectAll("*").remove(), this.axes.selectAll("*").remove(), this.labels.selectAll("*").remove(), 
                        this.categories.selectAll("*").remove(), this.legend.drawLegend({
                            dataPoints: []
                        }, this.viewport), this.scrolling.clearData();
                    }, TornadoChart.prototype.onClearSelection = function() {
                        this.interactivityService && this.interactivityService.clearSelection();
                    }, TornadoChart.prototype.renderWithScrolling = function(tornadoChartDataView, scrollStart, scrollEnd) {
                        if (this.dataView && this.dataView.settings) {
                            var categoriesLength = tornadoChartDataView.categories.length, startIndex = scrollStart * categoriesLength, endIndex = scrollEnd * categoriesLength, startIndexRound = Math.floor(startIndex), endIndexRound = Math.floor(endIndex), maxValues = Math.floor(this.scrolling.scrollViewport.height / TornadoChart.CategoryMinHeight);
                            scrollEnd - scrollStart < 1 && maxValues < endIndexRound - startIndexRound && (startIndex - startIndexRound > endIndex - endIndexRound ? startIndexRound++ : endIndex--), 
                            this.interactivityService && (this.interactivityService.applySelectionStateToData(tornadoChartDataView.dataPoints), 
                            this.interactivityService.applySelectionStateToData(tornadoChartDataView.highlightedDataPoints)), 
                            tornadoChartDataView.categories = tornadoChartDataView.categories.slice(startIndexRound, endIndexRound), 
                            tornadoChartDataView.dataPoints = _.filter(tornadoChartDataView.dataPoints, function(d) {
                                return d.categoryIndex >= startIndexRound && d.categoryIndex < endIndexRound;
                            }), tornadoChartDataView.highlightedDataPoints = _.filter(tornadoChartDataView.highlightedDataPoints, function(d) {
                                return d.categoryIndex >= startIndexRound && d.categoryIndex < endIndexRound;
                            }), this.dataView = tornadoChartDataView, this.computeHeightColumn(), this.renderMiddleSection(), 
                            this.renderAxes(), this.renderCategories();
                        }
                    }, TornadoChart.prototype.updateViewport = function() {
                        var legendPosition, legendMargins = this.legend.getMargins();
                        switch (legendPosition = LegendPosition[this.dataView.legendObjectProperties[legendProps.position]]) {
                          case LegendPosition.Top:
                          case LegendPosition.TopCenter:
                          case LegendPosition.Bottom:
                          case LegendPosition.BottomCenter:
                            this.viewport.height -= legendMargins.height;
                            break;

                          case LegendPosition.Left:
                          case LegendPosition.LeftCenter:
                          case LegendPosition.Right:
                          case LegendPosition.RightCenter:
                            this.viewport.width -= legendMargins.width;
                        }
                    }, TornadoChart.prototype.computeHeightColumn = function() {
                        var length = this.dataView.categories.length;
                        this.heightColumn = (this.scrolling.scrollViewport.height - (length - 1) * this.columnPadding) / length;
                    }, TornadoChart.prototype.renderMiddleSection = function() {
                        var tornadoChartDataView = this.dataView;
                        this.calculateDataPoints(tornadoChartDataView.dataPoints), this.calculateDataPoints(tornadoChartDataView.highlightedDataPoints);
                        var dataPointsWithHighlights = tornadoChartDataView.dataPoints.concat(tornadoChartDataView.highlightedDataPoints);
                        this.renderColumns(dataPointsWithHighlights, 2 === tornadoChartDataView.series.length), 
                        this.renderLabels(this.dataView.hasHighlights ? tornadoChartDataView.highlightedDataPoints : tornadoChartDataView.dataPoints, tornadoChartDataView.settings.labelSettings);
                    }, TornadoChart.prototype.calculateDataPoints = function(dataPoints) {
                        for (var categoriesLength = this.dataView.categories.length, settings = this.dataView.settings, heightColumn = Math.max(this.heightColumn, 0), py = heightColumn / 2, pyHighlighted = heightColumn * TornadoChart.HighlightedShapeFactor / 2, maxSeries = this.dataView.series.length === TornadoChart.MaxSeries, i = 0; i < dataPoints.length; i++) {
                            var dataPoint = dataPoints[i], shiftToMiddle = i < categoriesLength && maxSeries, shiftToRight = i > categoriesLength - 1, widthOfColumn = this.getColumnWidth(dataPoint.value, dataPoint.minValue, dataPoint.maxValue, this.columnWidth), dx = (this.columnWidth - widthOfColumn) * Number(shiftToMiddle) + this.columnWidth * Number(shiftToRight);
                            dx = Math.max(dx, 0);
                            var highlighted = this.dataView.hasHighlights && dataPoint.highlight, highlightOffset = highlighted ? heightColumn * (1 - TornadoChart.HighlightedShapeFactor) / 2 : 0, dy = (heightColumn + this.columnPadding) * (i % categoriesLength) + highlightOffset, label = this.getLabelData(dataPoint.value, dx, widthOfColumn, shiftToMiddle, dataPoint.formatString, settings);
                            dataPoint.dx = dx, dataPoint.dy = dy, dataPoint.px = widthOfColumn / 2, dataPoint.py = highlighted ? pyHighlighted : py, 
                            dataPoint.angle = shiftToMiddle ? 180 : 0, dataPoint.width = widthOfColumn, dataPoint.height = highlighted ? heightColumn * TornadoChart.HighlightedShapeFactor : heightColumn, 
                            dataPoint.label = label;
                        }
                    }, TornadoChart.prototype.renderColumns = function(columnsData, selectSecondSeries) {
                        var _this = this;
                        void 0 === selectSecondSeries && (selectSecondSeries = !1);
                        var hasSelection = this.interactivityService && this.interactivityService.hasSelection(), columnsSelection = this.columns.selectAll(TornadoChart.Column.selector).data(columnsData);
                        columnsSelection.enter().append("svg:rect").classed(TornadoChart.Column.class, !0), 
                        columnsSelection.style("fill", function(p) {
                            return p.color;
                        }).style("fill-opacity", function(p) {
                            return tornadoChartUtils.getFillOpacity(p.selected, p.highlight, hasSelection, _this.dataView.hasHighlights);
                        }).attr("transform", function(p) {
                            return SVGUtil.translateAndRotate(p.dx, p.dy, p.px, p.py, p.angle);
                        }).attr("height", function(p) {
                            return p.height;
                        }).attr("width", function(p) {
                            return p.width;
                        }), columnsSelection.exit().remove();
                        var interactivityService = this.interactivityService;
                        if (interactivityService) {
                            interactivityService.applySelectionStateToData(columnsData);
                            var behaviorOptions = {
                                columns: columnsSelection,
                                clearCatcher: this.clearCatcher,
                                interactivityService: this.interactivityService
                            };
                            interactivityService.bind(columnsData, this.behavior, behaviorOptions);
                        }
                        this.renderTooltip(columnsSelection);
                    }, TornadoChart.prototype.renderTooltip = function(selection) {
                        TooltipManager.addTooltip(selection, function(tooltipEvent) {
                            return tooltipEvent.data.tooltipData;
                        });
                    }, TornadoChart.prototype.getColumnWidth = function(value, minValue, maxValue, width) {
                        if (minValue === maxValue) return width;
                        var columnWidth = width * (value - minValue) / (maxValue - minValue);
                        return Math.max(0, Math.min(width, columnWidth));
                    }, TornadoChart.prototype.getLabelData = function(value, dxColumn, columnWidth, isColumnPositionLeft, formatStringProp, settings) {
                        var dx, tornadoChartSettings = settings ? settings : this.dataView.settings, labelSettings = tornadoChartSettings.labelSettings, fontSize = labelSettings.fontSize, color = labelSettings.labelColor, maxOutsideLabelWidth = isColumnPositionLeft ? dxColumn - this.leftLabelMargin : this.allColumnsWidth - (dxColumn + columnWidth + this.leftLabelMargin), maxLabelWidth = Math.max(maxOutsideLabelWidth, columnWidth - this.leftLabelMargin), textProperties = {
                            fontFamily: dataLabelUtils.StandardFontFamily,
                            fontSize: PixelConverter.fromPoint(fontSize),
                            text: tornadoChartSettings.getLabelValueFormatter(formatStringProp).format(value)
                        }, valueAfterValueFormatter = TextMeasurementService.getTailoredTextOrDefault(textProperties, maxLabelWidth), textDataAfterValueFormatter = TornadoChart.getTextData(valueAfterValueFormatter, this.textOptions, !0, !1, fontSize);
                        return columnWidth > textDataAfterValueFormatter.width + TornadoChart.LabelPadding ? dx = dxColumn + columnWidth / 2 - textDataAfterValueFormatter.width / 2 : (dx = isColumnPositionLeft ? dxColumn - this.leftLabelMargin - textDataAfterValueFormatter.width : dxColumn + columnWidth + this.leftLabelMargin, 
                        color = tornadoChartSettings.labelOutsideFillColor), {
                            dx: dx,
                            source: value,
                            value: valueAfterValueFormatter,
                            color: color
                        };
                    }, TornadoChart.prototype.renderAxes = function() {
                        var linesData, axesSelection, axesElements = this.main.select(TornadoChart.Axes.selector).selectAll(TornadoChart.Axis.selector);
                        return this.dataView.series.length !== TornadoChart.MaxSeries ? void axesElements.remove() : (linesData = this.generateAxesData(), 
                        axesSelection = axesElements.data(linesData), axesSelection.enter().append("svg:line").classed(TornadoChart.Axis.class, !0), 
                        axesSelection.attr("x1", function(data) {
                            return data.x1;
                        }).attr("y1", function(data) {
                            return data.y1;
                        }).attr("x2", function(data) {
                            return data.x2;
                        }).attr("y2", function(data) {
                            return data.y2;
                        }), void axesSelection.exit().remove());
                    }, TornadoChart.prototype.generateAxesData = function() {
                        var x, y1, y2;
                        return x = this.allColumnsWidth / 2, y1 = 0, y2 = this.scrolling.scrollViewport.height, 
                        [ {
                            x1: x,
                            y1: y1,
                            x2: x,
                            y2: y2
                        } ];
                    }, TornadoChart.prototype.renderLabels = function(dataPoints, labelsSettings) {
                        var labelEnterSelection, _this = this, labelSelection = this.main.select(TornadoChart.Labels.selector).selectAll(TornadoChart.Label.selector).data(_.filter(dataPoints, function(p) {
                            return p.label.dx >= 0;
                        }));
                        if (!labelsSettings.show || this.dataView.labelHeight >= this.heightColumn) return void this.labels.selectAll("*").remove();
                        var fontSizeInPx = PixelConverter.fromPoint(labelsSettings.fontSize), labelYOffset = this.heightColumn / 2 + this.dataView.labelHeight / 2 - this.InnerTextHeightDelta, categoriesLength = this.dataView.categories.length;
                        labelEnterSelection = labelSelection.enter().append("g"), labelEnterSelection.append("svg:title").classed(TornadoChart.LabelTitle.class, !0), 
                        labelEnterSelection.append("svg:text").attr("dy", dataLabelUtils.DefaultDy).classed(TornadoChart.LabelText.class, !0), 
                        labelSelection.attr("pointer-events", "none").classed(TornadoChart.Label.class, !0), 
                        labelSelection.select(TornadoChart.LabelTitle.selector).text(function(p) {
                            return p.label.source;
                        }), labelSelection.attr("transform", function(p, index) {
                            var dy = (_this.heightColumn + _this.columnPadding) * (index % categoriesLength);
                            return SVGUtil.translate(p.label.dx, dy + labelYOffset);
                        }), labelSelection.select(TornadoChart.LabelText.selector).attr("fill", function(p) {
                            return p.label.color;
                        }).attr("font-size", function(p) {
                            return fontSizeInPx;
                        }).text(function(p) {
                            return p.label.value;
                        }), labelSelection.exit().remove();
                    }, TornadoChart.prototype.renderCategories = function() {
                        var categoriesEnterSelection, categoriesSelection, _this = this, settings = this.dataView.settings, color = settings.categoriesFillColor, categoryElements = this.main.select(TornadoChart.Categories.selector).selectAll(TornadoChart.Category.selector);
                        return settings.showCategories ? (categoriesSelection = categoryElements.data(this.dataView.categories), 
                        categoriesEnterSelection = categoriesSelection.enter().append("g"), categoriesEnterSelection.append("svg:title").classed(TornadoChart.CategoryTitle.class, !0), 
                        categoriesEnterSelection.append("svg:text").classed(TornadoChart.CategoryText.class, !0), 
                        categoriesSelection.attr("transform", function(text, index) {
                            var shift = (_this.heightColumn + _this.columnPadding) * index + _this.heightColumn / 2, textData = TornadoChart.getTextData(text, _this.textOptions, !1, !0);
                            return shift = shift + textData.height / 2 - _this.InnerTextHeightDelta, SVGUtil.translate(0, shift);
                        }).classed(TornadoChart.Category.class, !0), categoriesSelection.select(TornadoChart.CategoryTitle.selector).text(function(text) {
                            return text.text;
                        }), categoriesSelection.select(TornadoChart.CategoryText.selector).attr("fill", color).text(function(data) {
                            return _this.dataView.settings.showCategories ? TextMeasurementService.getTailoredTextOrDefault(TornadoChart.getTextData(data.text, _this.textOptions).textProperties, _this.allLabelsWidth) : "";
                        }), void categoriesSelection.exit().remove()) : void categoryElements.remove();
                    }, TornadoChart.prototype.renderLegend = function() {
                        var legend = this.dataView.legend;
                        if (legend) {
                            var settings = this.dataView.settings, legendData = {
                                title: legend.title,
                                dataPoints: legend.dataPoints,
                                fontSize: settings.legendFontSize,
                                labelColor: settings.legendColor
                            };
                            if (this.dataView.legendObjectProperties) {
                                var position;
                                LegendData.update(legendData, this.dataView.legendObjectProperties), position = this.dataView.legendObjectProperties[legendProps.position], 
                                position && this.legend.changeOrientation(LegendPosition[position]);
                            }
                            var viewport = {
                                height: this.viewport.height + this.margin.top + this.margin.bottom,
                                width: this.viewport.width + this.margin.left + this.margin.right
                            };
                            this.legend.drawLegend(legendData, viewport), Legend.positionChartArea(this.root, this.legend), 
                            legendData.dataPoints.length > 0 && settings.showLegend && this.updateViewport();
                        }
                    }, TornadoChart.prototype.enumerateObjectInstances = function(options) {
                        var settings, enumeration = new ObjectEnumerationBuilder();
                        if (!this.dataView || !this.dataView.settings) return [];
                        switch (settings = this.dataView.settings, options.objectName) {
                          case "dataPoint":
                            this.enumerateDataPoint(enumeration);
                            break;

                          case "categoryAxis":
                            this.enumerateCategoryAxis(enumeration);
                            break;

                          case "labels":
                            this.enumerateLabels(enumeration, settings);
                            break;

                          case "legend":
                            if (!this.dataView.hasDynamicSeries) return;
                            this.enumerateLegend(enumeration, settings);
                            break;

                          case "categories":
                            this.enumerateCategories(enumeration, settings);
                        }
                        return enumeration.complete();
                    }, TornadoChart.prototype.enumerateDataPoint = function(enumeration) {
                        if (this.dataView && this.dataView.series) for (var series = this.dataView.series, i = 0, length = series.length; i < length; i++) enumeration.pushInstance({
                            objectName: "dataPoint",
                            displayName: series[i].name,
                            selector: ColorHelper.normalizeSelector(series[i].selectionId.getSelector(), !1),
                            properties: {
                                fill: {
                                    solid: {
                                        color: series[i].fill
                                    }
                                }
                            }
                        });
                    }, TornadoChart.prototype.enumerateCategoryAxis = function(enumeration) {
                        if (this.dataView && this.dataView.series) for (var series = this.dataView.series, i = 0, length = series.length; i < length; i++) enumeration.pushInstance({
                            objectName: "categoryAxis",
                            displayName: series[i].name,
                            selector: series[i].selectionId ? series[i].selectionId.getSelector() : null,
                            properties: {
                                end: series[i].categoryAxisEnd
                            }
                        });
                    }, TornadoChart.prototype.enumerateLabels = function(enumeration, settings) {
                        var labelSettings = settings.labelSettings, labels = {
                            objectName: "labels",
                            displayName: "Labels",
                            selector: null,
                            properties: {
                                show: labelSettings.show,
                                fontSize: labelSettings.fontSize,
                                labelPrecision: labelSettings.precision,
                                labelDisplayUnits: labelSettings.displayUnits,
                                insideFill: labelSettings.labelColor,
                                outsideFill: settings.labelOutsideFillColor
                            }
                        };
                        enumeration.pushInstance(labels);
                    }, TornadoChart.prototype.enumerateCategories = function(enumeration, settings) {
                        var categories = {
                            objectName: "categories",
                            displayName: "Categories",
                            selector: null,
                            properties: {
                                show: settings.showCategories,
                                fill: settings.categoriesFillColor
                            }
                        };
                        enumeration.pushInstance(categories);
                    }, TornadoChart.prototype.enumerateLegend = function(enumeration, settings) {
                        var legend, position, showTitle = !0, titleText = "";
                        showTitle = DataViewObject.getValue(this.dataView.legendObjectProperties, legendProps.showTitle, showTitle), 
                        titleText = DataViewObject.getValue(this.dataView.legendObjectProperties, legendProps.titleText, titleText), 
                        position = DataViewObject.getValue(this.dataView.legendObjectProperties, legendProps.position, legendPosition.top), 
                        legend = {
                            objectName: "legend",
                            displayName: "Legend",
                            selector: null,
                            properties: {
                                show: settings.showLegend,
                                position: position,
                                showTitle: showTitle,
                                titleText: titleText,
                                fontSize: settings.legendFontSize,
                                labelColor: settings.legendColor
                            }
                        }, enumeration.pushInstance(legend);
                    }, TornadoChart.prototype.destroy = function() {
                        this.root = null;
                    }, TornadoChart.ClassName = "tornado-chart", TornadoChart.capabilities = {
                        dataRoles: [ {
                            name: "Category",
                            kind: VisualDataRoleKind.Grouping,
                            displayName: "Group"
                        }, {
                            name: "Series",
                            kind: VisualDataRoleKind.Grouping,
                            displayName: "Legend"
                        }, {
                            name: "Values",
                            kind: VisualDataRoleKind.Measure,
                            displayName: "Values"
                        } ],
                        dataViewMappings: [ {
                            conditions: [ {
                                Category: {
                                    max: 1
                                },
                                Values: {
                                    min: 0,
                                    max: 1
                                },
                                Series: {
                                    min: 0,
                                    max: 1
                                }
                            }, {
                                Category: {
                                    max: 1
                                },
                                Values: {
                                    min: 2,
                                    max: 2
                                },
                                Series: {
                                    max: 0
                                }
                            } ],
                            categorical: {
                                categories: {
                                    for: {
                                        in: "Category"
                                    }
                                },
                                values: {
                                    group: {
                                        by: "Series",
                                        select: [ {
                                            for: {
                                                in: "Values"
                                            }
                                        } ],
                                        dataReductionAlgorithm: {
                                            top: {}
                                        }
                                    }
                                }
                            }
                        } ],
                        objects: {
                            general: {
                                displayName: "General",
                                properties: {
                                    formatString: {
                                        type: {
                                            formatting: {
                                                formatString: !0
                                            }
                                        }
                                    }
                                }
                            },
                            dataPoint: {
                                displayName: "Data Colors",
                                properties: {
                                    fill: {
                                        displayName: createDisplayNameGetter("Visual_Fill"),
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    }
                                }
                            },
                            categoryAxis: {
                                displayName: "X-Axis",
                                properties: {
                                    end: {
                                        displayName: "End",
                                        type: {
                                            numeric: !0
                                        },
                                        suppressFormatPainterCopy: !0
                                    }
                                }
                            },
                            labels: {
                                displayName: "Data Labels",
                                properties: {
                                    show: {
                                        displayName: "Show",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    labelPrecision: {
                                        displayName: "Decimal Places",
                                        placeHolderText: "Auto",
                                        type: {
                                            numeric: !0
                                        }
                                    },
                                    fontSize: {
                                        displayName: createDisplayNameGetter("Visual_TextSize"),
                                        type: {
                                            formatting: {
                                                fontSize: !0
                                            }
                                        }
                                    },
                                    labelDisplayUnits: {
                                        displayName: "Display Units",
                                        type: {
                                            formatting: {
                                                labelDisplayUnits: !0
                                            }
                                        }
                                    },
                                    insideFill: {
                                        displayName: "Inside fill",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    outsideFill: {
                                        displayName: "Outside fill",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    }
                                }
                            },
                            legend: {
                                displayName: "Legend",
                                properties: {
                                    show: {
                                        displayName: "Show",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    position: {
                                        displayName: "Position",
                                        description: createDisplayNameGetter("Visual_LegendPositionDescription"),
                                        type: {
                                            enumeration: legendPosition.type
                                        }
                                    },
                                    showTitle: {
                                        displayName: "Title",
                                        description: createDisplayNameGetter("Visual_LegendShowTitleDescription"),
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    titleText: {
                                        displayName: "Legend Name",
                                        description: createDisplayNameGetter("Visual_LegendNameDescription"),
                                        type: {
                                            text: !0
                                        }
                                    },
                                    labelColor: {
                                        displayName: "Color",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    fontSize: {
                                        displayName: "TextSize",
                                        type: {
                                            formatting: {
                                                fontSize: !0
                                            }
                                        }
                                    }
                                }
                            },
                            categories: {
                                displayName: "Group",
                                properties: {
                                    show: {
                                        displayName: "Show",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    fill: {
                                        displayName: "Color",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        },
                        supportsHighlight: !0
                    }, TornadoChart.Properties = TornadoChart.getProperties(TornadoChart.capabilities), 
                    TornadoChart.Columns = {
                        class: "columns",
                        selector: ".columns"
                    }, TornadoChart.Column = {
                        class: "column",
                        selector: ".column"
                    }, TornadoChart.Axes = {
                        class: "axes",
                        selector: ".axes"
                    }, TornadoChart.Axis = {
                        class: "axis",
                        selector: ".axis"
                    }, TornadoChart.Labels = {
                        class: "labels",
                        selector: ".labels"
                    }, TornadoChart.Label = {
                        class: "label",
                        selector: ".label"
                    }, TornadoChart.LabelTitle = {
                        class: "label-title",
                        selector: ".label-title"
                    }, TornadoChart.LabelText = {
                        class: "label-text",
                        selector: ".label-text"
                    }, TornadoChart.Categories = {
                        class: "categories",
                        selector: ".categories"
                    }, TornadoChart.Category = {
                        class: "category",
                        selector: ".category"
                    }, TornadoChart.CategoryTitle = {
                        class: "category-title",
                        selector: ".category-title"
                    }, TornadoChart.CategoryText = {
                        class: "category-text",
                        selector: ".category-text"
                    }, TornadoChart.MaxSeries = 2, TornadoChart.MaxPrecision = 17, TornadoChart.LabelPadding = 2.5, 
                    TornadoChart.CategoryMinHeight = 25, TornadoChart.DefaultFontSize = 9, TornadoChart.DefaultLegendFontSize = 8, 
                    TornadoChart.HighlightedShapeFactor = .5, TornadoChart.CategoryLabelMargin = 10, 
                    TornadoChart.ScrollBarWidth = 22, TornadoChart.DefaultTornadoChartSettings = {
                        labelOutsideFillColor: dataLabelUtils.defaultLabelColor,
                        labelSettings: {
                            show: !0,
                            precision: null,
                            fontSize: TornadoChart.DefaultFontSize,
                            displayUnits: 0,
                            labelColor: dataLabelUtils.defaultInsideLabelColor
                        },
                        showCategories: !0,
                        showLegend: !0,
                        legendFontSize: TornadoChart.DefaultLegendFontSize,
                        legendColor: LegendData.DefaultLegendLabelFillColor,
                        categoriesFillColor: "#777"
                    }, TornadoChart;
                }();
                samples.TornadoChart = TornadoChart;
                var tornadoChartUtils;
                !function(tornadoChartUtils) {
                    function getFillOpacity(selected, highlight, hasSelection, hasPartialHighlights) {
                        return hasPartialHighlights && !highlight || hasSelection && !selected ? tornadoChartUtils.DimmedOpacity : tornadoChartUtils.DefaultOpacity;
                    }
                    tornadoChartUtils.DimmedOpacity = .4, tornadoChartUtils.DefaultOpacity = 1, tornadoChartUtils.getFillOpacity = getFillOpacity;
                }(tornadoChartUtils = samples.tornadoChartUtils || (samples.tornadoChartUtils = {}));
            }(samples = visuals.samples || (visuals.samples = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, jsCommon = window.jsCommon, powerbi = window.powerbi;
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var samples;
            !function(samples) {
                function getTickLabelMargins(viewport, yMarginLimit, textWidthMeasurer, textHeightMeasurer, axes, bottomMarginLimit, xAxisTextProperties, y1AxisTextProperties, y2AxisTextProperties, enableOverflowCheck, scrollbarVisible, showOnRight, renderXAxis, renderY1Axis, renderY2Axis) {
                    var XLabelMaxAllowedOverflow = 35, xAxisProperties = axes.x, y1AxisProperties = axes.y1, y2AxisProperties = axes.y2, xLabels = xAxisProperties.values, y1Labels = y1AxisProperties.values, leftOverflow = 0, rightOverflow = 0, maxWidthY1 = 0, maxWidthY2 = 0, xMax = 0, ordinalLabelOffset = xAxisProperties.categoryThickness ? xAxisProperties.categoryThickness / 2 : 0, scaleIsOrdinal = AxisHelper.isOrdinalScale(xAxisProperties.scale), xLabelOuterPadding = 0;
                    if (void 0 !== xAxisProperties.outerPadding ? xLabelOuterPadding = xAxisProperties.outerPadding : void 0 !== xAxisProperties.xLabelMaxWidth && (xLabelOuterPadding = Math.max(0, (viewport.width - xAxisProperties.xLabelMaxWidth * xLabels.length) / 2)), 
                    0 !== AxisHelper.getRecommendedNumberOfTicksForXAxis(viewport.width) || 0 !== AxisHelper.getRecommendedNumberOfTicksForYAxis(viewport.height)) {
                        var rotation;
                        if (rotation = scrollbarVisible ? AxisHelper.LabelLayoutStrategy.DefaultRotationWithScrollbar : AxisHelper.LabelLayoutStrategy.DefaultRotation, 
                        renderY1Axis) for (var i = 0, len = y1Labels.length; i < len; i++) y1AxisTextProperties.text = y1Labels[i], 
                        maxWidthY1 = Math.max(maxWidthY1, textWidthMeasurer(y1AxisTextProperties));
                        if (y2AxisProperties && renderY2Axis) for (var y2Labels = y2AxisProperties.values, i = 0, len = y2Labels.length; i < len; i++) y2AxisTextProperties.text = y2Labels[i], 
                        maxWidthY2 = Math.max(maxWidthY2, textWidthMeasurer(y2AxisTextProperties));
                        var textHeight = textHeightMeasurer(xAxisTextProperties), maxNumLines = Math.floor(bottomMarginLimit / textHeight), xScale = xAxisProperties.scale, xDomain = xScale.domain();
                        if (renderXAxis && xLabels.length > 0) {
                            for (var i = 0, len = xLabels.length; i < len; i++) {
                                var height;
                                xAxisTextProperties.text = xLabels[i];
                                var width = textWidthMeasurer(xAxisTextProperties);
                                if (xAxisProperties.willLabelsWordBreak) {
                                    var wordBreaks = WordBreaker.splitByWidth(xAxisTextProperties.text, xAxisTextProperties, textWidthMeasurer, xAxisProperties.xLabelMaxWidth, maxNumLines);
                                    height = wordBreaks.length * textHeight, width = xAxisProperties.xLabelMaxWidth;
                                } else !xAxisProperties.willLabelsFit && scaleIsOrdinal ? (height = width * rotation.sine, 
                                width *= rotation.cosine) : height = textHeight;
                                if (0 === i) {
                                    if (scaleIsOrdinal) leftOverflow = xAxisProperties.willLabelsFit ? width / 2 - ordinalLabelOffset - xLabelOuterPadding : width - ordinalLabelOffset - xLabelOuterPadding, 
                                    leftOverflow = Math.max(leftOverflow, 0); else if (xDomain.length > 1) {
                                        var xPos = xScale(xDomain[0]);
                                        leftOverflow = width / 2 - xPos, leftOverflow = Math.max(leftOverflow, 0);
                                    }
                                } else if (i === len - 1) if (scaleIsOrdinal) (xAxisProperties.willLabelsFit || xAxisProperties.willLabelsWordBreak) && (rightOverflow = width / 2 - ordinalLabelOffset - xLabelOuterPadding, 
                                rightOverflow = Math.max(rightOverflow, 0)); else if (xDomain.length > 1) {
                                    var xPos = xScale(xDomain[1]);
                                    rightOverflow = width / 2 - (viewport.width - xPos), rightOverflow = Math.max(rightOverflow, 0);
                                }
                                xMax = Math.max(xMax, 1.4 * height - 15);
                            }
                            leftOverflow = enableOverflowCheck ? Math.min(leftOverflow, XLabelMaxAllowedOverflow) : 0, 
                            rightOverflow = enableOverflowCheck ? Math.min(rightOverflow, XLabelMaxAllowedOverflow) : 0;
                        }
                    }
                    var rightMargin = 0, leftMargin = 0, bottomMargin = Math.min(Math.ceil(xMax), bottomMarginLimit);
                    return showOnRight ? (leftMargin = Math.min(Math.max(leftOverflow, maxWidthY2), yMarginLimit), 
                    rightMargin = Math.min(Math.max(rightOverflow, maxWidthY1), yMarginLimit)) : (leftMargin = Math.min(Math.max(leftOverflow, maxWidthY1), yMarginLimit), 
                    rightMargin = Math.min(Math.max(rightOverflow, maxWidthY2), yMarginLimit)), {
                        xMax: Math.ceil(bottomMargin),
                        yLeft: Math.ceil(leftMargin),
                        yRight: Math.ceil(rightMargin)
                    };
                }
                function getLayerData(dataViews, currentIdx, totalLayers) {
                    return totalLayers > 1 ? dataViews && dataViews.length > currentIdx ? [ dataViews[currentIdx] ] : [] : dataViews;
                }
                function shouldShowYAxisLabel(layerNumber, valueAxisProperties, yAxisWillMerge) {
                    return 0 === layerNumber && !!valueAxisProperties && !!valueAxisProperties.showAxisTitle || 1 === layerNumber && !yAxisWillMerge && !!valueAxisProperties && !!valueAxisProperties.secShowAxisTitle;
                }
                function calculateAxes(layers, viewport, margin, categoryAxisProperties, valueAxisProperties, scrollbarVisible, existingAxisProperties) {
                    var visualOptions = {
                        viewport: viewport,
                        margin: margin,
                        forcedXDomain: [ categoryAxisProperties ? categoryAxisProperties.start : null, categoryAxisProperties ? categoryAxisProperties.end : null ],
                        forceMerge: valueAxisProperties && valueAxisProperties.secShow === !1,
                        showCategoryAxisLabel: !1,
                        showValueAxisLabel: !1,
                        categoryAxisScaleType: categoryAxisProperties && null != categoryAxisProperties.axisScale ? categoryAxisProperties.axisScale : axisScale.linear,
                        valueAxisScaleType: valueAxisProperties && null != valueAxisProperties.axisScale ? valueAxisProperties.axisScale : axisScale.linear,
                        trimOrdinalDataOnOverflow: !1
                    }, yAxisWillMerge = !1;
                    valueAxisProperties && (visualOptions.forcedYDomain = AxisHelper.applyCustomizedDomain([ valueAxisProperties.start, valueAxisProperties.end ], visualOptions.forcedYDomain));
                    for (var result, layerNumber = 0, len = layers.length; layerNumber < len; layerNumber++) {
                        var currentlayer = layers[layerNumber];
                        visualOptions.showCategoryAxisLabel = !!categoryAxisProperties && !!categoryAxisProperties.showAxisTitle, 
                        visualOptions.showValueAxisLabel = shouldShowYAxisLabel(layerNumber, valueAxisProperties, yAxisWillMerge);
                        var axes = currentlayer.calculateAxesProperties(visualOptions);
                        0 === layerNumber && (result = {
                            x: axes[0],
                            y1: axes[1]
                        }), result.x.willLabelsFit = !1, result.x.willLabelsWordBreak = !1;
                    }
                    return result;
                }
                function createLayers(type, objects, interactivityService, animator, isScrollable) {
                    void 0 === isScrollable && (isScrollable = !0);
                    var layers = [], cartesianOptions = {
                        isScrollable: isScrollable,
                        animator: animator,
                        interactivityService: interactivityService
                    };
                    return layers.push(createMekkoChartLayer(MekkoVisualChartType.hundredPercentStackedColumn, cartesianOptions)), 
                    layers;
                }
                function createMekkoChartLayer(type, defaultOptions) {
                    var options = {
                        animator: defaultOptions.animator,
                        interactivityService: defaultOptions.interactivityService,
                        isScrollable: defaultOptions.isScrollable,
                        chartType: type
                    };
                    return new MekkoColumnChart(options);
                }
                var EnumExtensions = jsCommon.EnumExtensions, PixelConverter = jsCommon.PixelConverter, ArrayExtensions = jsCommon.ArrayExtensions, WordBreaker = jsCommon.WordBreaker, createClassAndSelector = jsCommon.CssConstants.createClassAndSelector, NewDataLabelUtils = powerbi.visuals.NewDataLabelUtils, AxisHelper = powerbi.visuals.AxisHelper, valueFormatter = powerbi.visuals.valueFormatter, Double = powerbi.Double, TextMeasurementService = powerbi.TextMeasurementService, VisualDataRoleKind = powerbi.VisualDataRoleKind, LegendData = powerbi.visuals.LegendData, DataViewObject = powerbi.DataViewObject, InteractivityUtils = powerbi.visuals.InteractivityUtils, yAxisPosition = powerbi.visuals.yAxisPosition, appendClearCatcher = powerbi.visuals.appendClearCatcher, createInteractivityService = powerbi.visuals.createInteractivityService, createLegend = powerbi.visuals.createLegend, SVGUtil = powerbi.visuals.SVGUtil, DataViewObjects = powerbi.DataViewObjects, axisType = powerbi.visuals.axisType, getInvalidValueWarnings = powerbi.visuals.getInvalidValueWarnings, dataLabelUtils = powerbi.visuals.dataLabelUtils, ObjectEnumerationBuilder = powerbi.visuals.ObjectEnumerationBuilder, legendProps = powerbi.visuals.legendProps, LegendPosition = powerbi.visuals.LegendPosition, axisScale = powerbi.visuals.axisScale, axisStyle = powerbi.visuals.axisStyle, Prototype = powerbi.Prototype, GetAnimationDuration = powerbi.visuals.AnimatorCommon.GetAnimationDuration, LabelLayout = powerbi.LabelLayout, converterHelper = powerbi.visuals.converterHelper, SelectionIdBuilder = powerbi.visuals.SelectionIdBuilder, TooltipBuilder = powerbi.visuals.TooltipBuilder, SelectionId = powerbi.visuals.SelectionId, GradientUtils = powerbi.visuals.GradientUtils, ColorHelper = powerbi.visuals.ColorHelper, LegendIcon = powerbi.visuals.LegendIcon, TooltipManager = powerbi.visuals.TooltipManager, flagBar = 2, flagColumn = 4, flagClustered = 8, flagStacked = 16, flagStacked100 = 32 | flagStacked;
                !function(MekkoVisualChartType) {
                    MekkoVisualChartType[MekkoVisualChartType.clusteredBar = flagBar | flagClustered] = "clusteredBar", 
                    MekkoVisualChartType[MekkoVisualChartType.clusteredColumn = flagColumn | flagClustered] = "clusteredColumn", 
                    MekkoVisualChartType[MekkoVisualChartType.hundredPercentStackedBar = flagBar | flagStacked100] = "hundredPercentStackedBar", 
                    MekkoVisualChartType[MekkoVisualChartType.hundredPercentStackedColumn = flagColumn | flagStacked100] = "hundredPercentStackedColumn", 
                    MekkoVisualChartType[MekkoVisualChartType.stackedBar = flagBar | flagStacked] = "stackedBar", 
                    MekkoVisualChartType[MekkoVisualChartType.stackedColumn = flagColumn | flagStacked] = "stackedColumn";
                }(samples.MekkoVisualChartType || (samples.MekkoVisualChartType = {}));
                var MekkoVisualChartType = samples.MekkoVisualChartType;
                !function(MekkoChartType) {
                    MekkoChartType[MekkoChartType.HundredPercentStackedColumn = 0] = "HundredPercentStackedColumn";
                }(samples.MekkoChartType || (samples.MekkoChartType = {}));
                var MekkoDataWrapper = (samples.MekkoChartType, function() {
                    function MekkoDataWrapper(columnChartData, isScalar) {
                        this.data = columnChartData, this.isScalar = isScalar;
                    }
                    return MekkoDataWrapper.prototype.lookupXValue = function(index, type) {
                        var isDateTime = AxisHelper.isDateTime(type);
                        if (isDateTime && this.isScalar) return new Date(index);
                        var data = this.data;
                        if (type.text) return data.categories[index];
                        var firstSeries = data.series[0];
                        if (firstSeries) {
                            var seriesValues = firstSeries.data;
                            if (seriesValues) {
                                this.data.hasHighlights && (index = 2 * index);
                                var dataPoint = seriesValues[index];
                                if (dataPoint) return isDateTime ? new Date(dataPoint.categoryValue) : dataPoint.categoryValue;
                            }
                        }
                        return index;
                    }, MekkoDataWrapper;
                }());
                samples.MekkoDataWrapper = MekkoDataWrapper;
                var MekkoChartStrategy = function() {
                    function MekkoChartStrategy() {}
                    return MekkoChartStrategy.prototype.setupVisualProps = function(columnChartProps) {
                        this.graphicsContext = columnChartProps, this.margin = columnChartProps.margin, 
                        this.width = this.graphicsContext.width, this.height = this.graphicsContext.height, 
                        this.categoryLayout = columnChartProps.layout, this.animator = columnChartProps.animator, 
                        this.interactivityService = columnChartProps.interactivityService, this.viewportHeight = columnChartProps.viewportHeight, 
                        this.viewportWidth = columnChartProps.viewportWidth;
                    }, MekkoChartStrategy.prototype.setData = function(data) {
                        this.data = data;
                    }, MekkoChartStrategy.createFormatter = function(scaleDomain, dataDomain, dataType, isScalar, formatString, bestTickCount, tickValues, getValueFn, useTickIntervalForDisplayUnits) {
                        void 0 === useTickIntervalForDisplayUnits && (useTickIntervalForDisplayUnits = !1);
                        var formatter;
                        if (dataType.dateTime) if (isScalar) {
                            var value = new Date(scaleDomain[0]), value2 = new Date(scaleDomain[1]);
                            1 === bestTickCount && (value = value2 = new Date(dataDomain[0])), formatter = valueFormatter.create({
                                format: formatString,
                                value: value,
                                value2: value2,
                                tickCount: bestTickCount
                            });
                        } else {
                            var minDate = getValueFn(0, dataType), maxDate = getValueFn(scaleDomain.length - 1, dataType);
                            formatter = valueFormatter.create({
                                format: formatString,
                                value: minDate,
                                value2: maxDate,
                                tickCount: bestTickCount
                            });
                        } else if (useTickIntervalForDisplayUnits && isScalar && tickValues.length > 1) {
                            var domainMin = tickValues[1] - tickValues[0], domainMax = 0;
                            formatter = valueFormatter.create({
                                format: formatString,
                                value: domainMin,
                                value2: domainMax,
                                allowFormatBeautification: !0
                            });
                        } else formatter = valueFormatter.createDefaultFormatter(formatString, !0);
                        return formatter;
                    }, MekkoChartStrategy.formatAxisTickValues = function(axis, tickValues, formatter, dataType, isScalar, getValueFn) {
                        var formattedTickValues = [];
                        return formatter ? !getValueFn || dataType.numeric && isScalar ? (axis.tickFormat(function(d) {
                            return formatter.format(d);
                        }), formattedTickValues = tickValues.map(function(d) {
                            return formatter.format(d);
                        })) : (axis.tickFormat(function(d) {
                            return formatter.format(getValueFn(d, dataType));
                        }), formattedTickValues = tickValues.map(function(d) {
                            return formatter.format(getValueFn(d, dataType));
                        })) : formattedTickValues = tickValues.map(function(d) {
                            return getValueFn(d, dataType);
                        }), formattedTickValues;
                    }, MekkoChartStrategy.prototype.createAxis = function(options) {
                        var pixelSpan = options.pixelSpan, dataDomain = options.dataDomain, metaDataColumn = options.metaDataColumn, formatStringProp = options.formatStringProp, outerPadding = options.outerPadding || 0, isCategoryAxis = !!options.isCategoryAxis, isScalar = !!options.isScalar, isVertical = !!options.isVertical, useTickIntervalForDisplayUnits = !!options.useTickIntervalForDisplayUnits, getValueFn = options.getValueFn, categoryThickness = options.categoryThickness, formatString = valueFormatter.getFormatString(metaDataColumn, formatStringProp), dataType = AxisHelper.getCategoryValueType(metaDataColumn, isScalar), isLogScaleAllowed = AxisHelper.isLogScalePossible(dataDomain, dataType), scale = d3.scale.linear(), scaleDomain = [ 0, 1 ], bestTickCount = dataDomain.length || 1, borderWidth = MekkoColumnChart.getBorderWidth(options.borderSettings), chartWidth = pixelSpan - borderWidth * (bestTickCount - 1);
                        chartWidth < MekkoChart.MinOrdinalRectThickness && (chartWidth = MekkoChart.MinOrdinalRectThickness), 
                        scale.domain(scaleDomain).range([ 0, chartWidth ]);
                        var tickValues = dataDomain, formatter = MekkoChartStrategy.createFormatter(scaleDomain, dataDomain, dataType, isScalar, formatString, bestTickCount, tickValues, getValueFn, useTickIntervalForDisplayUnits), axis = d3.svg.axis().scale(scale).tickSize(6, 0).orient(isVertical ? "left" : "bottom").ticks(bestTickCount).tickValues(dataDomain), formattedTickValues = [];
                        metaDataColumn && (formattedTickValues = MekkoChartStrategy.formatAxisTickValues(axis, tickValues, formatter, dataType, isScalar, getValueFn));
                        var xLabelMaxWidth;
                        if (!isScalar && categoryThickness) xLabelMaxWidth = Math.max(1, categoryThickness - 2 * MekkoChart.TickLabelPadding); else {
                            var labelAreaCount = tickValues.length > 1 ? tickValues.length + 1 : tickValues.length;
                            xLabelMaxWidth = labelAreaCount > 1 ? pixelSpan / labelAreaCount : pixelSpan, xLabelMaxWidth = Math.max(1, xLabelMaxWidth - 2 * MekkoChart.TickLabelPadding);
                        }
                        return {
                            scale: scale,
                            axis: axis,
                            formatter: formatter,
                            values: formattedTickValues,
                            axisType: dataType,
                            axisLabel: null,
                            isCategoryAxis: isCategoryAxis,
                            xLabelMaxWidth: xLabelMaxWidth,
                            categoryThickness: categoryThickness,
                            outerPadding: outerPadding,
                            usingDefaultDomain: !1,
                            isLogScaleAllowed: isLogScaleAllowed
                        };
                    }, MekkoChartStrategy.prototype.getCategoryAxis = function(data, size, layout, isVertical, forcedXMin, forcedXMax, axisScaleType) {
                        var categoryThickness = layout.categoryThickness, isScalar = layout.isScalar, outerPaddingRatio = layout.outerPaddingRatio, dw = new MekkoDataWrapper(data, isScalar), domain = [];
                        if (data.series && data.series.length > 0 && data.series[0].data && data.series[0].data.length > 0) {
                            var domainDoubles = data.series[0].data.map(function(item) {
                                return item.originalPosition + item.value / 2;
                            });
                            domain = domainDoubles.filter(function(item, pos) {
                                return domainDoubles.indexOf(item) === pos;
                            });
                        }
                        var axisProperties = this.createAxis({
                            pixelSpan: size,
                            dataDomain: domain,
                            metaDataColumn: data.categoryMetadata,
                            formatStringProp: MekkoChart.Properties.general.formatString,
                            outerPadding: categoryThickness * outerPaddingRatio,
                            isCategoryAxis: !0,
                            isScalar: isScalar,
                            isVertical: isVertical,
                            categoryThickness: categoryThickness,
                            useTickIntervalForDisplayUnits: !0,
                            getValueFn: function(index, type) {
                                var domainIndex = domain.indexOf(index), value = dw.lookupXValue(domainIndex, type);
                                return value;
                            },
                            scaleType: axisScaleType,
                            borderSettings: data.borderSettings
                        });
                        return layout.categoryThickness = axisProperties.categoryThickness, axisProperties;
                    }, MekkoChartStrategy.prototype.setXScale = function(is100Pct, forcedTickCount, forcedXDomain, axisScaleType) {
                        var forcedXMin, forcedXMax, width = this.width;
                        forcedXDomain && 2 === forcedXDomain.length && (forcedXMin = forcedXDomain[0], forcedXMax = forcedXDomain[1]);
                        var props = this.xProps = this.getCategoryAxis(this.data, width, this.categoryLayout, !1, forcedXMin, forcedXMax, axisScaleType);
                        return props;
                    }, MekkoChartStrategy.prototype.setYScale = function(is100Pct, forcedTickCount, forcedYDomain, axisScaleType) {
                        var height = this.viewportHeight, valueDomain = MekkoChartUtils.calcValueDomain(this.data.series, is100Pct), valueDomainArr = [ valueDomain.min, valueDomain.max ], combinedDomain = AxisHelper.combineDomain(forcedYDomain, valueDomainArr), shouldClamp = AxisHelper.scaleShouldClamp(combinedDomain, valueDomainArr), metadataColumn = this.data.valuesMetadata[0], formatString = is100Pct ? this.graphicsContext.hostService.getLocalizedString("Percentage") : valueFormatter.getFormatString(metadataColumn, MekkoChart.Properties.general.formatString), mekkoMekkoCreateAxisOptions = {
                            pixelSpan: height,
                            dataDomain: combinedDomain,
                            metaDataColumn: metadataColumn,
                            formatString: formatString,
                            outerPadding: 0,
                            isScalar: !0,
                            isVertical: !0,
                            forcedTickCount: forcedTickCount,
                            useTickIntervalForDisplayUnits: !0,
                            isCategoryAxis: !1,
                            scaleType: axisScaleType,
                            axisDisplayUnits: 0,
                            axisPrecision: 0,
                            is100Pct: is100Pct,
                            shouldClamp: shouldClamp,
                            formatStringProp: void 0
                        };
                        return this.yProps = AxisHelper.createAxis(mekkoMekkoCreateAxisOptions), this.yProps;
                    }, MekkoChartStrategy.prototype.drawColumns = function(useAnimation) {
                        var data = this.data;
                        this.columnsCenters = null;
                        var result, shapes, axisOptions = {
                            columnWidth: 0,
                            xScale: this.xProps.scale,
                            yScale: this.yProps.scale,
                            isScalar: this.categoryLayout.isScalar,
                            margin: this.margin
                        }, stackedColumnLayout = this.layout = MekkoChartStrategy.getLayout(data, axisOptions), labelDataPoints = this.createMekkoLabelDataPoints(), series = MekkoChartUtils.drawSeries(data, this.graphicsContext.mainGraphicsContext, axisOptions);
                        return this.animator && useAnimation && (result = this.animator.animate({
                            viewModel: data,
                            series: series,
                            layout: stackedColumnLayout,
                            itemCS: MekkoChartStrategy.Classes.item,
                            interactivityService: this.interactivityService,
                            mainGraphicsContext: this.graphicsContext.mainGraphicsContext,
                            viewPort: {
                                height: this.height,
                                width: this.width
                            }
                        }), shapes = result.shapes), this.animator && useAnimation && !result.failed || (shapes = MekkoChartStrategy.drawDefaultShapes(data, series, stackedColumnLayout, MekkoChartStrategy.Classes.item, !this.animator, this.interactivityService && this.interactivityService.hasSelection())), 
                        MekkoChartUtils.applyInteractivity(shapes, this.graphicsContext.onDragStart), {
                            shapesSelection: shapes,
                            viewport: {
                                height: this.height,
                                width: this.width
                            },
                            axisOptions: axisOptions,
                            labelDataPoints: labelDataPoints
                        };
                    }, MekkoChartStrategy.drawDefaultShapes = function(data, series, layout, itemCS, filterZeros, hasSelection) {
                        var rectName = "rect";
                        filterZeros = !1;
                        var dataSelector;
                        dataSelector = filterZeros ? function(d) {
                            var filteredData = _.filter(d.data, function(datapoint) {
                                return !!datapoint.value;
                            });
                            return filteredData;
                        } : function(d) {
                            return d.data;
                        };
                        var shapeSelection = series.selectAll(itemCS.selector), shapes = shapeSelection.data(dataSelector, function(d) {
                            return d.key;
                        });
                        shapes.enter().append(rectName).attr("class", function(d) {
                            return itemCS.class.concat(d.highlight ? " highlight" : "");
                        }), shapes.style("fill", function(d) {
                            return data.showAllDataPoints ? d.color : data.defaultDataPointColor;
                        }).style("fill-opacity", function(d) {
                            return MekkoChartUtils.getFillOpacity(d.selected, d.highlight, hasSelection, data.hasHighlights);
                        }).attr(layout.shapeLayout), shapes.exit().remove();
                        var borderSelection = series.selectAll(MekkoColumnChart.BorderClass.selector), borders = borderSelection.data(dataSelector, function(d) {
                            return d.key;
                        }), borderColor = MekkoColumnChart.getBorderColor(data.borderSettings);
                        return borders.enter().append(rectName).classed(MekkoColumnChart.BorderClass.class, !0), 
                        borders.style("fill", function(d) {
                            return borderColor;
                        }).style("fill-opacity", function(d) {
                            return data.hasHighlights ? MekkoChartUtils.DimmedOpacity : MekkoChartUtils.DefaultOpacity;
                        }).attr(layout.shapeBorder), borders.exit().remove(), shapes;
                    }, MekkoChartStrategy.prototype.selectColumn = function(selectedColumnIndex, lastSelectedColumnIndex) {
                        MekkoChartUtils.setChosenColumnOpacity(this.graphicsContext.mainGraphicsContext, MekkoChartStrategy.Classes.item.selector, selectedColumnIndex, lastSelectedColumnIndex), 
                        this.moveHandle(selectedColumnIndex);
                    }, MekkoChartStrategy.prototype.getClosestColumnIndex = function(x, y) {
                        return MekkoChartUtils.getClosestColumnIndex(x, this.getColumnsCenters());
                    }, MekkoChartStrategy.prototype.getColumnsCenters = function() {
                        var _this = this;
                        if (!this.columnsCenters) {
                            var categoryWidth = this.categoryLayout.categoryThickness * (1 - MekkoChart.InnerPaddingRatio);
                            if (this.data.series.length > 0) {
                                var xScaleOffset = 0;
                                this.categoryLayout.isScalar || (xScaleOffset = categoryWidth / 2);
                                var firstSeries = this.data.series[0];
                                firstSeries && firstSeries.data && (this.columnsCenters = firstSeries.data.map(function(d) {
                                    return _this.xProps.scale(_this.categoryLayout.isScalar ? d.categoryValue : d.categoryIndex) + xScaleOffset;
                                }));
                            }
                        }
                        return this.columnsCenters;
                    }, MekkoChartStrategy.prototype.moveHandle = function(selectedColumnIndex) {
                        var columnCenters = this.getColumnsCenters(), x = columnCenters[selectedColumnIndex];
                        if (this.columnSelectionLineHandle) {
                            var handle = this.columnSelectionLineHandle;
                            handle.select("line").attr({
                                x1: x,
                                x2: x
                            }), handle.select("circle").attr({
                                cx: x
                            });
                        } else {
                            var handle = this.columnSelectionLineHandle = this.graphicsContext.mainGraphicsContext.append("g");
                            handle.append("line").classed("interactive-hover-line", !0).attr({
                                x1: x,
                                x2: x,
                                y1: 0,
                                y2: this.height
                            }), handle.append("circle").attr({
                                cx: x,
                                cy: this.height,
                                r: "6px"
                            }).classed("drag-handle", !0);
                        }
                    }, MekkoChartStrategy.getLayout = function(data, axisOptions) {
                        var xScale = axisOptions.xScale, yScale = axisOptions.yScale, scaledY0 = yScale(0), scaledX0 = xScale(0), borderWidth = MekkoColumnChart.getBorderWidth(data.borderSettings), columnWidthScale = function(d) {
                            var value = AxisHelper.diffScaled(xScale, d.value, 0);
                            return value;
                        }, columnStart = function(d) {
                            var value = scaledX0 + AxisHelper.diffScaled(xScale, d.originalPosition, 0) + borderWidth * d.categoryIndex;
                            return value;
                        }, borderStart = function(d) {
                            var value = scaledX0 + AxisHelper.diffScaled(xScale, d.originalPosition, 0) + AxisHelper.diffScaled(xScale, d.value, 0) + borderWidth * d.categoryIndex;
                            return value;
                        };
                        return {
                            shapeLayout: {
                                width: columnWidthScale,
                                x: columnStart,
                                y: function(d) {
                                    return scaledY0 + AxisHelper.diffScaled(yScale, d.position, 0);
                                },
                                height: function(d) {
                                    return MekkoChartUtils.getSize(yScale, d.valueAbsolute);
                                }
                            },
                            shapeBorder: {
                                width: function(d) {
                                    return borderWidth;
                                },
                                x: borderStart,
                                y: function(d) {
                                    return scaledY0 + AxisHelper.diffScaled(yScale, d.position, 0);
                                },
                                height: function(d) {
                                    return MekkoChartUtils.getSize(yScale, d.valueAbsolute);
                                }
                            },
                            shapeLayoutWithoutHighlights: {
                                width: columnWidthScale,
                                x: columnStart,
                                y: function(d) {
                                    return scaledY0 + AxisHelper.diffScaled(yScale, d.position, 0);
                                },
                                height: function(d) {
                                    return MekkoChartUtils.getSize(yScale, d.originalValueAbsolute);
                                }
                            },
                            zeroShapeLayout: {
                                width: columnWidthScale,
                                x: columnStart,
                                y: function(d) {
                                    return scaledY0 + AxisHelper.diffScaled(yScale, d.position, 0) + MekkoChartUtils.getSize(yScale, d.valueAbsolute);
                                },
                                height: function(d) {
                                    return 0;
                                }
                            },
                            shapeXAxis: {
                                width: columnWidthScale,
                                x: columnStart,
                                y: function(d) {
                                    return scaledY0 + AxisHelper.diffScaled(yScale, d.position, 0);
                                },
                                height: function(d) {
                                    return MekkoChartUtils.getSize(yScale, d.valueAbsolute);
                                }
                            }
                        };
                    }, MekkoChartStrategy.prototype.createMekkoLabelDataPoints = function() {
                        for (var labelDataPoints = [], data = this.data, series = data.series, formattersCache = NewDataLabelUtils.createColumnFormatterCacheManager(), shapeLayout = this.layout.shapeLayout, i = 0, ilen = series.length; i < ilen; i++) {
                            var currentSeries = series[i], labelSettings = currentSeries.labelSettings ? currentSeries.labelSettings : data.labelSettings;
                            if (labelSettings.show && currentSeries.data) for (var axisFormatter = NewDataLabelUtils.getDisplayUnitValueFromAxisFormatter(this.yProps.formatter, labelSettings), j = 0; j < currentSeries.data.length; j++) {
                                var dataPoint = currentSeries.data[j];
                                if ((!data.hasHighlights || dataPoint.highlight) && null != dataPoint.value) {
                                    var parentRect = {
                                        left: shapeLayout.x(dataPoint),
                                        top: shapeLayout.y(dataPoint),
                                        width: shapeLayout.width(dataPoint),
                                        height: shapeLayout.height(dataPoint)
                                    }, formatString = null, value = dataPoint.valueOriginal;
                                    labelSettings.displayUnits || (formatString = NewDataLabelUtils.hundredPercentFormat, 
                                    value = dataPoint.valueAbsolute);
                                    var formatter = formattersCache.getOrCreate(formatString, labelSettings, axisFormatter), text = NewDataLabelUtils.getLabelFormattedText(formatter.format(value)), properties = {
                                        text: text,
                                        fontFamily: NewDataLabelUtils.LabelTextProperties.fontFamily,
                                        fontSize: NewDataLabelUtils.LabelTextProperties.fontSize,
                                        fontWeight: NewDataLabelUtils.LabelTextProperties.fontWeight
                                    }, textWidth = TextMeasurementService.measureSvgTextWidth(properties), textHeight = TextMeasurementService.estimateSvgTextHeight(properties);
                                    labelDataPoints.push({
                                        isPreferred: !0,
                                        text: text,
                                        textSize: {
                                            width: textWidth,
                                            height: textHeight
                                        },
                                        outsideFill: labelSettings.labelColor ? labelSettings.labelColor : NewDataLabelUtils.defaultLabelColor,
                                        insideFill: labelSettings.labelColor ? labelSettings.labelColor : NewDataLabelUtils.defaultInsideLabelColor,
                                        isParentRect: !0,
                                        parentShape: {
                                            rect: parentRect,
                                            orientation: 1,
                                            validPositions: MekkoChartStrategy.validLabelPositions
                                        },
                                        identity: dataPoint.identity,
                                        parentType: 1
                                    });
                                }
                            }
                        }
                        return labelDataPoints;
                    }, MekkoChartStrategy.Classes = {
                        item: createClassAndSelector("column"),
                        highlightItem: createClassAndSelector("highlightColumn")
                    }, MekkoChartStrategy.validLabelPositions = [ 1 ], MekkoChartStrategy;
                }();
                samples.MekkoChartStrategy = MekkoChartStrategy;
                var MekkoChart = function() {
                    function MekkoChart(options) {
                        this.isScrollable = !1, options ? (this.type = options.chartType, options.isScrollable && (this.isScrollable = options.isScrollable), 
                        this.animator = options.animator, options.cartesianSmallViewPortProperties && (this.cartesianSmallViewPortProperties = options.cartesianSmallViewPortProperties), 
                        options.behavior && (this.behavior = options.behavior)) : this.behavior = new CustomVisualBehavior([ new MekkoChartWebBehavior() ]);
                    }
                    return MekkoChart.getTextProperties = function(fontSize) {
                        return void 0 === fontSize && (fontSize = MekkoChart.FontSize), {
                            fontFamily: "wf_segoe-ui_normal",
                            fontSize: PixelConverter.toString(fontSize)
                        };
                    }, MekkoChart.prototype.init = function(options) {
                        this.visualInitOptions = options, this.layers = [];
                        var element = this.element = options.element, viewport = this.currentViewport = options.viewport;
                        this.hostServices = options.host, this.brush = d3.svg.brush(), element.addClass(MekkoChart.ClassName), 
                        this.margin = {
                            top: 1,
                            right: 1,
                            bottom: 1,
                            left: 1
                        }, this.yAxisOrientation = yAxisPosition.left, this.adjustMargins(viewport), this.sharedColorPalette = new MekkoChartSharedColorPalette(options.style.colorPalette.dataColors);
                        var showLinesOnX = !0, showLinesOnY = !0, svg = this.svg = d3.select(element.get(0)).append("svg");
                        svg.style("position", "absolute");
                        var axisGraphicsContext = this.axisGraphicsContext = svg.append("g").classed(MekkoChart.AxisGraphicsContextClassName, !0);
                        this.svgScrollable = svg.append("svg").classed("svgScrollable", !0).style("overflow", "hidden");
                        var axisGraphicsContextScrollable = this.axisGraphicsContextScrollable = this.svgScrollable.append("g").classed(MekkoChart.AxisGraphicsContextClassName, !0);
                        this.labelGraphicsContextScrollable = this.svgScrollable.append("g").classed(NewDataLabelUtils.labelGraphicsContextClass.class, !0), 
                        this.behavior && (this.clearCatcher = appendClearCatcher(this.axisGraphicsContextScrollable));
                        var axisGroup = showLinesOnX ? axisGraphicsContextScrollable : axisGraphicsContext;
                        this.xAxisGraphicsContext = showLinesOnX ? axisGraphicsContext.append("g").attr("class", "x axis") : axisGraphicsContextScrollable.append("g").attr("class", "x axis"), 
                        this.y1AxisGraphicsContext = axisGroup.append("g").attr("class", "y axis"), this.y2AxisGraphicsContext = axisGroup.append("g").attr("class", "y axis"), 
                        this.xAxisGraphicsContext.classed("showLinesOnAxis", showLinesOnX), this.y1AxisGraphicsContext.classed("showLinesOnAxis", showLinesOnY), 
                        this.y2AxisGraphicsContext.classed("showLinesOnAxis", showLinesOnY), this.xAxisGraphicsContext.classed("hideLinesOnAxis", !showLinesOnX), 
                        this.y1AxisGraphicsContext.classed("hideLinesOnAxis", !showLinesOnY), this.y2AxisGraphicsContext.classed("hideLinesOnAxis", !showLinesOnY), 
                        this.behavior && (this.interactivityService = createInteractivityService(this.hostServices)), 
                        this.legend = createLegend(element, options.interactivity && options.interactivity.isInteractiveLegend, this.interactivityService, !0);
                    }, MekkoChart.prototype.renderAxesLabels = function(options, xFontSize) {
                        this.axisGraphicsContext.selectAll(".xAxisLabel").remove(), this.axisGraphicsContext.selectAll(".yAxisLabel").remove();
                        var margin = this.margin, width = options.viewport.width - (margin.left + margin.right), height = options.viewport.height, fontSize = MekkoChart.FontSize, showOnRight = this.yAxisOrientation === yAxisPosition.right;
                        if (!options.hideXAxisTitle) {
                            var xAxisYPosition = d3.transform(this.xAxisGraphicsContext.attr("transform")).translate[1] - fontSize + xFontSize + 33, xAxisLabel = this.axisGraphicsContext.append("text").style("text-anchor", "middle").text(options.axisLabels.x).call(function(text) {
                                text.each(function() {
                                    var text = d3.select(this);
                                    text.attr({
                                        class: "xAxisLabel",
                                        x: width / 2,
                                        y: xAxisYPosition
                                    });
                                });
                            });
                            xAxisLabel.style("fill", options.xLabelColor ? options.xLabelColor.solid.color : null), 
                            xAxisLabel.call(AxisHelper.LabelLayoutStrategy.clip, width, TextMeasurementService.svgEllipsis);
                        }
                        if (!options.hideYAxisTitle) {
                            var yAxisLabel = this.axisGraphicsContext.append("text").style("text-anchor", "middle").text(options.axisLabels.y).call(function(text) {
                                text.each(function() {
                                    var text = d3.select(this);
                                    text.attr({
                                        class: "yAxisLabel",
                                        transform: "rotate(-90)",
                                        y: showOnRight ? width + margin.right - fontSize : -margin.left,
                                        x: -((height - margin.top - options.legendMargin) / 2),
                                        dy: "1em"
                                    });
                                });
                            });
                            yAxisLabel.style("fill", options.yLabelColor ? options.yLabelColor.solid.color : null), 
                            yAxisLabel.call(AxisHelper.LabelLayoutStrategy.clip, height - (margin.bottom + margin.top), TextMeasurementService.svgEllipsis);
                        }
                        if (!options.hideY2AxisTitle && options.axisLabels.y2) {
                            var y2AxisLabel = this.axisGraphicsContext.append("text").style("text-anchor", "middle").text(options.axisLabels.y2).call(function(text) {
                                text.each(function() {
                                    var text = d3.select(this);
                                    text.attr({
                                        class: "yAxisLabel",
                                        transform: "rotate(-90)",
                                        y: showOnRight ? -margin.left : width + margin.right - fontSize,
                                        x: -((height - margin.top - options.legendMargin) / 2),
                                        dy: "1em"
                                    });
                                });
                            });
                            y2AxisLabel.style("fill", options.y2LabelColor ? options.y2LabelColor.solid.color : null), 
                            y2AxisLabel.call(AxisHelper.LabelLayoutStrategy.clip, height - (margin.bottom + margin.top), TextMeasurementService.svgEllipsis);
                        }
                    }, MekkoChart.prototype.adjustMargins = function(viewport) {
                        var margin = this.margin, width = viewport.width - (margin.left + margin.right), height = viewport.height - (margin.top + margin.bottom), xAxis = this.element.find(".x.axis");
                        0 === AxisHelper.getRecommendedNumberOfTicksForXAxis(width) && 0 === AxisHelper.getRecommendedNumberOfTicksForYAxis(height) ? (this.margin = {
                            top: 0,
                            right: 0,
                            bottom: 0,
                            left: 0
                        }, xAxis.hide()) : xAxis.show();
                    }, MekkoChart.prototype.translateAxes = function(viewport) {
                        this.adjustMargins(viewport);
                        var margin = this.margin, width = viewport.width - (margin.left + margin.right), height = viewport.height - (margin.top + margin.bottom), showY1OnRight = this.yAxisOrientation === yAxisPosition.right;
                        this.xAxisGraphicsContext.attr("transform", SVGUtil.translate(0, height)), this.y1AxisGraphicsContext.attr("transform", SVGUtil.translate(showY1OnRight ? width : 0, 0)), 
                        this.y2AxisGraphicsContext.attr("transform", SVGUtil.translate(showY1OnRight ? 0 : width, 0)), 
                        this.svg.attr({
                            width: viewport.width,
                            height: viewport.height
                        }), this.svg.style("top", this.legend.isVisible() ? this.legend.getMargins().height + "px" : 0), 
                        this.svgScrollable.attr({
                            width: viewport.width,
                            height: viewport.height
                        }), this.svgScrollable.attr({
                            x: 0
                        }), this.axisGraphicsContext.attr("transform", SVGUtil.translate(margin.left, margin.top)), 
                        this.axisGraphicsContextScrollable.attr("transform", SVGUtil.translate(margin.left, margin.top)), 
                        this.labelGraphicsContextScrollable.attr("transform", SVGUtil.translate(margin.left, margin.top)), 
                        this.isXScrollBarVisible ? (this.svgScrollable.attr({
                            x: this.margin.left
                        }), this.axisGraphicsContextScrollable.attr("transform", SVGUtil.translate(0, margin.top)), 
                        this.labelGraphicsContextScrollable.attr("transform", SVGUtil.translate(0, margin.top)), 
                        this.svgScrollable.attr("width", width), this.svg.attr("width", viewport.width).attr("height", viewport.height + MekkoChart.ScrollBarWidth)) : this.isYScrollBarVisible && (this.svgScrollable.attr("height", height + margin.top), 
                        this.svg.attr("width", viewport.width + MekkoChart.ScrollBarWidth).attr("height", viewport.height));
                    }, MekkoChart.getPreferredCategorySpan = function(categoryCount, categoryThickness, noOuterPadding) {
                        var span = categoryThickness * categoryCount;
                        return noOuterPadding ? span : span + categoryThickness * MekkoChart.OuterPaddingRatio * 2;
                    }, MekkoChart.getIsScalar = function(objects, propertyId, type) {
                        var axisTypeValue = DataViewObjects.getValue(objects, propertyId);
                        return objects && void 0 !== axisTypeValue ? axisTypeValue === axisType.scalar && !AxisHelper.isOrdinal(type) : !AxisHelper.isOrdinal(type);
                    }, MekkoChart.prototype.populateObjectProperties = function(dataViews) {
                        if (dataViews && dataViews.length > 0) {
                            var dataViewMetadata = dataViews[0].metadata;
                            if (dataViewMetadata ? (this.legendObjectProperties = DataViewObjects.getObject(dataViewMetadata.objects, "legend", {}), 
                            this.borderObjectProperties = DataViewObjects.getObject(dataViewMetadata.objects, "columnBorder", {})) : (this.legendObjectProperties = {}, 
                            this.borderObjectProperties = {}), this.categoryAxisProperties = MekkochartHelper.getCategoryAxisProperties(dataViewMetadata), 
                            this.valueAxisProperties = MekkochartHelper.getValueAxisProperties(dataViewMetadata), 
                            dataViewMetadata && dataViewMetadata.objects) {
                                var categoryAxis = dataViewMetadata.objects.categoryAxis, valueAxis = dataViewMetadata.objects.valueAxis;
                                categoryAxis && (this.categoryAxisProperties.showBorder = categoryAxis.showBorder, 
                                this.categoryAxisProperties.fontSize = categoryAxis.fontSize), valueAxis && (this.valueAxisProperties.fontSize = valueAxis.fontSize);
                            }
                            var axisPosition = this.valueAxisProperties.position;
                            this.yAxisOrientation = axisPosition ? axisPosition.toString() : yAxisPosition.left;
                        }
                    }, MekkoChart.prototype.update = function(options) {
                        var dataViews = this.dataViews = options.dataViews;
                        if (this.currentViewport = options.viewport, !dataViews) return void this.clearViewport();
                        if (this.currentViewport.width < MekkoChart.MinWidth || this.currentViewport.height < MekkoChart.MinHeight) return void this.clearViewport();
                        0 === this.layers.length && (this.layers = this.createAndInitLayers(dataViews));
                        var layers = this.layers;
                        if (dataViews && dataViews.length > 0) {
                            var warnings = getInvalidValueWarnings(dataViews, !1, !1, !1);
                            warnings && warnings.length > 0 && this.hostServices.setWarnings(warnings), this.populateObjectProperties(dataViews);
                        }
                        this.sharedColorPalette.clearPreferredScale();
                        for (var i = 0, len = layers.length; i < len; i++) layers[i].setData(getLayerData(dataViews, i, len)), 
                        len > 1 && this.sharedColorPalette.rotateScale();
                        this.visualInitOptions.interactivity && this.visualInitOptions.interactivity.isInteractiveLegend || this.renderLegend(), 
                        this.render(!this.hasSetData || options.suppressAnimations), this.hasSetData = this.hasSetData || dataViews && dataViews.length > 0;
                    }, MekkoChart.prototype.clearViewport = function() {
                        this.legend.reset(), this.setVisibility(!1);
                    }, MekkoChart.prototype.setVisibility = function(status) {
                        void 0 === status && (status = !0), this.svg.style("display", status ? "block" : "none"), 
                        this.element.find(".legend").toggle(status);
                    }, MekkoChart.getLayout = function(data, options) {
                        var categoryCount = options.categoryCount, availableWidth = options.availableWidth, domain = options.domain, trimOrdinalDataOnOverflow = options.trimOrdinalDataOnOverflow, isScalar = !!options.isScalar, isScrollable = !!options.isScrollable, categoryThickness = MekkoChart.getCategoryThickness(data ? data.series : null, categoryCount, availableWidth, domain, isScalar, trimOrdinalDataOnOverflow), totalOuterPadding = categoryThickness * MekkoChart.OuterPaddingRatio * 2, calculatedBarCount = Double.floorWithPrecision((availableWidth - totalOuterPadding) / categoryThickness), visibleCategoryCount = Math.min(calculatedBarCount, categoryCount), willScroll = visibleCategoryCount < categoryCount && isScrollable, outerPaddingRatio = MekkoChart.OuterPaddingRatio;
                        if (!isScalar && !willScroll) {
                            var oneOuterPadding = (availableWidth - categoryThickness * visibleCategoryCount) / 2;
                            outerPaddingRatio = oneOuterPadding / categoryThickness;
                        }
                        return !isScalar && isScrollable && (visibleCategoryCount = categoryCount), {
                            categoryCount: visibleCategoryCount,
                            categoryThickness: categoryThickness,
                            outerPaddingRatio: outerPaddingRatio,
                            isScalar: isScalar
                        };
                    }, MekkoChart.getCategoryThickness = function(seriesList, numCategories, plotLength, domain, isScalar, trimOrdinalDataOnOverflow) {
                        var thickness;
                        if (numCategories < 2) thickness = plotLength * (1 - MekkoChart.OuterPaddingRatio); else if (isScalar && domain && domain.length > 1) {
                            var minInterval = MekkoChart.getMinInterval(seriesList), domainSpan = domain[domain.length - 1] - domain[0], ratio = minInterval / (domainSpan + minInterval * MekkoChart.OuterPaddingRatio * 2);
                            thickness = plotLength * ratio, thickness = Math.max(thickness, MekkoChart.MinScalarRectThickness);
                        } else thickness = plotLength / (numCategories + 2 * MekkoChart.OuterPaddingRatio), 
                        trimOrdinalDataOnOverflow && (thickness = Math.max(thickness, MekkoChart.MinOrdinalRectThickness));
                        var maxRectThickness = plotLength / (3 + 2 * MekkoChart.OuterPaddingRatio);
                        return thickness = Math.min(thickness, maxRectThickness), !isScalar && numCategories >= 3 && trimOrdinalDataOnOverflow ? Math.max(thickness, MekkoChart.MinOrdinalRectThickness) : thickness;
                    }, MekkoChart.getMinInterval = function(seriesList) {
                        var minInterval = Number.MAX_VALUE;
                        if (seriesList.length > 0) for (var series0data = seriesList[0].data.filter(function(d) {
                            return !d.highlight;
                        }), i = 0, ilen = series0data.length - 1; i < ilen; i++) minInterval = Math.min(minInterval, Math.abs(series0data[i + 1].categoryValue - series0data[i].categoryValue));
                        return minInterval;
                    }, MekkoChart.parseLabelSettings = function(objects) {
                        var labelSettings = dataLabelUtils.getDefaultColumnLabelSettings(!0), labelsObj = objects.labels, minPrecision = MekkoChart.DefaultSettings.labelSettings.minPrecision, maxPrecision = MekkoChart.DefaultSettings.labelSettings.maxPrecision;
                        return dataLabelUtils.updateLabelSettingsFromLabelsObject(labelsObj, labelSettings), 
                        labelSettings.precision < minPrecision && (labelSettings.precision = minPrecision), 
                        labelSettings.precision > maxPrecision && (labelSettings.precision = maxPrecision), 
                        labelSettings;
                    }, MekkoChart.parseBorderSettings = function(objects) {
                        var show = DataViewObjects.getValue(objects, MekkoChart.Properties.columnBorder.show, MekkoChart.DefaultSettings.columnBorder.show), color = DataViewObjects.getFillColor(objects, MekkoChart.Properties.columnBorder.color, MekkoChart.DefaultSettings.columnBorder.color), width = DataViewObjects.getValue(objects, MekkoChart.Properties.columnBorder.width, MekkoChart.DefaultSettings.columnBorder.width), maxWidth = MekkoChart.DefaultSettings.columnBorder.maxWidth;
                        return width > maxWidth ? width = maxWidth : width < 0 && (width = 0), show || (width = 0), 
                        {
                            show: show,
                            color: color,
                            width: width
                        };
                    }, MekkoChart.prototype.enumerateBorder = function(enumeration) {
                        var objects = {
                            columnBorder: this.borderObjectProperties
                        }, show = DataViewObjects.getValue(objects, MekkoChart.Properties.columnBorder.show, MekkoChart.DefaultSettings.columnBorder.show), color = DataViewObjects.getFillColor(objects, MekkoChart.Properties.columnBorder.color, MekkoChart.DefaultSettings.columnBorder.color), width = DataViewObjects.getValue(objects, MekkoChart.Properties.columnBorder.width, MekkoChart.DefaultSettings.columnBorder.width), maxWidth = MekkoChart.DefaultSettings.columnBorder.maxWidth;
                        width > maxWidth ? width = maxWidth : width < 0 && (width = 0);
                        var instance = {
                            objectName: "columnBorder",
                            selector: null,
                            properties: {
                                show: show,
                                color: color,
                                width: width
                            }
                        };
                        enumeration.pushInstance(instance);
                    }, MekkoChart.prototype.enumerateObjectInstances = function(options) {
                        var enumeration = new ObjectEnumerationBuilder(), layersLength = this.layers ? this.layers.length : 0;
                        if ("columnBorder" === options.objectName) this.enumerateBorder(enumeration); else if ("legend" === options.objectName) {
                            if (!this.shouldShowLegendCard()) return;
                            this.enumerateLegend(options, enumeration);
                        } else "categoryAxis" === options.objectName && this.hasCategoryAxis ? this.getCategoryAxisValues(enumeration) : "valueAxis" === options.objectName && this.getValueAxisValues(enumeration);
                        for (var i = 0, len = layersLength; i < len; i++) {
                            var layer = this.layers[i];
                            layer.enumerateObjectInstances && layer.enumerateObjectInstances(enumeration, options);
                        }
                        return enumeration.complete();
                    }, MekkoChart.prototype.enumerateLegend = function(options, enumeration) {
                        var show, showTitle, titleText, fontSize, position;
                        show = DataViewObject.getValue(this.legendObjectProperties, legendProps.show, this.legend.isVisible()), 
                        showTitle = DataViewObject.getValue(this.legendObjectProperties, legendProps.showTitle, !0), 
                        titleText = DataViewObject.getValue(this.legendObjectProperties, legendProps.titleText, this.layerLegendData && this.layerLegendData.title ? this.layerLegendData.title : ""), 
                        fontSize = DataViewObject.getValue(this.legendObjectProperties, legendProps.fontSize, this.layerLegendData && this.layerLegendData.fontSize ? this.layerLegendData.fontSize : NewDataLabelUtils.DefaultLabelFontSizeInPt), 
                        position = DataViewObject.getValue(this.legendObjectProperties, legendProps.position, visuals.legendPosition.top), 
                        enumeration.pushInstance({
                            selector: null,
                            properties: {
                                show: show,
                                position: position,
                                showTitle: showTitle,
                                titleText: titleText,
                                fontSize: fontSize
                            },
                            objectName: options.objectName
                        });
                    }, MekkoChart.prototype.shouldShowLegendCard = function() {
                        var layers = this.layers, dataViews = this.dataViews;
                        if (layers && dataViews) for (var layersLength = layers.length, layersWithValuesCtr = 0, i = 0; i < layersLength; i++) {
                            if (layers[i].hasLegend()) return !0;
                            var dataView = dataViews[i];
                            if (dataView && dataView.categorical && dataView.categorical.values && dataView.categorical.values.length > 0 && (layersWithValuesCtr++, 
                            layersWithValuesCtr > 1)) return !0;
                        }
                        return !1;
                    }, MekkoChart.prototype.getCategoryAxisValues = function(enumeration) {
                        var supportedType = axisType.both, isScalar = !1, logPossible = !!this.axes.x.isLogScaleAllowed, scaleOptions = [ axisScale.log, axisScale.linear ];
                        this.layers && this.layers[0].getSupportedCategoryAxisType && (supportedType = this.layers[0].getSupportedCategoryAxisType(), 
                        isScalar = supportedType === axisType.scalar || MekkochartHelper.isScalar(supportedType === axisType.both, this.categoryAxisProperties)), 
                        isScalar || this.categoryAxisProperties && (this.categoryAxisProperties.start = null, 
                        this.categoryAxisProperties.end = null);
                        var instance = {
                            selector: null,
                            properties: {},
                            objectName: "categoryAxis",
                            validValues: {
                                axisScale: scaleOptions
                            }
                        };
                        instance.properties.show = !this.categoryAxisProperties || null == this.categoryAxisProperties.show || this.categoryAxisProperties.show, 
                        this.yAxisIsCategorical && (instance.properties.position = this.valueAxisProperties && null != this.valueAxisProperties.position ? this.valueAxisProperties.position : yAxisPosition.left), 
                        supportedType === axisType.both && (instance.properties.axisType = isScalar ? axisType.scalar : axisType.categorical), 
                        isScalar && (instance.properties.axisScale = this.categoryAxisProperties && null != this.categoryAxisProperties.axisScale && logPossible ? this.categoryAxisProperties.axisScale : axisScale.linear, 
                        instance.properties.start = this.categoryAxisProperties ? this.categoryAxisProperties.start : null, 
                        instance.properties.end = this.categoryAxisProperties ? this.categoryAxisProperties.end : null), 
                        instance.properties.showAxisTitle = !(!this.categoryAxisProperties || null == this.categoryAxisProperties.showAxisTitle) && this.categoryAxisProperties.showAxisTitle, 
                        instance.properties.showBorder = !(!this.categoryAxisProperties || null == this.categoryAxisProperties.showBorder) && this.categoryAxisProperties.showAxisTitle, 
                        instance.properties.fontSize = this.categoryAxisProperties && null != this.categoryAxisProperties.fontSize ? this.categoryAxisProperties.fontSize : NewDataLabelUtils.DefaultLabelFontSizeInPt, 
                        enumeration.pushInstance(instance).pushInstance({
                            selector: null,
                            properties: {
                                axisStyle: this.categoryAxisProperties && this.categoryAxisProperties.axisStyle ? this.categoryAxisProperties.axisStyle : axisStyle.showTitleOnly,
                                labelColor: this.categoryAxisProperties ? this.categoryAxisProperties.labelColor : null,
                                fontSize: this.categoryAxisProperties && null != this.categoryAxisProperties.fontSize ? this.categoryAxisProperties.fontSize : NewDataLabelUtils.DefaultLabelFontSizeInPt
                            },
                            objectName: "categoryAxis",
                            validValues: {
                                axisStyle: this.categoryAxisHasUnitType ? [ axisStyle.showTitleOnly, axisStyle.showUnitOnly, axisStyle.showBoth ] : [ axisStyle.showTitleOnly ]
                            }
                        });
                    }, MekkoChart.prototype.getValueAxisValues = function(enumeration) {
                        var scaleOptions = [ axisScale.log, axisScale.linear ], logPossible = !!this.axes.y1.isLogScaleAllowed, instance = {
                            selector: null,
                            properties: {},
                            objectName: "valueAxis",
                            validValues: {
                                axisScale: scaleOptions,
                                secAxisScale: scaleOptions
                            }
                        };
                        instance.properties.show = !this.valueAxisProperties || null == this.valueAxisProperties.show || this.valueAxisProperties.show, 
                        this.yAxisIsCategorical || (instance.properties.position = this.valueAxisProperties && null != this.valueAxisProperties.position ? this.valueAxisProperties.position : yAxisPosition.left), 
                        instance.properties.axisScale = this.valueAxisProperties && null != this.valueAxisProperties.axisScale && logPossible ? this.valueAxisProperties.axisScale : axisScale.linear, 
                        instance.properties.start = this.valueAxisProperties ? this.valueAxisProperties.start : null, 
                        instance.properties.end = this.valueAxisProperties ? this.valueAxisProperties.end : null, 
                        instance.properties.showAxisTitle = !(!this.valueAxisProperties || null == this.valueAxisProperties.showAxisTitle) && this.valueAxisProperties.showAxisTitle, 
                        instance.properties.fontSize = this.valueAxisProperties && null != this.valueAxisProperties.fontSize ? this.valueAxisProperties.fontSize : NewDataLabelUtils.DefaultLabelFontSizeInPt, 
                        enumeration.pushInstance(instance).pushInstance({
                            selector: null,
                            properties: {
                                axisStyle: this.valueAxisProperties && null != this.valueAxisProperties.axisStyle ? this.valueAxisProperties.axisStyle : axisStyle.showTitleOnly,
                                labelColor: this.valueAxisProperties ? this.valueAxisProperties.labelColor : null,
                                fontSize: this.valueAxisProperties && null != this.valueAxisProperties.fontSize ? this.valueAxisProperties.fontSize : NewDataLabelUtils.DefaultLabelFontSizeInPt
                            },
                            objectName: "valueAxis",
                            validValues: {
                                axisStyle: this.valueAxisHasUnitType ? [ axisStyle.showTitleOnly, axisStyle.showUnitOnly, axisStyle.showBoth ] : [ axisStyle.showTitleOnly ]
                            }
                        }), 2 === this.layers.length && (instance.properties.secShow = this.valueAxisProperties && null != this.valueAxisProperties.secShow ? this.valueAxisProperties.secShow : this.y2AxisExists, 
                        instance.properties.secShow && (instance.properties.axisLabel = ""));
                    }, MekkoChart.prototype.onClearSelection = function() {
                        if (this.hasSetData) for (var i = 0, len = this.layers.length; i < len; i++) {
                            var layer = this.layers[i];
                            layer.onClearSelection(), layer.render(!0);
                        }
                    }, MekkoChart.prototype.createAndInitLayers = function(dataViews) {
                        var objects, _this = this;
                        if (dataViews && dataViews.length > 0) {
                            var dataViewMetadata = dataViews[0].metadata;
                            dataViewMetadata && (objects = dataViewMetadata.objects);
                        }
                        var layers = createLayers(this.type, objects, this.interactivityService, this.animator, this.isScrollable), cartesianOptions = Prototype.inherit(this.visualInitOptions);
                        cartesianOptions.svg = this.axisGraphicsContextScrollable, cartesianOptions.cartesianHost = {
                            updateLegend: function(data) {
                                return _this.legend.drawLegend(data, _this.currentViewport);
                            },
                            getSharedColors: function() {
                                return _this.sharedColorPalette;
                            },
                            triggerRender: void 0
                        };
                        for (var i = 0, len = layers.length; i < len; i++) layers[i].init(cartesianOptions);
                        return layers;
                    }, MekkoChart.prototype.renderLegend = function() {
                        for (var layers = this.layers, legendData = {
                            title: "",
                            dataPoints: []
                        }, i = 0, len = layers.length; i < len; i++) this.layerLegendData = layers[i].calculateLegend(), 
                        this.layerLegendData && (legendData.title = 0 === i ? this.layerLegendData.title || "" : legendData.title, 
                        legendData.dataPoints = legendData.dataPoints.concat(this.layerLegendData.dataPoints || []), 
                        this.layerLegendData.grouped && (legendData.grouped = !0));
                        var legendProperties = this.legendObjectProperties;
                        if (legendProperties) {
                            legendProperties.fontSize || (legendProperties.fontSize = NewDataLabelUtils.DefaultLabelFontSizeInPt), 
                            LegendData.update(legendData, legendProperties);
                            var position = legendProperties[legendProps.position];
                            position && this.legend.changeOrientation(LegendPosition[position]);
                        } else this.legend.changeOrientation(LegendPosition.Top);
                        (1 === legendData.dataPoints.length && !legendData.grouped || this.hideLegends()) && (legendData.dataPoints = []), 
                        this.legend.drawLegend(legendData, this.currentViewport);
                    }, MekkoChart.prototype.hideLegends = function() {
                        return !!(this.cartesianSmallViewPortProperties && this.cartesianSmallViewPortProperties.hideLegendOnSmallViewPort && this.currentViewport.height < this.cartesianSmallViewPortProperties.MinHeightLegendVisible);
                    }, MekkoChart.prototype.addUnitTypeToAxisLabel = function(axes) {
                        var unitType = MekkoChart.getUnitType(axes, function(axis) {
                            return axis.x;
                        });
                        if (axes.x.isCategoryAxis ? this.categoryAxisHasUnitType = null !== unitType : this.valueAxisHasUnitType = null !== unitType, 
                        axes.x.axisLabel && unitType && (axes.x.isCategoryAxis ? axes.x.axisLabel = AxisHelper.createAxisLabel(this.categoryAxisProperties, axes.x.axisLabel, unitType) : axes.x.axisLabel = AxisHelper.createAxisLabel(this.valueAxisProperties, axes.x.axisLabel, unitType)), 
                        unitType = MekkoChart.getUnitType(axes, function(axis) {
                            return axis.y1;
                        }), axes.y1.isCategoryAxis ? this.categoryAxisHasUnitType = null !== unitType : this.valueAxisHasUnitType = null !== unitType, 
                        axes.y1.axisLabel && unitType && (axes.y1.isCategoryAxis ? axes.y1.axisLabel = AxisHelper.createAxisLabel(this.categoryAxisProperties, axes.y1.axisLabel, unitType) : axes.y1.axisLabel = AxisHelper.createAxisLabel(this.valueAxisProperties, axes.y1.axisLabel, unitType)), 
                        axes.y2) {
                            var unitType = MekkoChart.getUnitType(axes, function(axis) {
                                return axis.y2;
                            });
                            this.secValueAxisHasUnitType = null !== unitType, axes.y2.axisLabel && unitType && this.valueAxisProperties && this.valueAxisProperties.secAxisStyle && (this.valueAxisProperties.secAxisStyle === axisStyle.showBoth ? axes.y2.axisLabel = axes.y2.axisLabel + " (" + unitType + ")" : this.valueAxisProperties.secAxisStyle === axisStyle.showUnitOnly && (axes.y2.axisLabel = unitType));
                        }
                    }, MekkoChart.prototype.shouldRenderSecondaryAxis = function(axisProperties) {
                        return !!axisProperties && (!(this.valueAxisProperties && null != this.valueAxisProperties.secShow && !this.valueAxisProperties.secShow) && (axisProperties.values && axisProperties.values.length > 0));
                    }, MekkoChart.prototype.shouldRenderAxis = function(axisProperties, propertyName) {
                        return void 0 === propertyName && (propertyName = "show"), !!axisProperties && (!axisProperties.isCategoryAxis || this.categoryAxisProperties && null != this.categoryAxisProperties[propertyName] && !this.categoryAxisProperties[propertyName] ? !(axisProperties.isCategoryAxis || this.valueAxisProperties && null != this.valueAxisProperties[propertyName] && !this.valueAxisProperties[propertyName]) && (axisProperties.values && axisProperties.values.length > 0) : axisProperties.values && axisProperties.values.length > 0);
                    }, MekkoChart.prototype.render = function(suppressAnimations) {
                        this.setVisibility(!0);
                        var legendMargins = this.legendMargins = this.legend.getMargins(), viewport = {
                            height: this.currentViewport.height - legendMargins.height,
                            width: this.currentViewport.width - legendMargins.width
                        }, maxMarginFactor = this.getMaxMarginFactor(), leftRightMarginLimit = this.leftRightMarginLimit = viewport.width * maxMarginFactor;
                        this.bottomMarginLimit = Math.max(MekkoChart.MinBottomMargin, Math.ceil(viewport.height * maxMarginFactor));
                        var xAxisTextProperties = MekkoChart.getTextProperties(this.categoryAxisProperties && jsCommon.PixelConverter.fromPointToPixel(parseFloat(this.categoryAxisProperties.fontSize)) || void 0), y1AxisTextProperties = MekkoChart.getTextProperties(this.valueAxisProperties && jsCommon.PixelConverter.fromPointToPixel(parseFloat(this.valueAxisProperties.fontSize)) || void 0), margin = this.margin;
                        margin.top = parseFloat(y1AxisTextProperties.fontSize) / 2, margin.bottom = MekkoChart.MinBottomMargin, 
                        margin.right = 0;
                        var axes = this.axes = calculateAxes(this.layers, viewport, margin, this.categoryAxisProperties, this.valueAxisProperties, this.isXScrollBarVisible || this.isYScrollBarVisible, null);
                        this.yAxisIsCategorical = axes.y1.isCategoryAxis, this.hasCategoryAxis = this.yAxisIsCategorical ? axes.y1 && axes.y1.values.length > 0 : axes.x && axes.x.values.length > 0;
                        var mainAxisScale, preferredViewport, renderXAxis = this.shouldRenderAxis(axes.x), renderY1Axis = this.shouldRenderAxis(axes.y1), renderY2Axis = this.shouldRenderSecondaryAxis(axes.y2), width = viewport.width - (margin.left + margin.right), isScalar = !1;
                        this.isXScrollBarVisible = !1, this.isYScrollBarVisible = !1;
                        var yAxisOrientation = this.yAxisOrientation, showY1OnRight = yAxisOrientation === yAxisPosition.right;
                        if (this.layers && (this.layers[0].getVisualCategoryAxisIsScalar && (isScalar = this.layers[0].getVisualCategoryAxisIsScalar()), 
                        !isScalar && this.isScrollable && this.layers[0].getPreferredPlotArea)) {
                            var categoryThickness = this.scrollX ? axes.x.categoryThickness : axes.y1.categoryThickness, categoryCount = this.scrollX ? axes.x.values.length : axes.y1.values.length;
                            preferredViewport = this.layers[0].getPreferredPlotArea(isScalar, categoryCount, categoryThickness), 
                            this.scrollX && preferredViewport && preferredViewport.width > viewport.width && (this.isXScrollBarVisible = !0, 
                            viewport.height -= MekkoChart.ScrollBarWidth), this.scrollY && preferredViewport && preferredViewport.height > viewport.height && (this.isYScrollBarVisible = !0, 
                            viewport.width -= MekkoChart.ScrollBarWidth, width = viewport.width - (margin.left + margin.right));
                        }
                        this.isXScrollBarVisible || this.isYScrollBarVisible ? this.brushGraphicsContext || (this.brushGraphicsContext = this.svg.append("g").classed("x brush", !0)) : (this.svg.selectAll(".brush").remove(), 
                        this.brushGraphicsContext = void 0), axes = calculateAxes(this.layers, viewport, margin, this.categoryAxisProperties, this.valueAxisProperties, this.isXScrollBarVisible || this.isYScrollBarVisible, null);
                        for (var doneWithMargins = !1, maxIterations = 2, numIterations = 0, tickLabelMargins = void 0, chartHasAxisLabels = void 0, axisLabels = void 0; !doneWithMargins && numIterations < maxIterations; ) {
                            numIterations++, tickLabelMargins = getTickLabelMargins({
                                width: width,
                                height: viewport.height
                            }, leftRightMarginLimit, TextMeasurementService.measureSvgTextWidth, TextMeasurementService.estimateSvgTextHeight, axes, this.bottomMarginLimit, xAxisTextProperties, y1AxisTextProperties, null, !1, this.isXScrollBarVisible || this.isYScrollBarVisible, showY1OnRight, renderXAxis, renderY1Axis, renderY2Axis);
                            var maxMainYaxisSide = showY1OnRight ? tickLabelMargins.yRight : tickLabelMargins.yLeft, maxSecondYaxisSide = showY1OnRight ? tickLabelMargins.yLeft : tickLabelMargins.yRight, xMax = renderXAxis ? tickLabelMargins.xMax / 1.8 : 0;
                            maxMainYaxisSide += MekkoChart.LeftPadding, maxSecondYaxisSide += MekkoChart.RightPadding, 
                            xMax += MekkoChart.BottomPadding, this.hideAxisLabels(legendMargins) && (axes.x.axisLabel = null, 
                            axes.y1.axisLabel = null, axes.y2 && (axes.y2.axisLabel = null)), this.addUnitTypeToAxisLabel(axes), 
                            axisLabels = {
                                x: axes.x.axisLabel,
                                y: axes.y1.axisLabel,
                                y2: axes.y2 ? axes.y2.axisLabel : null
                            }, chartHasAxisLabels = null != axisLabels.x || null != axisLabels.y || null != axisLabels.y2, 
                            null != axisLabels.x && (xMax += MekkoChart.XAxisLabelPadding), null != axisLabels.y && (maxMainYaxisSide += MekkoChart.YAxisLabelPadding), 
                            null != axisLabels.y2 && (maxSecondYaxisSide += MekkoChart.YAxisLabelPadding), margin.left = showY1OnRight ? maxSecondYaxisSide : maxMainYaxisSide, 
                            margin.right = showY1OnRight ? maxMainYaxisSide : maxSecondYaxisSide, margin.bottom = xMax, 
                            this.margin = margin, width = viewport.width - (margin.left + margin.right);
                            var previousTickCountY1 = axes.y1.values.length, previousTickCountY2 = axes.y2 && axes.y2.values.length;
                            axes = calculateAxes(this.layers, viewport, margin, this.categoryAxisProperties, this.valueAxisProperties, this.isXScrollBarVisible || this.isYScrollBarVisible, axes), 
                            axes.y1.values.length !== previousTickCountY1 || axes.y2 && axes.y2.values.length !== previousTickCountY2 || (doneWithMargins = !0);
                        }
                        this.renderChart(mainAxisScale, axes, width, tickLabelMargins, chartHasAxisLabels, axisLabels, viewport, suppressAnimations);
                    }, MekkoChart.prototype.hideAxisLabels = function(legendMargins) {
                        return !(!(this.cartesianSmallViewPortProperties && this.cartesianSmallViewPortProperties.hideAxesOnSmallViewPort && this.currentViewport.height + legendMargins.height < this.cartesianSmallViewPortProperties.MinHeightAxesVisible) || this.visualInitOptions.interactivity.isInteractiveLegend);
                    }, MekkoChart.getUnitType = function(axis, axisPropertiesLookup) {
                        return axisPropertiesLookup(axis).formatter && axisPropertiesLookup(axis).formatter.displayUnit && axisPropertiesLookup(axis).formatter.displayUnit.value > 1 ? axisPropertiesLookup(axis).formatter.displayUnit.title : null;
                    }, MekkoChart.prototype.getMaxMarginFactor = function() {
                        return this.visualInitOptions.style.maxMarginFactor || MekkoChart.MaxMarginFactor;
                    }, MekkoChart.getChartViewport = function(viewport, margin) {
                        return {
                            width: viewport.width - margin.left - margin.right,
                            height: viewport.height - margin.top - margin.bottom
                        };
                    }, MekkoChart.wordBreak = function(text, axisProperties, columnsWidth, maxHeight, borderWidth) {
                        text.each(function(data, index) {
                            var width, allowedLength, node = d3.select(this);
                            columnsWidth.length >= index ? (width = columnsWidth[index], allowedLength = axisProperties.scale(width)) : allowedLength = axisProperties.xLabelMaxWidth, 
                            node.style("text-anchor", "middle").attr({
                                dx: "0em",
                                dy: "1em",
                                transform: "rotate(0)"
                            }), TextMeasurementService.wordBreak(this, allowedLength, axisProperties.willLabelsWordBreak ? maxHeight : 0);
                        });
                    }, MekkoChart.prototype.renderChart = function(mainAxisScale, axes, width, tickLabelMargins, chartHasAxisLabels, axisLabels, viewport, suppressAnimations, scrollScale, extent) {
                        var xLabelColor, yLabelColor, y2LabelColor, xFontSize, yFontSize, bottomMarginLimit = this.bottomMarginLimit, leftRightMarginLimit = this.leftRightMarginLimit, layers = this.layers, duration = GetAnimationDuration(this.animator, suppressAnimations), chartViewport = MekkoChart.getChartViewport(viewport, this.margin);
                        if (this.shouldRenderAxis(axes.x)) {
                            axes.x.isCategoryAxis ? (xLabelColor = this.categoryAxisProperties && this.categoryAxisProperties.labelColor ? this.categoryAxisProperties.labelColor : null, 
                            xFontSize = this.categoryAxisProperties && null != this.categoryAxisProperties.fontSize ? this.categoryAxisProperties.fontSize : NewDataLabelUtils.DefaultLabelFontSizeInPt) : (xLabelColor = this.valueAxisProperties && this.valueAxisProperties.labelColor ? this.valueAxisProperties.labelColor : null, 
                            xFontSize = this.valueAxisProperties && this.valueAxisProperties.fontSize ? this.valueAxisProperties.fontSize : NewDataLabelUtils.DefaultLabelFontSizeInPt), 
                            xFontSize = jsCommon.PixelConverter.fromPointToPixel(xFontSize), axes.x.axis.orient("bottom"), 
                            axes.x.willLabelsFit || axes.x.axis.tickPadding(MekkoChart.TickPaddingRotatedX);
                            var xAxisGraphicsElement = this.xAxisGraphicsContext;
                            duration ? xAxisGraphicsElement.transition().duration(duration).call(axes.x.axis) : xAxisGraphicsElement.call(axes.x.axis), 
                            xAxisGraphicsElement.call(MekkoChart.darkenZeroLine).call(MekkoChart.setAxisLabelColor, xLabelColor).call(MekkoChart.setAxisLabelFontSize, xFontSize);
                            var xAxisTextNodes = xAxisGraphicsElement.selectAll("text"), columnWidth = [], borderWidth = 0;
                            this.layers && this.layers.length && (columnWidth = this.layers[0].getColumnsWidth(), 
                            borderWidth = this.layers[0].getBorderWidth()), xAxisGraphicsElement.call(MekkoChart.moveBorder, axes.x.scale, borderWidth, xFontSize / 1.5 - 12), 
                            xAxisTextNodes.call(MekkoChart.wordBreak, axes.x, columnWidth, bottomMarginLimit, borderWidth);
                        } else this.xAxisGraphicsContext.selectAll("*").remove();
                        if (this.shouldRenderAxis(axes.y1)) {
                            axes.y1.isCategoryAxis ? (yLabelColor = this.categoryAxisProperties && this.categoryAxisProperties.labelColor ? this.categoryAxisProperties.labelColor : null, 
                            yFontSize = this.categoryAxisProperties && null != this.categoryAxisProperties.fontSize ? this.categoryAxisProperties.fontSize : NewDataLabelUtils.DefaultLabelFontSizeInPt) : (yLabelColor = this.valueAxisProperties && this.valueAxisProperties.labelColor ? this.valueAxisProperties.labelColor : null, 
                            yFontSize = this.valueAxisProperties && null != this.valueAxisProperties.fontSize ? this.valueAxisProperties.fontSize : NewDataLabelUtils.DefaultLabelFontSizeInPt), 
                            yFontSize = jsCommon.PixelConverter.fromPointToPixel(yFontSize);
                            var yAxisOrientation = this.yAxisOrientation, showY1OnRight = yAxisOrientation === yAxisPosition.right;
                            axes.y1.axis.tickSize(-width).tickPadding(MekkoChart.TickPaddingY).orient(yAxisOrientation.toLowerCase());
                            var y1AxisGraphicsElement = this.y1AxisGraphicsContext;
                            duration ? y1AxisGraphicsElement.transition().duration(duration).call(axes.y1.axis) : y1AxisGraphicsElement.call(axes.y1.axis), 
                            y1AxisGraphicsElement.call(MekkoChart.darkenZeroLine).call(MekkoChart.setAxisLabelColor, yLabelColor).call(MekkoChart.setAxisLabelFontSize, yFontSize), 
                            tickLabelMargins.yLeft >= leftRightMarginLimit && y1AxisGraphicsElement.selectAll("text").call(AxisHelper.LabelLayoutStrategy.clip, leftRightMarginLimit - MekkoChart.LeftPadding, TextMeasurementService.svgEllipsis), 
                            !axes.y2 || this.valueAxisProperties && null != this.valueAxisProperties.secShow && !this.valueAxisProperties.secShow ? this.y2AxisGraphicsContext.selectAll("*").remove() : (y2LabelColor = this.valueAxisProperties && this.valueAxisProperties.secLabelColor ? this.valueAxisProperties.secLabelColor : null, 
                            axes.y2.axis.tickPadding(MekkoChart.TickPaddingY).orient(showY1OnRight ? yAxisPosition.left.toLowerCase() : yAxisPosition.right.toLowerCase()), 
                            duration ? this.y2AxisGraphicsContext.transition().duration(duration).call(axes.y2.axis) : this.y2AxisGraphicsContext.call(axes.y2.axis), 
                            this.y2AxisGraphicsContext.call(MekkoChart.darkenZeroLine).call(MekkoChart.setAxisLabelColor, y2LabelColor), 
                            tickLabelMargins.yRight >= leftRightMarginLimit && this.y2AxisGraphicsContext.selectAll("text").call(AxisHelper.LabelLayoutStrategy.clip, leftRightMarginLimit - MekkoChart.RightPadding, TextMeasurementService.svgEllipsis));
                        } else this.y1AxisGraphicsContext.selectAll("*").remove(), this.y2AxisGraphicsContext.selectAll("*").remove();
                        if (this.translateAxes(viewport), chartHasAxisLabels) {
                            var hideXAxisTitle = !this.shouldRenderAxis(axes.x, "showAxisTitle"), hideYAxisTitle = !this.shouldRenderAxis(axes.y1, "showAxisTitle"), hideY2AxisTitle = this.valueAxisProperties && null != this.valueAxisProperties.secShowAxisTitle && this.valueAxisProperties.secShowAxisTitle === !1, renderAxisOptions = {
                                axisLabels: axisLabels,
                                legendMargin: this.legendMargins.height,
                                viewport: viewport,
                                hideXAxisTitle: hideXAxisTitle,
                                hideYAxisTitle: hideYAxisTitle,
                                hideY2AxisTitle: hideY2AxisTitle,
                                xLabelColor: xLabelColor,
                                yLabelColor: yLabelColor,
                                y2LabelColor: y2LabelColor,
                                margin: void 0
                            };
                            this.renderAxesLabels(renderAxisOptions, xFontSize);
                        } else this.axisGraphicsContext.selectAll(".xAxisLabel").remove(), this.axisGraphicsContext.selectAll(".yAxisLabel").remove();
                        var dataPoints = [], layerBehaviorOptions = [], labelDataPointsGroup = [];
                        if (this.behavior) {
                            for (var i = 0, len = layers.length; i < len; i++) {
                                var result = layers[i].render(suppressAnimations);
                                if (result) if (dataPoints = dataPoints.concat(result.dataPoints), layerBehaviorOptions.push(result.behaviorOptions), 
                                result.labelDataPointGroups) for (var resultLabelDataPointsGroups = result.labelDataPointGroups, j = 0, jlen = resultLabelDataPointsGroups.length; j < jlen; j++) {
                                    var resultLabelDataPointsGroup = resultLabelDataPointsGroups[j];
                                    labelDataPointsGroup.push({
                                        labelDataPoints: resultLabelDataPointsGroup.labelDataPoints,
                                        maxNumberOfLabels: resultLabelDataPointsGroup.maxNumberOfLabels
                                    });
                                } else {
                                    var resultsLabelDataPoints = result.labelDataPoints, reducedDataPoints = resultsLabelDataPoints;
                                    labelDataPointsGroup.push({
                                        labelDataPoints: reducedDataPoints,
                                        maxNumberOfLabels: reducedDataPoints.length
                                    });
                                }
                            }
                            var labelLayoutOptions = {
                                maximumOffset: NewDataLabelUtils.maxLabelOffset,
                                startingOffset: NewDataLabelUtils.startingLabelOffset
                            }, labelLayout = new LabelLayout(labelLayoutOptions), dataLabels = labelLayout.layout(labelDataPointsGroup, chartViewport);
                            if (layers.length > 1 && NewDataLabelUtils.drawLabelBackground(this.labelGraphicsContextScrollable, dataLabels, "#FFFFFF", .7), 
                            this.animator && !suppressAnimations ? NewDataLabelUtils.animateDefaultLabels(this.labelGraphicsContextScrollable, dataLabels, this.animator.getDuration()) : NewDataLabelUtils.drawDefaultLabels(this.labelGraphicsContextScrollable, dataLabels), 
                            this.labelGraphicsContextScrollable.selectAll("text.label").style("pointer-events", "none"), 
                            this.interactivityService) {
                                var behaviorOptions = {
                                    layerOptions: layerBehaviorOptions,
                                    clearCatcher: this.clearCatcher
                                };
                                this.interactivityService.bind(dataPoints, this.behavior, behaviorOptions);
                            }
                        }
                    }, MekkoChart.darkenZeroLine = function(g) {
                        var zeroTick = g.selectAll("g.tick").filter(function(data) {
                            return 0 === data;
                        }).node();
                        zeroTick && d3.select(zeroTick).select("line").classed("zero-line", !0);
                    }, MekkoChart.setAxisLabelColor = function(g, fill) {
                        g.selectAll("g.tick text").style("fill", fill ? fill.solid.color : null);
                    }, MekkoChart.setAxisLabelFontSize = function(g, fontSize) {
                        var value = PixelConverter.toString(fontSize);
                        g.selectAll("g.tick text").attr("font-size", value);
                    }, MekkoChart.moveBorder = function(g, scale, borderWidth, yOffset) {
                        void 0 === yOffset && (yOffset = 0), g.selectAll("g.tick").attr("transform", function(value, index) {
                            return SVGUtil.translate(scale(value) + borderWidth * index, yOffset);
                        });
                    }, MekkoChart.Classes = {
                        series: createClassAndSelector("series")
                    }, MekkoChart.capabilities = {
                        dataRoles: [ {
                            name: "Category",
                            kind: VisualDataRoleKind.Grouping,
                            displayName: "Category"
                        }, {
                            name: "Series",
                            kind: VisualDataRoleKind.Grouping,
                            displayName: "Series"
                        }, {
                            name: "Y",
                            kind: VisualDataRoleKind.Measure,
                            displayName: "Y Axis"
                        }, {
                            name: "Width",
                            kind: VisualDataRoleKind.Measure,
                            displayName: "Axis width"
                        } ],
                        objects: {
                            columnBorder: {
                                displayName: "Column Border",
                                properties: {
                                    show: {
                                        displayName: "Show",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    color: {
                                        displayName: "Color",
                                        description: "Select color for data labels",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    width: {
                                        displayName: "Width",
                                        type: {
                                            numeric: !0
                                        }
                                    }
                                }
                            },
                            labels: {
                                displayName: "Data labels",
                                description: "Display data label options",
                                properties: {
                                    show: {
                                        displayName: "Show",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    color: {
                                        displayName: "Color",
                                        description: "Select color for data labels",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    labelDisplayUnits: {
                                        displayName: "Display units",
                                        description: "Select the units (millions, billions, etc.)",
                                        type: {
                                            formatting: {
                                                labelDisplayUnits: !0
                                            }
                                        },
                                        suppressFormatPainterCopy: !0
                                    },
                                    labelPrecision: {
                                        displayName: "Decimal Places",
                                        description: "Select the number of decimal places to display",
                                        placeHolderText: "Auto",
                                        type: {
                                            numeric: !0
                                        },
                                        suppressFormatPainterCopy: !0
                                    },
                                    showAll: {
                                        displayName: "Show All",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    fontSize: {
                                        displayName: "Text Size",
                                        type: {
                                            formatting: {
                                                fontSize: !0
                                            }
                                        }
                                    }
                                }
                            },
                            legend: {
                                displayName: "Legend",
                                properties: {
                                    show: {
                                        displayName: "Show",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    position: {
                                        displayName: "Position",
                                        type: {
                                            formatting: {
                                                legendPosition: !0
                                            }
                                        }
                                    },
                                    showTitle: {
                                        displayName: "Title",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    titleText: {
                                        displayName: "Title text",
                                        type: {
                                            text: !0
                                        }
                                    },
                                    fontSize: {
                                        displayName: "Text size",
                                        type: {
                                            formatting: {
                                                fontSize: !0
                                            }
                                        }
                                    }
                                }
                            },
                            categoryAxis: {
                                displayName: "X-Axis",
                                properties: {
                                    show: {
                                        displayName: "Show",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    position: {
                                        displayName: "Position",
                                        type: {
                                            formatting: {
                                                yAxisPosition: !0
                                            }
                                        }
                                    },
                                    axisScale: {
                                        displayName: "Scale type",
                                        type: {
                                            formatting: {
                                                axisScale: !0
                                            }
                                        }
                                    },
                                    axisType: {
                                        displayName: "Type",
                                        type: {
                                            formatting: {
                                                axisType: !0
                                            }
                                        }
                                    },
                                    showAxisTitle: {
                                        displayName: "Title",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    axisStyle: {
                                        displayName: "Style",
                                        type: {
                                            formatting: {
                                                axisStyle: !0
                                            }
                                        }
                                    },
                                    labelColor: {
                                        displayName: "Color",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    fontSize: {
                                        displayName: "Text Size",
                                        type: {
                                            formatting: {
                                                fontSize: !0
                                            }
                                        }
                                    }
                                }
                            },
                            valueAxis: {
                                displayName: "Y-Axis",
                                properties: {
                                    show: {
                                        displayName: "Show",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    position: {
                                        displayName: "Position",
                                        type: {
                                            formatting: {
                                                yAxisPosition: !0
                                            }
                                        }
                                    },
                                    axisScale: {
                                        displayName: "Scale type",
                                        type: {
                                            formatting: {
                                                axisScale: !0
                                            }
                                        }
                                    },
                                    intersection: {
                                        displayName: "Intersection",
                                        type: {
                                            numeric: !0
                                        }
                                    },
                                    showAxisTitle: {
                                        displayName: "Title",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    axisStyle: {
                                        displayName: "Style",
                                        type: {
                                            formatting: {
                                                axisStyle: !0
                                            }
                                        }
                                    },
                                    labelColor: {
                                        displayName: "Color",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    fontSize: {
                                        displayName: "Text Size",
                                        type: {
                                            formatting: {
                                                fontSize: !0
                                            }
                                        }
                                    }
                                }
                            },
                            dataPoint: {
                                displayName: "Data colors",
                                properties: {
                                    defaultColor: {
                                        displayName: "Default color",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    showAllDataPoints: {
                                        displayName: "Show all",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    fill: {
                                        displayName: "Fill",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    fillRule: {
                                        displayName: "Color saturation",
                                        type: {
                                            fillRule: {}
                                        },
                                        rule: {
                                            inputRole: "Gradient",
                                            output: {
                                                property: "fill",
                                                selector: [ "Category" ]
                                            }
                                        }
                                    }
                                }
                            }
                        },
                        dataViewMappings: [ {
                            conditions: [ {
                                Category: {
                                    min: 0,
                                    max: 1
                                },
                                Series: {
                                    min: 0,
                                    max: 1
                                },
                                Y: {
                                    min: 0,
                                    max: 1
                                },
                                Width: {
                                    min: 0,
                                    max: 1
                                }
                            } ],
                            categorical: {
                                categories: {
                                    for: {
                                        in: "Category"
                                    },
                                    dataReductionAlgorithm: {
                                        top: {}
                                    }
                                },
                                values: {
                                    group: {
                                        by: "Series",
                                        select: [ {
                                            for: {
                                                in: "Y"
                                            }
                                        }, {
                                            for: {
                                                in: "Width"
                                            }
                                        } ],
                                        dataReductionAlgorithm: {
                                            top: {}
                                        }
                                    }
                                },
                                rowCount: {
                                    preferred: {
                                        min: 1,
                                        max: 1
                                    },
                                    supported: {
                                        min: 0
                                    }
                                }
                            }
                        } ],
                        supportsHighlight: !0,
                        sorting: {
                            default: {}
                        },
                        drilldown: {
                            roles: [ "Category" ]
                        }
                    }, MekkoChart.Properties = {
                        dataPoint: {
                            defaultColor: {
                                objectName: "dataPoint",
                                propertyName: "defaultColor"
                            },
                            fill: {
                                objectName: "dataPoint",
                                propertyName: "fill"
                            },
                            showAllDataPoints: {
                                objectName: "dataPoint",
                                propertyName: "showAllDataPoints"
                            }
                        },
                        general: {
                            formatString: {
                                objectName: "general",
                                propertyName: "formatString"
                            }
                        },
                        columnBorder: {
                            show: {
                                objectName: "columnBorder",
                                propertyName: "show"
                            },
                            color: {
                                objectName: "columnBorder",
                                propertyName: "color"
                            },
                            width: {
                                objectName: "columnBorder",
                                propertyName: "width"
                            }
                        }
                    }, MekkoChart.DefaultSettings = {
                        columnBorder: {
                            show: !0,
                            color: "#fff",
                            width: 2,
                            maxWidth: 5
                        },
                        labelSettings: {
                            maxPrecision: 4,
                            minPrecision: 0
                        }
                    }, MekkoChart.MinOrdinalRectThickness = 20, MekkoChart.MinScalarRectThickness = 2, 
                    MekkoChart.OuterPaddingRatio = .4, MekkoChart.InnerPaddingRatio = .2, MekkoChart.TickLabelPadding = 2, 
                    MekkoChart.ClassName = "cartesianChart", MekkoChart.AxisGraphicsContextClassName = "axisGraphicsContext", 
                    MekkoChart.MaxMarginFactor = .25, MekkoChart.MinBottomMargin = 50, MekkoChart.LeftPadding = 10, 
                    MekkoChart.RightPadding = 10, MekkoChart.BottomPadding = 16, MekkoChart.YAxisLabelPadding = 20, 
                    MekkoChart.XAxisLabelPadding = 20, MekkoChart.TickPaddingY = 10, MekkoChart.TickPaddingRotatedX = 5, 
                    MekkoChart.FontSize = 11, MekkoChart.MaxNumberOfLabels = 100, MekkoChart.MinWidth = 100, 
                    MekkoChart.MinHeight = 100, MekkoChart.ScrollBarWidth = 10, MekkoChart;
                }();
                samples.MekkoChart = MekkoChart, samples.createLayers = createLayers;
                var RoleNames = {
                    category: "Category",
                    series: "Series",
                    y: "Y",
                    width: "Width"
                }, MekkoColumnChart = function() {
                    function MekkoColumnChart(options) {
                        var chartType = options.chartType;
                        this.chartType = chartType, this.categoryAxisType = null, this.animator = options.animator, 
                        this.isScrollable = options.isScrollable, this.interactivityService = options.interactivityService;
                    }
                    return MekkoColumnChart.prototype.init = function(options) {
                        this.svg = options.svg, this.unclippedGraphicsContext = this.svg.append("g").classed("columnChartUnclippedGraphicsContext", !0), 
                        this.mainGraphicsContext = this.unclippedGraphicsContext.append("svg").classed("columnChartMainGraphicsContext", !0), 
                        this.labelGraphicsContext = this.svg.append("g").classed(NewDataLabelUtils.labelGraphicsContextClass.class, !0), 
                        this.style = options.style, this.currentViewport = options.viewport, this.hostService = options.host, 
                        this.interactivity = options.interactivity, this.colors = this.style.colorPalette.dataColors, 
                        this.cartesianVisualHost = options.cartesianHost, this.options = options, this.supportsOverflow = !EnumExtensions.hasFlag(this.chartType, flagStacked);
                        var element = this.element = options.element;
                        element.addClass(MekkoColumnChart.ColumnChartClassName), this.columnChart = new MekkoChartStrategy();
                    }, MekkoColumnChart.prototype.getCategoryLayout = function(numCategoryValues, options) {
                        var availableWidth = this.currentViewport.width - (this.margin.left + this.margin.right), metaDataColumn = this.data ? this.data.categoryMetadata : void 0, categoryDataType = AxisHelper.getCategoryValueType(metaDataColumn), isScalar = !!this.data && this.data.scalarCategoryAxis, domain = AxisHelper.createDomain(this.data.series, categoryDataType, isScalar, options.forcedXDomain);
                        return MekkoChart.getLayout(this.data, {
                            availableWidth: availableWidth,
                            categoryCount: numCategoryValues,
                            domain: domain,
                            isScalar: isScalar,
                            isScrollable: this.isScrollable,
                            trimOrdinalDataOnOverflow: !1
                        });
                    }, MekkoColumnChart.getBorderWidth = function(border) {
                        if (!border || !border.show || !border.width) return 0;
                        var width = border.width;
                        return width < 0 ? 0 : width > border.maxWidth ? border.maxWidth : width;
                    }, MekkoColumnChart.getBorderColor = function(border) {
                        return border ? border.color : MekkoChart.DefaultSettings.columnBorder.color;
                    }, MekkoColumnChart.converter = function(dataView, colors, is100PercentStacked, isScalar, supportsOverflow, dataViewMetadata, chartType) {
                        void 0 === is100PercentStacked && (is100PercentStacked = !1), void 0 === isScalar && (isScalar = !1), 
                        void 0 === supportsOverflow && (supportsOverflow = !1), void 0 === dataViewMetadata && (dataViewMetadata = null);
                        var xAxisCardProperties = MekkochartHelper.getCategoryAxisProperties(dataViewMetadata), valueAxisProperties = MekkochartHelper.getValueAxisProperties(dataViewMetadata);
                        isScalar = MekkochartHelper.isScalar(isScalar, xAxisCardProperties), dataView = MekkoChartUtils.applyUserMinMax(isScalar, dataView, xAxisCardProperties);
                        var converterStrategy = new MekkoChartConverterHelper(dataView), categoryInfo = converterHelper.getPivotedCategories(dataView, MekkoChart.Properties.general.formatString), categories = categoryInfo.categories, categoryFormatter = categoryInfo.categoryFormatter, categoryIdentities = categoryInfo.categoryIdentities, categoryMetadata = dataView.categories && dataView.categories.length > 0 ? dataView.categories[0].source : void 0, borderSettings = MekkoChart.DefaultSettings.columnBorder, labelSettings = dataLabelUtils.getDefaultColumnLabelSettings(!0), defaultDataPointColor = void 0, showAllDataPoints = void 0;
                        if (dataViewMetadata && dataViewMetadata.objects) {
                            var objects = dataViewMetadata.objects;
                            defaultDataPointColor = DataViewObjects.getFillColor(objects, MekkoChart.Properties.dataPoint.defaultColor), 
                            showAllDataPoints = DataViewObjects.getValue(objects, MekkoChart.Properties.dataPoint.showAllDataPoints), 
                            labelSettings = MekkoChart.parseLabelSettings(objects), borderSettings = MekkoChart.parseBorderSettings(objects);
                        }
                        for (var legendAndSeriesInfo = converterStrategy.getLegend(colors, defaultDataPointColor), legend = legendAndSeriesInfo.legend.dataPoints, seriesSources = legendAndSeriesInfo.seriesSources, result = MekkoColumnChart.createDataPoints(dataView, categories, categoryIdentities, legend, legendAndSeriesInfo.seriesObjects, converterStrategy, labelSettings, is100PercentStacked, isScalar, supportsOverflow, converterHelper.categoryIsAlsoSeriesRole(dataView, RoleNames.series, RoleNames.category), categoryInfo.categoryObjects, defaultDataPointColor, chartType, categoryMetadata), columnSeries = result.series, valuesMetadata = [], j = 0, jlen = legend.length; j < jlen; j++) valuesMetadata.push(seriesSources[j]);
                        var labels = converterHelper.createAxesLabels(xAxisCardProperties, valueAxisProperties, categoryMetadata, valuesMetadata);
                        return {
                            categories: categories,
                            categoriesWidth: result.categoriesWidth,
                            categoryFormatter: categoryFormatter,
                            series: columnSeries,
                            valuesMetadata: valuesMetadata,
                            legendData: legendAndSeriesInfo.legend,
                            hasHighlights: result.hasHighlights,
                            categoryMetadata: categoryMetadata,
                            scalarCategoryAxis: isScalar,
                            borderSettings: borderSettings,
                            labelSettings: labelSettings,
                            axesLabels: {
                                x: labels.xAxisLabel,
                                y: labels.yAxisLabel
                            },
                            hasDynamicSeries: result.hasDynamicSeries,
                            defaultDataPointColor: defaultDataPointColor,
                            showAllDataPoints: showAllDataPoints,
                            isMultiMeasure: !1
                        };
                    }, MekkoColumnChart.getStackedMultiplier = function(rawValues, rowIdx, seriesCount, categoryCount) {
                        for (var pos = 0, neg = 0, i = 0; i < seriesCount; i++) {
                            var value = rawValues[i][rowIdx];
                            value = AxisHelper.normalizeNonFiniteNumber(value), value > 0 ? pos += value : value < 0 && (neg -= value);
                        }
                        var absTotal = pos + neg;
                        return {
                            pos: pos ? pos / absTotal / pos : 1,
                            neg: neg ? neg / absTotal / neg : 1
                        };
                    }, MekkoColumnChart.createDataPoints = function(dataViewCat, categories, categoryIdentities, legend, seriesObjectsList, converterStrategy, defaultLabelSettings, is100PercentStacked, isScalar, supportsOverflow, isCategoryAlsoSeries, categoryObjectsList, defaultDataPointColor, chartType, categoryMetadata) {
                        void 0 === is100PercentStacked && (is100PercentStacked = !1), void 0 === isScalar && (isScalar = !1), 
                        void 0 === supportsOverflow && (supportsOverflow = !1);
                        var grouped = dataViewCat && dataViewCat.values ? dataViewCat.values.grouped() : void 0, categoryCount = categories.length, seriesCount = legend.length, columnSeries = [];
                        if (seriesCount < 1 || categoryCount < 1 || null === categories[0]) return {
                            series: columnSeries,
                            hasHighlights: !1,
                            hasDynamicSeries: !1,
                            categoriesWidth: []
                        };
                        var dvCategories = dataViewCat.categories;
                        categoryMetadata = dvCategories && dvCategories.length > 0 ? dvCategories[0].source : null;
                        var categoryType = AxisHelper.getCategoryValueType(categoryMetadata), isDateTime = AxisHelper.isDateTime(categoryType), baseValuesPos = [], baseValuesNeg = [], rawValues = [], rawHighlightValues = [], hasDynamicSeries = !(!dataViewCat.values || !dataViewCat.values.source), widthColumns = [], widthIndex = -1, seriesIndex = 0, highlightsOverflow = !1, hasHighlights = converterStrategy.hasHighlightValues(0);
                        for (seriesIndex = 0; seriesIndex < dataViewCat.values.length; seriesIndex++) if (dataViewCat.values[seriesIndex].source.roles && dataViewCat.values[seriesIndex].source.roles[RoleNames.width] && !dataViewCat.values[seriesIndex].source.roles[RoleNames.y]) {
                            widthIndex = seriesIndex;
                            for (var widthValues = dataViewCat.values[seriesIndex].values, i = 0, valuesLen = widthValues.length; i < valuesLen; i++) widthColumns[i] = d3.sum([ 0, widthColumns[i], widthValues[i] ]);
                        } else {
                            for (var seriesValues = [], seriesHighlightValues = [], categoryIndex = 0; categoryIndex < categoryCount; categoryIndex++) {
                                var value = converterStrategy.getValueBySeriesAndCategory(seriesIndex, categoryIndex);
                                if (seriesValues[categoryIndex] = value, hasHighlights) {
                                    var highlightValue = converterStrategy.getHighlightBySeriesAndCategory(seriesIndex, categoryIndex);
                                    seriesHighlightValues[categoryIndex] = highlightValue, value >= 0 && highlightValue >= 0 && value >= highlightValue || value <= 0 && highlightValue <= 0 && value <= highlightValue || (highlightsOverflow = !0);
                                }
                            }
                            rawValues.push(seriesValues), hasHighlights && rawHighlightValues.push(seriesHighlightValues);
                        }
                        if (highlightsOverflow && !supportsOverflow && (highlightsOverflow = !1, hasHighlights = !1, 
                        rawValues = rawHighlightValues), widthColumns.length < 1) for (seriesIndex = 0; seriesIndex < dataViewCat.values.length; seriesIndex++) if (dataViewCat.values[seriesIndex].source.roles && dataViewCat.values[seriesIndex].source.roles[RoleNames.width]) {
                            widthIndex = seriesIndex;
                            for (var widthValues = dataViewCat.values[seriesIndex].values, i = 0, valuesLen = widthValues.length; i < valuesLen; i++) widthColumns[i] = d3.sum([ 0, widthColumns[i], widthValues[i] ]);
                        } else ;
                        if (widthColumns.length < 1) for (seriesIndex = 0; seriesIndex < categoryCount; seriesIndex++) widthColumns.push(1);
                        var totalSum = d3.sum(widthColumns), linearScale = d3.scale.linear().domain([ 0, totalSum ]).range([ 0, 1 ]), columnStartX = [ 0 ], columnWidth = [];
                        for (seriesIndex = 0; seriesIndex < categoryCount - 1; seriesIndex++) {
                            var stepWidth = columnStartX[columnStartX.length - 1] + (widthColumns[seriesIndex] || 0);
                            columnStartX.push(stepWidth);
                        }
                        for (seriesIndex = 0; seriesIndex < categoryCount; seriesIndex++) columnStartX[seriesIndex] = linearScale(columnStartX[seriesIndex]), 
                        columnWidth[seriesIndex] = linearScale(widthColumns[seriesIndex]);
                        var dataPointObjects = categoryObjectsList, formatStringProp = MekkoChart.Properties.general.formatString;
                        for (seriesIndex = 0; seriesIndex < seriesCount; seriesIndex++) {
                            var seriesLabelSettings, seriesDataPoints = [], legendItem = legend[seriesIndex];
                            if (!hasDynamicSeries) {
                                var labelsSeriesGroup = grouped && grouped.length > 0 && grouped[0].values ? grouped[0].values[seriesIndex] : null, labelObjects = labelsSeriesGroup && labelsSeriesGroup.source && labelsSeriesGroup.source.objects ? labelsSeriesGroup.source.objects.labels : null;
                                labelObjects && (seriesLabelSettings = Prototype.inherit(defaultLabelSettings), 
                                dataLabelUtils.updateLabelSettingsFromLabelsObject(labelObjects, seriesLabelSettings));
                            }
                            var series = {
                                displayName: legendItem.label,
                                key: "series" + seriesIndex,
                                index: seriesIndex,
                                data: seriesDataPoints,
                                identity: legendItem.identity,
                                color: legendItem.color,
                                labelSettings: seriesLabelSettings
                            };
                            seriesCount > 1 && (dataPointObjects = seriesObjectsList[seriesIndex]);
                            for (var metadata = dataViewCat.values[seriesIndex].source, categoryIndex = 0; categoryIndex < categoryCount; categoryIndex++) {
                                0 === seriesIndex && (baseValuesPos.push(0), baseValuesNeg.push(0));
                                var value = AxisHelper.normalizeNonFiniteNumber(rawValues[seriesIndex][categoryIndex]);
                                if (!(null == value && seriesIndex > 0)) {
                                    var originalValue = value, categoryValue = categories[categoryIndex];
                                    if (isDateTime && categoryValue && (categoryValue = categoryValue.getTime()), !isScalar || null != categoryValue && !isNaN(categoryValue)) {
                                        var multipliers;
                                        is100PercentStacked && (multipliers = MekkoColumnChart.getStackedMultiplier(rawValues, categoryIndex, seriesCount, categoryCount));
                                        var unadjustedValue = value, isNegative = value < 0;
                                        multipliers && (value *= isNegative ? multipliers.neg : multipliers.pos);
                                        var position, valueAbsolute = Math.abs(value);
                                        isNegative ? (position = baseValuesNeg[categoryIndex], isNaN(valueAbsolute) || (baseValuesNeg[categoryIndex] -= valueAbsolute)) : (isNaN(valueAbsolute) || (baseValuesPos[categoryIndex] += valueAbsolute), 
                                        position = baseValuesPos[categoryIndex]);
                                        var columnGroup = grouped && grouped.length > seriesIndex && grouped[seriesIndex].values ? grouped[seriesIndex] : null, category = dataViewCat.categories && dataViewCat.categories.length > 0 ? dataViewCat.categories[0] : null, identity = SelectionIdBuilder.builder().withCategory(category, categoryIndex).withSeries(dataViewCat.values, columnGroup).withMeasure(converterStrategy.getMeasureNameByIndex(seriesIndex)).createSelectionId(), rawCategoryValue = categories[categoryIndex], color = MekkoColumnChart.getDataPointColor(legendItem, categoryIndex, dataPointObjects), seriesData = [];
                                        if (columnGroup) {
                                            var seriesValueColumn = {
                                                values: [],
                                                source: dataViewCat.values.source
                                            };
                                            seriesData.push({
                                                value: columnGroup.name,
                                                metadata: seriesValueColumn
                                            });
                                            for (var columnIndex = 0; columnIndex < columnGroup.values.length; columnIndex++) {
                                                var columnValues = columnGroup.values[columnIndex];
                                                seriesData.push({
                                                    value: columnValues.values[categoryIndex],
                                                    metadata: columnValues
                                                });
                                            }
                                        }
                                        var tooltipInfo = TooltipBuilder.createTooltipInfo(formatStringProp, null, rawCategoryValue, originalValue, [ category ], seriesData, null, categoryIndex), dataPointLabelSettings = series && series.labelSettings ? series.labelSettings : defaultLabelSettings, labelColor = dataPointLabelSettings.labelColor, lastValue = void 0;
                                        EnumExtensions.hasFlag(chartType, flagStacked) && (lastValue = this.getStackedLabelColor(isNegative, seriesIndex, seriesCount, categoryIndex, rawValues), 
                                        labelColor = lastValue || seriesIndex === seriesCount - 1 && !isNegative ? labelColor : dataLabelUtils.defaultInsideLabelColor), 
                                        value = columnWidth[categoryIndex];
                                        var originalPosition = columnStartX[categoryIndex], dataPoint = {
                                            categoryValue: categoryValue,
                                            value: value,
                                            position: position,
                                            valueAbsolute: valueAbsolute,
                                            valueOriginal: unadjustedValue,
                                            seriesIndex: seriesIndex,
                                            labelSettings: dataPointLabelSettings,
                                            categoryIndex: categoryIndex,
                                            color: color,
                                            selected: !1,
                                            originalValue: value,
                                            originalPosition: originalPosition,
                                            originalValueAbsolute: valueAbsolute,
                                            identity: identity,
                                            key: identity.getKey(),
                                            tooltipInfo: tooltipInfo,
                                            labelFill: labelColor,
                                            labelFormatString: metadata.format,
                                            lastSeries: lastValue,
                                            chartType: chartType
                                        };
                                        if (seriesDataPoints.push(dataPoint), hasHighlights) {
                                            var valueHighlight = rawHighlightValues[seriesIndex][categoryIndex], unadjustedValueHighlight = valueHighlight, highlightedTooltip = !0;
                                            null === valueHighlight && (valueHighlight = 0, highlightedTooltip = !1), is100PercentStacked && (valueHighlight *= multipliers.pos);
                                            var absoluteValueHighlight = Math.abs(valueHighlight), highlightPosition = position;
                                            valueHighlight > 0 ? highlightPosition -= valueAbsolute - absoluteValueHighlight : 0 === valueHighlight && value > 0 && (highlightPosition -= valueAbsolute);
                                            var highlightIdentity = SelectionId.createWithHighlight(identity), rawCategoryValue = categories[categoryIndex];
                                            highlightedTooltip && (dataPoint.tooltipInfo = tooltipInfo);
                                            var highlightDataPoint = {
                                                categoryValue: categoryValue,
                                                value: value,
                                                position: highlightPosition,
                                                valueAbsolute: absoluteValueHighlight,
                                                valueOriginal: unadjustedValueHighlight,
                                                seriesIndex: seriesIndex,
                                                labelSettings: dataPointLabelSettings,
                                                categoryIndex: categoryIndex,
                                                color: color,
                                                selected: !1,
                                                highlight: !0,
                                                originalValue: value,
                                                originalPosition: originalPosition,
                                                originalValueAbsolute: valueAbsolute,
                                                drawThinner: highlightsOverflow,
                                                identity: highlightIdentity,
                                                key: highlightIdentity.getKey(),
                                                tooltipInfo: tooltipInfo,
                                                labelFormatString: metadata.format,
                                                labelFill: labelColor,
                                                lastSeries: lastValue,
                                                chartType: chartType
                                            };
                                            seriesDataPoints.push(highlightDataPoint);
                                        }
                                    }
                                }
                            }
                            columnSeries.push(series);
                        }
                        return {
                            series: columnSeries,
                            categoriesWidth: columnWidth,
                            hasHighlights: hasHighlights,
                            hasDynamicSeries: hasDynamicSeries
                        };
                    }, MekkoColumnChart.getDataPointColor = function(legendItem, categoryIndex, dataPointObjects) {
                        if (dataPointObjects) {
                            var colorOverride = DataViewObjects.getFillColor(dataPointObjects[categoryIndex], MekkoChart.Properties.dataPoint.fill);
                            if (colorOverride) return colorOverride;
                        }
                        return legendItem.color;
                    }, MekkoColumnChart.getStackedLabelColor = function(isNegative, seriesIndex, seriesCount, categoryIndex, rawValues) {
                        for (var lastValue = !(isNegative && seriesIndex === seriesCount - 1 && 1 !== seriesCount), i = seriesIndex + 1; i < seriesCount; i++) {
                            var nextValues = AxisHelper.normalizeNonFiniteNumber(rawValues[i][categoryIndex]);
                            if (null !== nextValues && ((!isNegative || isNegative && 0 === seriesIndex) && nextValues > 0 || isNegative && 0 !== seriesIndex)) {
                                lastValue = !1;
                                break;
                            }
                        }
                        return lastValue;
                    }, MekkoColumnChart.sliceSeries = function(series, endIndex, startIndex) {
                        void 0 === startIndex && (startIndex = 0);
                        var newSeries = [];
                        if (series && series.length > 0) for (var i = 0, len = series.length; i < len; i++) {
                            var iNewSeries = newSeries[i] = Prototype.inherit(series[i]);
                            iNewSeries.data = series[i].data.filter(function(d) {
                                return d.categoryIndex >= startIndex && d.categoryIndex < endIndex;
                            });
                        }
                        return newSeries;
                    }, MekkoColumnChart.getInteractiveColumnChartDomElement = function(element) {
                        return element.children("svg").get(0);
                    }, MekkoColumnChart.prototype.getColumnsWidth = function() {
                        var data = this.data;
                        return data && data.series && data.series[0] && data.series[0].data ? data.categoriesWidth : [];
                    }, MekkoColumnChart.prototype.getBorderWidth = function() {
                        return MekkoColumnChart.getBorderWidth(this.data.borderSettings);
                    }, MekkoColumnChart.prototype.setData = function(dataViews) {
                        var is100PctStacked = !0;
                        if (this.data = {
                            categories: [],
                            categoriesWidth: [],
                            categoryFormatter: null,
                            series: [],
                            valuesMetadata: [],
                            legendData: null,
                            hasHighlights: !1,
                            categoryMetadata: null,
                            scalarCategoryAxis: !1,
                            borderSettings: null,
                            labelSettings: dataLabelUtils.getDefaultColumnLabelSettings(is100PctStacked),
                            axesLabels: {
                                x: null,
                                y: null
                            },
                            hasDynamicSeries: !1,
                            defaultDataPointColor: null,
                            isMultiMeasure: !1
                        }, dataViews.length > 0) {
                            var dataView = dataViews[0];
                            if (dataView && dataView.categorical) {
                                var dataViewCat = this.dataViewCat = dataView.categorical;
                                this.data = MekkoColumnChart.converter(dataViewCat, this.cartesianVisualHost.getSharedColors(), !0, !1, this.supportsOverflow, dataView.metadata, this.chartType);
                                for (var series = this.data.series, i = 0, ilen = series.length; i < ilen; i++) {
                                    var currentSeries = series[i];
                                    this.interactivityService && this.interactivityService.applySelectionStateToData(currentSeries.data);
                                }
                            }
                        }
                    }, MekkoColumnChart.prototype.calculateLegend = function() {
                        if (this.interactivity && this.interactivity.isInteractiveLegend) return this.createInteractiveMekkoLegendDataPoints(0);
                        var legendData = this.data ? this.data.legendData : null, MekkoLegendDataPoints = legendData ? legendData.dataPoints : [];
                        return ArrayExtensions.isUndefinedOrEmpty(MekkoLegendDataPoints) ? null : legendData;
                    }, MekkoColumnChart.prototype.hasLegend = function() {
                        return this.data && (this.data.hasDynamicSeries || this.data.series && this.data.series.length > 1);
                    }, MekkoColumnChart.prototype.enumerateObjectInstances = function(enumeration, options) {
                        switch (options.objectName) {
                          case "dataPoint":
                            GradientUtils.hasGradientRole(this.dataViewCat) || this.enumerateDataPoints(enumeration);
                            break;

                          case "labels":
                            this.enumerateDataLabels(enumeration);
                        }
                    }, MekkoColumnChart.prototype.enumerateDataLabels = function(enumeration) {
                        var data = this.data, labelSettings = this.data.labelSettings, seriesCount = data.series.length;
                        if (dataLabelUtils.enumerateDataLabels(this.getLabelSettingsOptions(enumeration, labelSettings, !1)), 
                        0 !== seriesCount && !data.hasDynamicSeries && (seriesCount > 1 || !data.categoryMetadata)) for (var i = 0; i < seriesCount; i++) {
                            var series = data.series[i], labelSettings = series.labelSettings ? series.labelSettings : this.data.labelSettings;
                            dataLabelUtils.enumerateDataLabels(this.getLabelSettingsOptions(enumeration, labelSettings, !0, series));
                        }
                    }, MekkoColumnChart.prototype.getLabelSettingsOptions = function(enumeration, labelSettings, isSeries, series) {
                        var is100PctStacked = !0;
                        return {
                            enumeration: enumeration,
                            dataLabelsSettings: labelSettings,
                            show: !isSeries,
                            displayUnits: is100PctStacked,
                            precision: !0,
                            selector: series && series.identity ? series.identity.getSelector() : null
                        };
                    }, MekkoColumnChart.prototype.enumerateDataPoints = function(enumeration) {
                        var data = this.data;
                        if (data && data.series) {
                            var seriesCount = data.series.length;
                            if (0 !== seriesCount) if (data.hasDynamicSeries || seriesCount > 1 || !data.categoryMetadata) for (var i = 0; i < seriesCount; i++) {
                                var series = data.series[i];
                                enumeration.pushInstance({
                                    objectName: "dataPoint",
                                    displayName: series.displayName,
                                    selector: ColorHelper.normalizeSelector(series.identity.getSelector()),
                                    properties: {
                                        fill: {
                                            solid: {
                                                color: series.color
                                            }
                                        }
                                    }
                                });
                            } else {
                                var singleSeriesData = data.series[0].data, categoryFormatter = data.categoryFormatter;
                                enumeration.pushInstance({
                                    objectName: "dataPoint",
                                    selector: null,
                                    properties: {
                                        defaultColor: {
                                            solid: {
                                                color: data.defaultDataPointColor || this.colors.getColorByIndex(0).value
                                            }
                                        }
                                    }
                                }).pushInstance({
                                    objectName: "dataPoint",
                                    selector: null,
                                    properties: {
                                        showAllDataPoints: !!data.showAllDataPoints
                                    }
                                });
                                for (var i = 0; i < singleSeriesData.length && data.showAllDataPoints; i++) {
                                    var singleSeriesDataPoints = singleSeriesData[i], categoryValue = data.categories[i];
                                    enumeration.pushInstance({
                                        objectName: "dataPoint",
                                        displayName: categoryFormatter ? categoryFormatter.format(categoryValue) : categoryValue,
                                        selector: ColorHelper.normalizeSelector(singleSeriesDataPoints.identity.getSelector(), !0),
                                        properties: {
                                            fill: {
                                                solid: {
                                                    color: singleSeriesDataPoints.color
                                                }
                                            }
                                        }
                                    });
                                }
                            }
                        }
                    }, MekkoColumnChart.prototype.calculateAxesProperties = function(options) {
                        var data = this.data;
                        this.currentViewport = options.viewport;
                        var margin = this.margin = options.margin, origCatgSize = data && data.categories ? data.categories.length : 0, chartLayout = data ? this.getCategoryLayout(origCatgSize, options) : {
                            categoryCount: 0,
                            categoryThickness: MekkoChart.MinOrdinalRectThickness,
                            outerPaddingRatio: MekkoChart.OuterPaddingRatio,
                            isScalar: !1
                        };
                        this.categoryAxisType = chartLayout.isScalar ? axisType.scalar : null, this.columnChart.setData(data);
                        var preferredPlotArea = this.getPreferredPlotArea(chartLayout.isScalar, chartLayout.categoryCount, chartLayout.categoryThickness);
                        preferredPlotArea.width === this.currentViewport.width && (preferredPlotArea.width -= margin.left + margin.right), 
                        preferredPlotArea.height -= margin.top + margin.bottom;
                        var is100Pct = !0, chartContext = {
                            height: preferredPlotArea.height,
                            width: preferredPlotArea.width,
                            duration: 0,
                            hostService: this.hostService,
                            unclippedGraphicsContext: this.unclippedGraphicsContext,
                            mainGraphicsContext: this.mainGraphicsContext,
                            labelGraphicsContext: this.labelGraphicsContext,
                            margin: this.margin,
                            layout: chartLayout,
                            animator: this.animator,
                            interactivityService: this.interactivityService,
                            viewportHeight: this.currentViewport.height - (margin.top + margin.bottom),
                            viewportWidth: this.currentViewport.width - (margin.left + margin.right),
                            is100Pct: is100Pct,
                            isComboChart: !0
                        };
                        this.ApplyInteractivity(chartContext), this.columnChart.setupVisualProps(chartContext);
                        var isBarChart = EnumExtensions.hasFlag(this.chartType, flagBar);
                        if (isBarChart) {
                            var temp = options.forcedXDomain;
                            options.forcedXDomain = options.forcedYDomain, options.forcedYDomain = temp;
                        }
                        return this.xAxisProperties = this.columnChart.setXScale(is100Pct, options.forcedTickCount, options.forcedXDomain, isBarChart ? options.valueAxisScaleType : options.categoryAxisScaleType), 
                        this.yAxisProperties = this.columnChart.setYScale(is100Pct, options.forcedTickCount, options.forcedYDomain, isBarChart ? options.categoryAxisScaleType : options.valueAxisScaleType), 
                        options.showCategoryAxisLabel && this.xAxisProperties.isCategoryAxis || options.showValueAxisLabel && !this.xAxisProperties.isCategoryAxis ? this.xAxisProperties.axisLabel = data.axesLabels.x : this.xAxisProperties.axisLabel = null, 
                        options.showValueAxisLabel && !this.yAxisProperties.isCategoryAxis || options.showCategoryAxisLabel && this.yAxisProperties.isCategoryAxis ? this.yAxisProperties.axisLabel = data.axesLabels.y : this.yAxisProperties.axisLabel = null, 
                        [ this.xAxisProperties, this.yAxisProperties ];
                    }, MekkoColumnChart.prototype.getPreferredPlotArea = function(isScalar, categoryCount, categoryThickness) {
                        var viewport = {
                            height: this.currentViewport.height,
                            width: this.currentViewport.width
                        };
                        if (this.isScrollable && !isScalar) {
                            var preferredWidth = MekkoChart.getPreferredCategorySpan(categoryCount, categoryThickness);
                            EnumExtensions.hasFlag(this.chartType, flagBar) ? viewport.height = Math.max(preferredWidth, viewport.height) : viewport.width = Math.max(preferredWidth, viewport.width);
                        }
                        return viewport;
                    }, MekkoColumnChart.prototype.ApplyInteractivity = function(chartContext) {
                        var _this = this, interactivity = this.interactivity;
                        if (interactivity && (interactivity.dragDataPoint && (chartContext.onDragStart = function(datum) {
                            datum.identity && _this.hostService.onDragStart({
                                event: d3.event,
                                data: {
                                    data: datum.identity.getSelector()
                                }
                            });
                        }), interactivity.isInteractiveLegend)) {
                            var dragMove = function() {
                                var mousePoint = d3.mouse(_this.mainGraphicsContext[0][0]), x = mousePoint[0], y = mousePoint[1], index = _this.columnChart.getClosestColumnIndex(x, y);
                                _this.selectColumn(index);
                            }, ColumnChartSvg = MekkoColumnChart.getInteractiveColumnChartDomElement(this.element);
                            this.svg.on("click", dragMove), d3.select(ColumnChartSvg).on("click", dragMove);
                            var drag = d3.behavior.drag().origin(Object).on("drag", dragMove);
                            this.svg.call(drag), d3.select(ColumnChartSvg).call(drag);
                        }
                    }, MekkoColumnChart.prototype.selectColumn = function(indexOfColumnSelected, force) {
                        if (void 0 === force && (force = !1), force || this.lastInteractiveSelectedColumnIndex !== indexOfColumnSelected) {
                            var legendData = this.createInteractiveMekkoLegendDataPoints(indexOfColumnSelected), MekkoLegendDataPoints = legendData.dataPoints;
                            this.cartesianVisualHost.updateLegend(legendData), MekkoLegendDataPoints.length > 0 && this.columnChart.selectColumn(indexOfColumnSelected, this.lastInteractiveSelectedColumnIndex), 
                            this.lastInteractiveSelectedColumnIndex = indexOfColumnSelected;
                        }
                    }, MekkoColumnChart.prototype.createInteractiveMekkoLegendDataPoints = function(columnIndex) {
                        var data = this.data;
                        if (!data || ArrayExtensions.isUndefinedOrEmpty(data.series)) return {
                            dataPoints: []
                        };
                        for (var formatStringProp = MekkoChart.Properties.general.formatString, MekkoLegendDataPoints = [], category = data.categories && data.categories[columnIndex], allSeries = data.series, dataPoints = data.legendData && data.legendData.dataPoints, converterStrategy = new MekkoChartConverterHelper(this.dataViewCat), i = 0, len = allSeries.length; i < len; i++) {
                            var dataPointColor, measure = converterStrategy.getValueBySeriesAndCategory(i, columnIndex), valueMetadata = data.valuesMetadata[i], formattedLabel = converterHelper.getFormattedLegendLabel(valueMetadata, this.dataViewCat.values, formatStringProp);
                            if (1 === allSeries.length) {
                                var series = allSeries[0];
                                dataPointColor = series.data.length > columnIndex && series.data[columnIndex].color;
                            } else dataPointColor = dataPoints.length > i && dataPoints[i].color;
                            MekkoLegendDataPoints.push({
                                color: dataPointColor,
                                icon: LegendIcon.Box,
                                label: formattedLabel,
                                category: data.categoryFormatter ? data.categoryFormatter.format(category) : category,
                                measure: valueFormatter.format(measure, valueFormatter.getFormatString(valueMetadata, formatStringProp)),
                                identity: SelectionId.createNull(),
                                selected: !1
                            });
                        }
                        return {
                            dataPoints: MekkoLegendDataPoints
                        };
                    }, MekkoColumnChart.prototype.overrideXScale = function(xProperties) {
                        this.xAxisProperties = xProperties;
                    }, MekkoColumnChart.prototype.render = function(suppressAnimations) {
                        var MekkoColumnChartDrawInfo = this.columnChart.drawColumns(!suppressAnimations), data = this.data, margin = this.margin, viewport = this.currentViewport, height = viewport.height - (margin.top + margin.bottom), width = viewport.width - (margin.left + margin.right);
                        this.mainGraphicsContext.attr("height", height).attr("width", width), TooltipManager.addTooltip(MekkoColumnChartDrawInfo.shapesSelection, function(tooltipEvent) {
                            return tooltipEvent.data.tooltipInfo;
                        });
                        var allDataPoints = [], behaviorOptions = void 0;
                        if (this.interactivityService) {
                            for (var i = 0, ilen = data.series.length; i < ilen; i++) allDataPoints = allDataPoints.concat(data.series[i].data);
                            behaviorOptions = {
                                datapoints: allDataPoints,
                                bars: MekkoColumnChartDrawInfo.shapesSelection,
                                hasHighlights: data.hasHighlights,
                                eventGroup: this.mainGraphicsContext,
                                mainGraphicsContext: this.mainGraphicsContext,
                                viewport: MekkoColumnChartDrawInfo.viewport,
                                axisOptions: MekkoColumnChartDrawInfo.axisOptions,
                                showLabel: data.labelSettings.show
                            };
                        }
                        return this.interactivity && this.interactivity.isInteractiveLegend && this.data.series.length > 0 && this.selectColumn(0, !0), 
                        SVGUtil.flushAllD3TransitionsIfNeeded(this.options), {
                            dataPoints: allDataPoints,
                            behaviorOptions: behaviorOptions,
                            labelDataPoints: MekkoColumnChartDrawInfo.labelDataPoints,
                            labelsAreNumeric: !0
                        };
                    }, MekkoColumnChart.prototype.onClearSelection = function() {
                        this.interactivityService && this.interactivityService.clearSelection();
                    }, MekkoColumnChart.prototype.getVisualCategoryAxisIsScalar = function() {
                        return !!this.data && this.data.scalarCategoryAxis;
                    }, MekkoColumnChart.prototype.getSupportedCategoryAxisType = function() {
                        var metaDataColumn = this.data ? this.data.categoryMetadata : void 0, valueType = AxisHelper.getCategoryValueType(metaDataColumn), isOrdinal = AxisHelper.isOrdinal(valueType);
                        return isOrdinal ? axisType.categorical : axisType.both;
                    }, MekkoColumnChart.prototype.setFilteredData = function(startIndex, endIndex) {
                        var data = Prototype.inherit(this.data);
                        return data.series = MekkoColumnChart.sliceSeries(data.series, endIndex, startIndex), 
                        data.categories = data.categories.slice(startIndex, endIndex), this.columnChart.setData(data), 
                        data;
                    }, MekkoColumnChart.ColumnChartClassName = "columnChart", MekkoColumnChart.SeriesClasses = createClassAndSelector("series"), 
                    MekkoColumnChart.BorderClass = createClassAndSelector("mekkoborder"), MekkoColumnChart;
                }();
                samples.MekkoColumnChart = MekkoColumnChart;
                var MekkoChartConverterHelper = function() {
                    function MekkoChartConverterHelper(dataView) {
                        this.dataView = dataView;
                    }
                    return MekkoChartConverterHelper.hasRole = function(column, name) {
                        var roles = column.roles;
                        return roles && roles[name];
                    }, MekkoChartConverterHelper.prototype.getLegend = function(colors, defaultColor) {
                        var legend = [], seriesSources = [], seriesObjects = [], grouped = !1, colorHelper = new ColorHelper(colors, MekkoChart.Properties.dataPoint.fill, defaultColor), legendTitle = void 0;
                        if (this.dataView && this.dataView.values) {
                            for (var allValues = this.dataView.values, valueGroups = allValues.grouped(), hasDynamicSeries = !(!allValues || !allValues.source), formatStringProp = MekkoChart.Properties.general.formatString, valueGroupsIndex = 0, valueGroupsLen = valueGroups.length; valueGroupsIndex < valueGroupsLen; valueGroupsIndex++) for (var valueGroup = valueGroups[valueGroupsIndex], valueGroupObjects = valueGroup.objects, values = valueGroup.values, valueIndex = 0, valuesLen = values.length; valueIndex < valuesLen; valueIndex++) {
                                var series = values[valueIndex], source = series.source;
                                if (!MekkoChartConverterHelper.hasRole(source, "Width") || MekkoChartConverterHelper.hasRole(source, "Y")) {
                                    seriesSources.push(source), seriesObjects.push(series.objects);
                                    var selectionId = series.identity ? SelectionId.createWithIdAndMeasure(series.identity, source.queryName) : SelectionId.createWithMeasure(this.getMeasureNameByIndex(valueIndex)), label = converterHelper.getFormattedLegendLabel(source, allValues, formatStringProp), color = hasDynamicSeries ? colorHelper.getColorForSeriesValue(valueGroupObjects || source.objects, allValues.identityFields, source.groupName) : colorHelper.getColorForMeasure(valueGroupObjects || source.objects, source.queryName);
                                    legend.push({
                                        icon: LegendIcon.Box,
                                        color: color,
                                        label: label,
                                        identity: selectionId,
                                        selected: !1
                                    }), series.identity && void 0 !== source.groupName && (grouped = !0);
                                }
                            }
                            var dvValues = this.dataView.values;
                            legendTitle = dvValues && dvValues.source ? dvValues.source.displayName : "";
                        }
                        var legendData = {
                            title: legendTitle,
                            dataPoints: legend,
                            grouped: grouped
                        };
                        return {
                            legend: legendData,
                            seriesSources: seriesSources,
                            seriesObjects: seriesObjects
                        };
                    }, MekkoChartConverterHelper.prototype.getValueBySeriesAndCategory = function(series, category) {
                        return this.dataView.values[series].values[category];
                    }, MekkoChartConverterHelper.prototype.getMeasureNameByIndex = function(index) {
                        return this.dataView.values[index].source.queryName;
                    }, MekkoChartConverterHelper.prototype.hasHighlightValues = function(series) {
                        var column = this.dataView && this.dataView.values ? this.dataView.values[series] : void 0;
                        return column && !!column.highlights;
                    }, MekkoChartConverterHelper.prototype.getHighlightBySeriesAndCategory = function(series, category) {
                        return this.dataView.values[series].highlights[category];
                    }, MekkoChartConverterHelper;
                }(), CustomVisualBehavior = function() {
                    function CustomVisualBehavior(behaviors) {
                        this.behaviors = behaviors || [];
                    }
                    return CustomVisualBehavior.prototype.bindEvents = function(options, selectionHandler) {
                        for (var behaviors = this.behaviors, i = 0, ilen = behaviors.length; i < ilen; i++) behaviors[i].bindEvents(options.layerOptions[i], selectionHandler);
                        options.clearCatcher.on("click", function() {
                            selectionHandler.handleClearSelection();
                        });
                    }, CustomVisualBehavior.prototype.renderSelection = function(hasSelection) {
                        for (var behaviorName in this.behaviors) this.behaviors[behaviorName].renderSelection(hasSelection);
                    }, CustomVisualBehavior;
                }(), MekkoChartWebBehavior = function() {
                    function MekkoChartWebBehavior() {}
                    return MekkoChartWebBehavior.prototype.bindEvents = function(options, selectionHandler) {
                        this.options = options;
                        var eventGroup = options.eventGroup;
                        eventGroup.on("click", function() {
                            var d = MekkoChartWebBehavior.getDatumForLastInputEvent();
                            selectionHandler.handleSelection(d, d3.event.ctrlKey);
                        }), eventGroup.on("contextmenu", function() {
                            if (!d3.event.ctrlKey) {
                                d3.event.preventDefault();
                                var d = MekkoChartWebBehavior.getDatumForLastInputEvent(), position = InteractivityUtils.getPositionOfLastInputEvent();
                                selectionHandler.handleContextMenu(d, position);
                            }
                        });
                    }, MekkoChartWebBehavior.prototype.renderSelection = function(hasSelection) {
                        var options = this.options;
                        options.bars.style("fill-opacity", function(d) {
                            return MekkoChartUtils.getFillOpacity(d.selected, d.highlight, !d.highlight && hasSelection, !d.selected && options.hasHighlights);
                        });
                    }, MekkoChartWebBehavior.getDatumForLastInputEvent = function() {
                        var target = d3.event.target;
                        return d3.select(target).datum();
                    }, MekkoChartWebBehavior;
                }();
                samples.MekkoChartWebBehavior = MekkoChartWebBehavior;
                var MekkoChartUtils;
                !function(MekkoChartUtils) {
                    function getSize(scale, size, zeroVal) {
                        return void 0 === zeroVal && (zeroVal = 0), AxisHelper.diffScaled(scale, zeroVal, size);
                    }
                    function calcValueDomain(data, is100pct) {
                        var defaultNumberRange = {
                            min: 0,
                            max: 10
                        };
                        if (0 === data.length) return defaultNumberRange;
                        var min = d3.min(data, function(d) {
                            return d3.min(d.data, function(e) {
                                return e.position - e.valueAbsolute;
                            });
                        }), max = d3.max(data, function(d) {
                            return d3.max(d.data, function(e) {
                                return e.position;
                            });
                        });
                        return is100pct && (min = Double.roundToPrecision(min, PctRoundingError), max = Double.roundToPrecision(max, PctRoundingError)), 
                        {
                            min: min,
                            max: max
                        };
                    }
                    function drawSeries(data, graphicsContext, axisOptions) {
                        var colGroupSelection = graphicsContext.selectAll(MekkoChart.Classes.series.selector), series = colGroupSelection.data(data.series, function(d) {
                            return d.key;
                        });
                        return series.enter().append("g").classed(MekkoChart.Classes.series.class, !0), 
                        series.style({
                            fill: function(d) {
                                return d.color;
                            }
                        }), series.exit().remove(), series;
                    }
                    function applyInteractivity(columns, onDragStart) {
                        onDragStart && columns.attr("draggable", "true").on("dragstart", onDragStart);
                    }
                    function getFillOpacity(selected, highlight, hasSelection, hasPartialHighlights) {
                        return hasPartialHighlights && !highlight || hasSelection && !selected ? MekkoChartUtils.DimmedOpacity : MekkoChartUtils.DefaultOpacity;
                    }
                    function setChosenColumnOpacity(mainGraphicsContext, columnGroupSelector, selectedColumnIndex, lastColumnIndex) {
                        var series = mainGraphicsContext.selectAll(MekkoChart.Classes.series.selector), lastColumnUndefined = "undefined" == typeof lastColumnIndex;
                        series.selectAll(rectName + columnGroupSelector).filter(function(d) {
                            return d.categoryIndex !== selectedColumnIndex && (lastColumnUndefined || d.categoryIndex === lastColumnIndex);
                        }).transition().style("fill-opacity", MekkoChartUtils.DimmedOpacity), series.selectAll(rectName + columnGroupSelector).filter(function(d) {
                            return d.categoryIndex === selectedColumnIndex;
                        }).style("fill-opacity", MekkoChartUtils.DefaultOpacity);
                    }
                    function getClosestColumnIndex(coordinate, columnsCenters) {
                        for (var currentIndex = 0, distance = Number.MAX_VALUE, i = 0, ilen = columnsCenters.length; i < ilen; i++) {
                            var currentDistance = Math.abs(coordinate - columnsCenters[i]);
                            currentDistance < distance && (distance = currentDistance, currentIndex = i);
                        }
                        return currentIndex;
                    }
                    function applyUserMinMax(isScalar, dataView, xAxisCardProperties) {
                        if (isScalar) {
                            var min = xAxisCardProperties.start, max = xAxisCardProperties.end;
                            return MekkoChartUtils.transformDomain(dataView, min, max);
                        }
                        return dataView;
                    }
                    function transformDomain(dataView, min, max) {
                        if (!dataView.categories || !dataView.values || 0 === dataView.categories.length || 0 === dataView.values.length) return dataView;
                        if ("number" != typeof min && "number" != typeof max) return dataView;
                        var category = dataView.categories[0], categoryType = category ? category.source.type : null;
                        if (!AxisHelper.isOrdinal(categoryType)) {
                            var categoryValues = category.values, categoryObjects = category.objects;
                            if (!categoryValues || !categoryObjects) return dataView;
                            var newcategoryValues = [], newValues = [], newObjects = [];
                            if ("number" != typeof min && (min = categoryValues[0]), "number" != typeof max && (max = categoryValues[categoryValues.length - 1]), 
                            min > max) return dataView;
                            for (var j = 0, len = dataView.values.length; j < len; j++) newValues.push([]);
                            for (var t = 0, len = categoryValues.length; t < len; t++) if (categoryValues[t] >= min && categoryValues[t] <= max && (newcategoryValues.push(categoryValues[t]), 
                            categoryObjects && newObjects.push(categoryObjects[t]), dataView.values)) for (var k = 0; k < dataView.values.length; k++) newValues[k].push(dataView.values[k].values[t]);
                            var resultDataView = Prototype.inherit(dataView), resultDataViewValues = resultDataView.values = Prototype.inherit(resultDataView.values), resultDataViewCategories = resultDataView.categories = Prototype.inherit(dataView.categories), resultDataViewCategories0 = resultDataView.categories[0] = Prototype.inherit(resultDataViewCategories[0]);
                            resultDataViewCategories0.values = newcategoryValues, resultDataViewCategories0.objects && (resultDataViewCategories0.objects = newObjects);
                            for (var t = 0, len = dataView.values.length; t < len; t++) {
                                var measureArray = resultDataViewValues[t] = Prototype.inherit(resultDataViewValues[t]);
                                measureArray.values = newValues[t];
                            }
                            return resultDataView;
                        }
                    }
                    var PctRoundingError = 1e-4, rectName = "rect";
                    MekkoChartUtils.DimmedOpacity = .4, MekkoChartUtils.DefaultOpacity = 1, MekkoChartUtils.getSize = getSize, 
                    MekkoChartUtils.calcValueDomain = calcValueDomain, MekkoChartUtils.drawSeries = drawSeries, 
                    MekkoChartUtils.applyInteractivity = applyInteractivity, MekkoChartUtils.getFillOpacity = getFillOpacity, 
                    MekkoChartUtils.setChosenColumnOpacity = setChosenColumnOpacity, MekkoChartUtils.getClosestColumnIndex = getClosestColumnIndex, 
                    MekkoChartUtils.applyUserMinMax = applyUserMinMax, MekkoChartUtils.transformDomain = transformDomain;
                }(MekkoChartUtils = samples.MekkoChartUtils || (samples.MekkoChartUtils = {}));
                var MekkoChartSharedColorPalette = function() {
                    function MekkoChartSharedColorPalette(palette) {
                        this.palette = palette, this.clearPreferredScale();
                    }
                    return MekkoChartSharedColorPalette.prototype.getColorScaleByKey = function(scaleKey) {
                        return this.setPreferredScale(scaleKey), this.preferredScale;
                    }, MekkoChartSharedColorPalette.prototype.getNewColorScale = function() {
                        return this.preferredScale;
                    }, MekkoChartSharedColorPalette.prototype.getColorByIndex = function(index) {
                        return this.palette.getColorByIndex(index);
                    }, MekkoChartSharedColorPalette.prototype.getSentimentColors = function() {
                        return this.palette.getSentimentColors();
                    }, MekkoChartSharedColorPalette.prototype.getBasePickerColors = function() {
                        return this.palette.getBasePickerColors();
                    }, MekkoChartSharedColorPalette.prototype.clearPreferredScale = function() {
                        this.preferredScale = this.palette.getNewColorScale(), this.rotated = !1;
                    }, MekkoChartSharedColorPalette.prototype.rotateScale = function() {
                        this.preferredScale = this.preferredScale.clone(), this.preferredScale.clearAndRotateScale(), 
                        this.rotated = !0;
                    }, MekkoChartSharedColorPalette.prototype.setPreferredScale = function(scaleKey) {
                        this.rotated || (this.preferredScale = this.palette.getColorScaleByKey(scaleKey));
                    }, MekkoChartSharedColorPalette;
                }();
                samples.MekkoChartSharedColorPalette = MekkoChartSharedColorPalette;
                var MekkochartHelper;
                !function(MekkochartHelper) {
                    function getCategoryAxisProperties(dataViewMetadata, axisTitleOnByDefault) {
                        var toReturn = {};
                        if (!dataViewMetadata) return toReturn;
                        var objects = dataViewMetadata.objects;
                        if (objects) {
                            var categoryAxisObject = objects.categoryAxis;
                            categoryAxisObject && (toReturn = {
                                show: categoryAxisObject.show,
                                axisType: categoryAxisObject.axisType,
                                axisScale: categoryAxisObject.axisScale,
                                start: categoryAxisObject.start,
                                end: categoryAxisObject.end,
                                showAxisTitle: null == categoryAxisObject.showAxisTitle ? axisTitleOnByDefault : categoryAxisObject.showAxisTitle,
                                axisStyle: categoryAxisObject.axisStyle,
                                labelColor: categoryAxisObject.labelColor,
                                labelDisplayUnits: categoryAxisObject.labelDisplayUnits,
                                labelPrecision: categoryAxisObject.labelPrecision,
                                duration: categoryAxisObject.duration
                            });
                        }
                        return toReturn;
                    }
                    function getValueAxisProperties(dataViewMetadata, axisTitleOnByDefault) {
                        var toReturn = {};
                        if (!dataViewMetadata) return toReturn;
                        var objects = dataViewMetadata.objects;
                        if (objects) {
                            var valueAxisObject = objects.valueAxis;
                            valueAxisObject && (toReturn = {
                                show: valueAxisObject.show,
                                position: valueAxisObject.position,
                                axisScale: valueAxisObject.axisScale,
                                start: valueAxisObject.start,
                                end: valueAxisObject.end,
                                showAxisTitle: null == valueAxisObject.showAxisTitle ? axisTitleOnByDefault : valueAxisObject.showAxisTitle,
                                axisStyle: valueAxisObject.axisStyle,
                                labelColor: valueAxisObject.labelColor,
                                labelDisplayUnits: valueAxisObject.labelDisplayUnits,
                                labelPrecision: valueAxisObject.labelPrecision,
                                secShow: valueAxisObject.secShow,
                                secPosition: valueAxisObject.secPosition,
                                secAxisScale: valueAxisObject.secAxisScale,
                                secStart: valueAxisObject.secStart,
                                secEnd: valueAxisObject.secEnd,
                                secShowAxisTitle: valueAxisObject.secShowAxisTitle,
                                secAxisStyle: valueAxisObject.secAxisStyle,
                                secLabelColor: valueAxisObject.secLabelColor,
                                secLabelDisplayUnits: valueAxisObject.secLabelDisplayUnits,
                                secLabelPrecision: valueAxisObject.secLabelPrecision
                            });
                        }
                        return toReturn;
                    }
                    function isScalar(isScalar, xAxisCardProperties) {
                        return isScalar && (isScalar = !xAxisCardProperties || !xAxisCardProperties.axisType || xAxisCardProperties.axisType === axisType.scalar), 
                        isScalar;
                    }
                    MekkochartHelper.getCategoryAxisProperties = getCategoryAxisProperties, MekkochartHelper.getValueAxisProperties = getValueAxisProperties, 
                    MekkochartHelper.isScalar = isScalar;
                }(MekkochartHelper = samples.MekkochartHelper || (samples.MekkochartHelper = {}));
            }(samples = visuals.samples || (visuals.samples = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, jsCommon = window.jsCommon, powerbi = window.powerbi;
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var samples;
            !function(samples) {
                var SelectionManager = visuals.utility.SelectionManager, ValueFormatter = powerbi.visuals.valueFormatter, pixelConverterFromPoint = jsCommon.PixelConverter.fromPoint, SankeyDiagram = function() {
                    function SankeyDiagram(constructorOptions) {
                        this.margin = {
                            top: 10,
                            right: 10,
                            bottom: 10,
                            left: 10
                        }, this.nodeWidth = 21.5, this.curvatureOfLinks = .5, constructorOptions && (this.svg = constructorOptions.svg, 
                        this.margin = constructorOptions.margin || this.margin, this.curvatureOfLinks = constructorOptions.curvatureOfLinks || this.curvatureOfLinks);
                    }
                    return SankeyDiagram.getProperties = function(capabilities) {
                        var result = {};
                        for (var objectKey in capabilities.objects) {
                            result[objectKey] = {};
                            for (var propKey in capabilities.objects[objectKey].properties) result[objectKey][propKey] = {
                                objectName: objectKey,
                                propertyName: propKey
                            };
                        }
                        return result;
                    }, Object.defineProperty(SankeyDiagram.prototype, "textProperties", {
                        get: function() {
                            return {
                                fontFamily: this.root.style("font-family"),
                                fontSize: pixelConverterFromPoint(this.dataView ? this.dataView.settings.fontSize : SankeyDiagram.DefaultSettings.fontSize)
                            };
                        },
                        enumerable: !0,
                        configurable: !0
                    }), SankeyDiagram.prototype.init = function(visualsInitOptions) {
                        this.svg ? this.root = this.svg : this.root = d3.select(visualsInitOptions.element.get(0)).append("svg"), 
                        this.selectionManager = new SelectionManager({
                            hostServices: visualsInitOptions.host
                        });
                        var style = visualsInitOptions.style;
                        this.colours = style && style.colorPalette ? style.colorPalette.dataColors : new visuals.DataColorPalette(), 
                        this.root.classed(SankeyDiagram.ClassName, !0), this.main = this.root.append("g"), 
                        this.links = this.main.append("g").classed(SankeyDiagram.Links.class, !0), this.nodes = this.main.append("g").classed(SankeyDiagram.Nodes.class, !0);
                    }, SankeyDiagram.prototype.update = function(visualUpdateOptions) {
                        if (visualUpdateOptions && visualUpdateOptions.dataViews) {
                            var sankeyDiagramDataView, dataView = visualUpdateOptions.dataViews[0];
                            this.updateViewport(visualUpdateOptions.viewport), sankeyDiagramDataView = this.converter(dataView), 
                            this.computePositions(sankeyDiagramDataView), this.dataView = sankeyDiagramDataView, 
                            this.render(sankeyDiagramDataView);
                        }
                    }, SankeyDiagram.prototype.updateViewport = function(viewport) {
                        var height, width;
                        height = this.getPositiveNumber(viewport.height), width = this.getPositiveNumber(viewport.width), 
                        this.viewport = {
                            height: this.getPositiveNumber(height - this.margin.top - this.margin.bottom),
                            width: this.getPositiveNumber(width - this.margin.left - this.margin.right)
                        }, this.updateElements(height, width);
                    }, SankeyDiagram.prototype.getPositiveNumber = function(value) {
                        return value < 0 || isNaN(value) || null === value || value === 1 / 0 || value === -(1 / 0) ? 0 : value;
                    }, SankeyDiagram.prototype.updateElements = function(height, width) {
                        this.root.attr({
                            height: height,
                            width: width
                        }), this.main.attr("transform", visuals.SVGUtil.translate(this.margin.left, this.margin.top));
                    }, SankeyDiagram.prototype.converter = function(dataView) {
                        var _this = this;
                        if (!(dataView && dataView.categorical && dataView.categorical.categories && dataView.categorical.categories[0] && dataView.categorical.categories[1] && dataView.categorical.categories[0].values && dataView.categorical.categories[1].values)) return {
                            nodes: [],
                            links: [],
                            columns: [],
                            settings: {
                                scale: {
                                    x: 1,
                                    y: 1
                                },
                                colourOfLabels: SankeyDiagram.DefaultSettings.colourOfLabels,
                                fontSize: SankeyDiagram.DefaultSettings.fontSize
                            }
                        };
                        var allCategories, valueFormatterForCategories, valuesFormatterForWeigth, objects, labelColour, settings, shiftOfColour, nodes = [], links = [], dataPoints = [], categories = dataView.categorical.categories[0].values, secondCategories = dataView.categorical.categories[1].values, valuesColumn = dataView.categorical.values && dataView.categorical.values[0], weightValues = [], formatOfWeigth = "g", linksObjects = dataView.categorical.categories[0].objects || [], identities = [];
                        return valuesColumn && valuesColumn.values && valuesColumn.values.map && (weightValues = valuesColumn.values.map(function(x) {
                            return x ? x : 0;
                        })), dataView.categorical.categories[0].identity && (identities = identities.concat(dataView.categorical.categories[0].identity)), 
                        dataView.categorical.categories[1].identity && (identities = identities.concat(dataView.categorical.categories[1].identity)), 
                        objects = this.getObjectsFromDataView(dataView), labelColour = this.getColour(SankeyDiagram.Properties.labels.fill, SankeyDiagram.DefaultSettings.colourOfLabels, objects), 
                        valuesColumn && valuesColumn.source && (formatOfWeigth = ValueFormatter.getFormatString(valuesColumn.source, SankeyDiagram.Properties.general.formatString)), 
                        dataPoints = categories.map(function(item, index) {
                            return {
                                source: item,
                                destination: secondCategories[index],
                                weigth: valuesColumn ? Math.max(weightValues[index] || 0, 0) : 1
                            };
                        }), allCategories = categories.concat(secondCategories), valueFormatterForCategories = ValueFormatter.create({
                            format: ValueFormatter.getFormatString(dataView.categorical.categories[0].source, SankeyDiagram.Properties.general.formatString),
                            value: allCategories[0],
                            value2: allCategories[allCategories.length - 1]
                        }), valuesFormatterForWeigth = ValueFormatter.create({
                            format: formatOfWeigth,
                            value: Math.max(d3.max(weightValues) || 1, 1)
                        }), allCategories.forEach(function(item, index) {
                            if (!nodes.some(function(node) {
                                return item === node.label.name && (node.selectionIds.push(visuals.SelectionId.createWithId(identities[index])), 
                                !0);
                            })) {
                                var label, selectionId, formattedValue = valueFormatterForCategories.format(item), textProperties = {
                                    text: formattedValue,
                                    fontFamily: _this.textProperties.fontFamily,
                                    fontSize: _this.textProperties.fontSize
                                };
                                label = {
                                    name: item,
                                    formattedName: valueFormatterForCategories.format(item),
                                    width: powerbi.TextMeasurementService.measureSvgTextWidth(textProperties),
                                    height: powerbi.TextMeasurementService.estimateSvgTextHeight(textProperties),
                                    colour: labelColour
                                }, selectionId = visuals.SelectionId.createWithId(identities[index]), nodes.push({
                                    label: label,
                                    links: [],
                                    inputWeight: 0,
                                    outputWeight: 0,
                                    width: _this.nodeWidth,
                                    height: 0,
                                    colour: SankeyDiagram.DefaultColourOfNode,
                                    tooltipData: [],
                                    selectionIds: [ selectionId ]
                                });
                            }
                        }), shiftOfColour = this.colours.getAllColors().length / nodes.length, nodes.forEach(function(node, index) {
                            node.colour = _this.colours.getColorByIndex(Math.floor(index * shiftOfColour)).value;
                        }), dataPoints.forEach(function(dataPoint, index) {
                            var sourceNode, destinationNode, link, linkColour;
                            dataPoint.source !== dataPoint.destination && (nodes.forEach(function(node) {
                                node.label.name === dataPoint.source && (sourceNode = node), node.label.name === dataPoint.destination && (destinationNode = node);
                            }), linkColour = _this.getColour(SankeyDiagram.Properties.links.fill, SankeyDiagram.DefaultColourOfLink, linksObjects[index]), 
                            link = {
                                source: sourceNode,
                                destination: destinationNode,
                                weigth: dataPoint.weigth,
                                height: dataPoint.weigth,
                                colour: linkColour,
                                tooltipData: _this.getTooltipDataForLink(valuesFormatterForWeigth, sourceNode.label.formattedName, destinationNode.label.formattedName, dataPoint.weigth),
                                selectionId: visuals.SelectionId.createWithId(identities[index])
                            }, links.push(link), sourceNode.links.push(link), destinationNode.links.push(link), 
                            _this.updateValueOfNode(sourceNode), _this.updateValueOfNode(destinationNode), sourceNode.tooltipData = _this.getTooltipForNode(valuesFormatterForWeigth, sourceNode.label.formattedName, sourceNode.inputWeight ? sourceNode.inputWeight : sourceNode.outputWeight), 
                            destinationNode.tooltipData = _this.getTooltipForNode(valuesFormatterForWeigth, destinationNode.label.formattedName, destinationNode.inputWeight ? destinationNode.inputWeight : destinationNode.outputWeight));
                        }), settings = this.parseSettings(objects), settings.colourOfLabels = labelColour, 
                        {
                            nodes: nodes,
                            links: links,
                            settings: settings,
                            columns: []
                        };
                    }, SankeyDiagram.prototype.getObjectsFromDataView = function(dataView) {
                        return dataView && dataView.metadata && dataView.metadata.columns && dataView.metadata.objects ? dataView.metadata.objects : null;
                    }, SankeyDiagram.prototype.getColour = function(properties, defaultColor, objects) {
                        var colorHelper;
                        return colorHelper = new visuals.ColorHelper(this.colours, properties, defaultColor), 
                        colorHelper.getColorForMeasure(objects, "");
                    }, SankeyDiagram.prototype.getTooltipDataForLink = function(valueFormatter, sourceNodeName, destinationNodeName, linkWeight) {
                        var formattedLinkWeight;
                        return formattedLinkWeight = valueFormatter && valueFormatter.format ? valueFormatter.format(linkWeight) : linkWeight.toString(), 
                        [ {
                            displayName: SankeyDiagram.RoleNames.rows,
                            value: sourceNodeName
                        }, {
                            displayName: SankeyDiagram.RoleNames.columns,
                            value: destinationNodeName
                        }, {
                            displayName: SankeyDiagram.RoleNames.values,
                            value: formattedLinkWeight
                        } ];
                    }, SankeyDiagram.prototype.updateValueOfNode = function(node) {
                        node.inputWeight = node.links.reduce(function(previousValue, currentValue) {
                            return previousValue + (currentValue.destination === node ? currentValue.weigth : 0);
                        }, 0), node.outputWeight = node.links.reduce(function(previousValue, currentValue) {
                            return previousValue + (currentValue.source === node ? currentValue.weigth : 0);
                        }, 0);
                    }, SankeyDiagram.prototype.getTooltipForNode = function(valueFormatter, nodeName, nodeWeight) {
                        var formattedNodeWeigth;
                        return formattedNodeWeigth = valueFormatter && valueFormatter.format ? valueFormatter.format(nodeWeight) : nodeWeight.toString(), 
                        [ {
                            displayName: "Name",
                            value: nodeName
                        }, {
                            displayName: SankeyDiagram.RoleNames.values,
                            value: formattedNodeWeigth
                        } ];
                    }, SankeyDiagram.prototype.parseSettings = function(objects) {
                        var isVisibleLabels = !1;
                        return isVisibleLabels = powerbi.DataViewObjects.getValue(objects, SankeyDiagram.Properties.labels.show, SankeyDiagram.DefaultSettings.isVisibleLabels), 
                        {
                            isVisibleLabels: isVisibleLabels,
                            scale: {
                                x: SankeyDiagram.DefaultSettings.scale.x,
                                y: SankeyDiagram.DefaultSettings.scale.y
                            },
                            colourOfLabels: SankeyDiagram.DefaultSettings.colourOfLabels,
                            fontSize: powerbi.DataViewObjects.getValue(objects, SankeyDiagram.Properties.labels.fontSize, SankeyDiagram.DefaultSettings.fontSize)
                        };
                    }, SankeyDiagram.prototype.computePositions = function(sankeyDiagramDataView) {
                        var maxXPosition, maxColumn, columns;
                        maxXPosition = this.computeXPositions(sankeyDiagramDataView), this.sortNodesByX(sankeyDiagramDataView.nodes), 
                        columns = this.getColumns(sankeyDiagramDataView.nodes), maxColumn = this.getMaxColumn(columns), 
                        sankeyDiagramDataView.settings.scale.x = this.getScaleByAxisX(maxXPosition), sankeyDiagramDataView.settings.scale.y = this.getScaleByAxisY(maxColumn.sumValueOfNodes), 
                        this.scalePositionsByAxes(sankeyDiagramDataView.nodes, columns, sankeyDiagramDataView.settings.scale, this.viewport.height), 
                        this.computeYPosition(sankeyDiagramDataView.nodes, sankeyDiagramDataView.settings.scale.y);
                    }, SankeyDiagram.prototype.computeXPositions = function(sankeyDiagramDataView) {
                        for (var nodes = sankeyDiagramDataView.nodes, nextNodes = [], previousNodes = [], x = 0, isRecursiveDependencies = !1; nodes.length > 0; ) nextNodes = [], 
                        nodes.forEach(function(node) {
                            node.x = x, node.links.forEach(function(link) {
                                node === link.source && node !== link.destination && nextNodes.every(function(item) {
                                    return item !== link.destination;
                                }) && nextNodes.push(link.destination);
                            });
                        }), isRecursiveDependencies = nextNodes.length === previousNodes.length && previousNodes.every(function(previousNode) {
                            return nextNodes.some(function(nextNode) {
                                return nextNode === previousNode;
                            });
                        }), isRecursiveDependencies ? (previousNodes.forEach(function(element) {
                            element.x = x, x++;
                        }), nodes = []) : (nodes = nextNodes, previousNodes = nodes, x++);
                        return x - 1;
                    }, SankeyDiagram.prototype.getScaleByAxisX = function(numberOfColumns) {
                        return void 0 === numberOfColumns && (numberOfColumns = 1), this.getPositiveNumber((this.viewport.width - this.nodeWidth) / numberOfColumns);
                    }, SankeyDiagram.prototype.sortNodesByX = function(nodes) {
                        return nodes.sort(function(firstNode, secondNode) {
                            return firstNode.x - secondNode.x;
                        });
                    }, SankeyDiagram.prototype.getColumns = function(nodes) {
                        var columns = [], currentX = -Number.MAX_VALUE;
                        return nodes.forEach(function(node, index) {
                            currentX !== node.x && (columns.push({
                                countOfNodes: 0,
                                sumValueOfNodes: 0
                            }), currentX = node.x), columns[node.x] && (columns[node.x].sumValueOfNodes += Math.max(node.inputWeight, node.outputWeight), 
                            columns[node.x].countOfNodes++);
                        }), columns;
                    }, SankeyDiagram.prototype.getMaxColumn = function(columns) {
                        void 0 === columns && (columns = []);
                        var currentMaxColumn = {
                            sumValueOfNodes: 0,
                            countOfNodes: 0
                        };
                        return columns.forEach(function(column) {
                            column && column.sumValueOfNodes > currentMaxColumn.sumValueOfNodes && (currentMaxColumn = column);
                        }), currentMaxColumn;
                    }, SankeyDiagram.prototype.getScaleByAxisY = function(sumValueOfNodes) {
                        return this.getPositiveNumber((this.viewport.height - this.getAvailableSumNodeMarginByY()) / sumValueOfNodes);
                    }, SankeyDiagram.prototype.getAvailableSumNodeMarginByY = function() {
                        return this.viewport ? this.viewport.height * SankeyDiagram.NodeBottomMargin / 100 : 0;
                    }, SankeyDiagram.prototype.scalePositionsByAxes = function(nodes, columns, scale, viewportHeight) {
                        var shiftByAxisY = 0, currentX = 0, index = 0;
                        nodes.forEach(function(node) {
                            var offsetByY = 0, availableHeight = 0;
                            currentX !== node.x && (currentX = node.x, shiftByAxisY = 0, index = 0), columns[currentX] && (availableHeight = viewportHeight - columns[currentX].sumValueOfNodes * scale.y, 
                            offsetByY = availableHeight / columns[currentX].countOfNodes), node.x *= scale.x, 
                            node.height = Math.max(node.inputWeight, node.outputWeight) * scale.y, node.y = shiftByAxisY + offsetByY * index, 
                            shiftByAxisY += node.height, index++;
                        });
                    }, SankeyDiagram.prototype.computeYPosition = function(nodes, scale) {
                        nodes.forEach(function(node) {
                            node.links = node.links.sort(function(firstLink, secondLink) {
                                var firstY, secondY;
                                return firstY = firstLink.source === node ? firstLink.destination.y : firstLink.source.y, 
                                secondY = secondLink.source === node ? secondLink.destination.y : secondLink.source.y, 
                                firstY - secondY;
                            });
                            var shiftByAxisYOfLeftLink = 0, shiftByAxisYOfRightLink = 0;
                            node.links.forEach(function(link) {
                                var shiftByAxisY = 0;
                                link.height = link.weigth * scale, link.source.x < node.x || link.destination.x < node.x ? (shiftByAxisY = shiftByAxisYOfLeftLink, 
                                shiftByAxisYOfLeftLink += link.height) : (link.source.x > node.x || link.destination.x > node.x) && (shiftByAxisY = shiftByAxisYOfRightLink, 
                                shiftByAxisYOfRightLink += link.height), link.source === node ? link.dySource = shiftByAxisY : link.destination === node && (link.dyDestination = shiftByAxisY);
                            });
                        });
                    }, SankeyDiagram.prototype.render = function(sankeyDiagramDataView) {
                        var nodesSelection, linksSelection;
                        linksSelection = this.renderLinks(sankeyDiagramDataView), this.renderTooltip(linksSelection), 
                        nodesSelection = this.renderNodes(sankeyDiagramDataView), this.renderTooltip(nodesSelection), 
                        this.bindSelectionHandler(sankeyDiagramDataView, nodesSelection, linksSelection);
                    }, SankeyDiagram.prototype.renderNodes = function(sankeyDiagramDataView) {
                        var nodesEnterSelection, nodesSelection, nodeElements, _this = this;
                        return nodeElements = this.main.select(SankeyDiagram.Nodes.selector).selectAll(SankeyDiagram.Node.selector), 
                        nodesSelection = nodeElements.data(sankeyDiagramDataView.nodes.filter(function(x) {
                            return x.height > 0;
                        })), nodesEnterSelection = nodesSelection.enter().append("g"), nodesSelection.attr("transform", function(node) {
                            return visuals.SVGUtil.translate(node.x, node.y);
                        }).classed(SankeyDiagram.Node.class, !0), nodesEnterSelection.append("rect").classed(SankeyDiagram.NodeRect.class, !0), 
                        nodesEnterSelection.append("text").classed(SankeyDiagram.NodeLabel.class, !0), nodesSelection.select(SankeyDiagram.NodeRect.selector).style({
                            fill: function(node) {
                                return node.colour;
                            },
                            stroke: function(node) {
                                return d3.rgb(node.colour).darker(1.5);
                            }
                        }).attr({
                            x: 0,
                            y: 0,
                            height: function(node) {
                                return node.height;
                            },
                            width: function(node) {
                                return node.width;
                            }
                        }), nodesSelection.select(SankeyDiagram.NodeLabel.selector).attr({
                            x: function(node) {
                                return _this.getLabelPositionByAxisX(node);
                            },
                            y: function(node) {
                                return node.height / 2;
                            },
                            dy: "0.35em"
                        }).style("fill", function(node) {
                            return node.label.colour;
                        }).style("font-size", this.textProperties.fontSize).style("display", function(node) {
                            var isNotVisibleLabel = !1, labelPositionByAxisX = _this.getCurrentPositionOfLabelByAxisX(node);
                            return isNotVisibleLabel = labelPositionByAxisX >= _this.viewport.width || labelPositionByAxisX <= 0 || node.height + SankeyDiagram.NodeMargin < node.label.height, 
                            isNotVisibleLabel || !sankeyDiagramDataView.settings.isVisibleLabels || sankeyDiagramDataView.settings.scale.x / 2 < SankeyDiagram.MinWidthOfLabel ? "none" : null;
                        }).style("text-anchor", function(node) {
                            return _this.isLabelLargerThanWidth(node) ? "end" : null;
                        }).text(function(node) {
                            var maxWidth = sankeyDiagramDataView.settings.scale.x / 2 - node.width - SankeyDiagram.NodeMargin;
                            return _this.getCurrentPositionOfLabelByAxisX(node) > maxWidth ? powerbi.TextMeasurementService.getTailoredTextOrDefault({
                                text: node.label.formattedName,
                                fontFamily: _this.textProperties.fontFamily,
                                fontSize: _this.textProperties.fontSize
                            }, maxWidth) : node.label.formattedName;
                        }), nodesSelection.exit().remove(), nodesSelection;
                    }, SankeyDiagram.prototype.getLabelPositionByAxisX = function(node) {
                        return this.isLabelLargerThanWidth(node) ? -SankeyDiagram.LabelMargin : node.width + SankeyDiagram.LabelMargin;
                    }, SankeyDiagram.prototype.isLabelLargerThanWidth = function(node) {
                        var shiftByAxisX = node.x + node.width + SankeyDiagram.LabelMargin;
                        return shiftByAxisX + node.label.width > this.viewport.width;
                    }, SankeyDiagram.prototype.getCurrentPositionOfLabelByAxisX = function(node) {
                        var labelPositionByAxisX = this.getLabelPositionByAxisX(node);
                        return labelPositionByAxisX = labelPositionByAxisX > 0 ? labelPositionByAxisX + node.x + node.label.width + node.width : node.x + labelPositionByAxisX - node.label.width - node.width;
                    }, SankeyDiagram.prototype.renderLinks = function(sankeyDiagramDataView) {
                        var linksSelection, linksElements, _this = this;
                        return linksElements = this.main.select(SankeyDiagram.Links.selector).selectAll(SankeyDiagram.Link.selector), 
                        linksSelection = linksElements.data(sankeyDiagramDataView.links.filter(function(x) {
                            return x.height > 0;
                        })), linksSelection.enter().append("path").classed(SankeyDiagram.Link.class, !0), 
                        linksSelection.attr("d", function(link) {
                            return _this.getSvgPath(link);
                        }).style({
                            "stroke-width": function(link) {
                                return link.height;
                            },
                            stroke: function(link) {
                                return link.colour;
                            }
                        }), linksSelection.exit().remove(), linksSelection;
                    }, SankeyDiagram.prototype.getSvgPath = function(link) {
                        var x0, x1, xi, x2, x3, y0, y1;
                        return link.destination.x < link.source.x ? (x0 = link.source.x, x1 = link.destination.x + link.destination.width) : (x0 = link.source.x + link.source.width, 
                        x1 = link.destination.x), xi = d3.interpolateNumber(x0, x1), x2 = xi(this.curvatureOfLinks), 
                        x3 = xi(1 - this.curvatureOfLinks), y0 = link.source.y + link.dySource + link.height / 2, 
                        y1 = link.destination.y + link.dyDestination + link.height / 2, "M " + x0 + " " + y0 + " C " + x2 + " " + y0 + ", " + x3 + " " + y1 + ", " + x1 + " " + y1;
                    }, SankeyDiagram.prototype.renderTooltip = function(selection) {
                        visuals.TooltipManager.addTooltip(selection, function(tooltipEvent) {
                            return tooltipEvent.data.tooltipData;
                        });
                    }, SankeyDiagram.prototype.bindSelectionHandler = function(sankeyDiagramDataView, nodesSelection, linksSelection) {
                        var _this = this;
                        nodesSelection.on("click", function(node) {
                            var selectionIds = _.isEqual(node.selectionIds.map(function(x) {
                                return x.getKey();
                            }), _this.selectionManager.getSelectionIds().map(function(x) {
                                return x.getKey();
                            })) ? [] : node.selectionIds;
                            _this.selectMany(selectionIds, !0).then(function() {
                                return _this.setSelection(nodesSelection, linksSelection);
                            }), d3.event.stopPropagation();
                        }), linksSelection.on("click", function(link) {
                            _this.selectionManager.select(link.selectionId, d3.event.ctrlKey).then(function() {
                                return _this.setSelection(nodesSelection, linksSelection);
                            }), d3.event.stopPropagation();
                        }), this.root.on("click", function() {
                            _this.selectionManager.clear().then(function() {
                                return _this.setSelection(nodesSelection, linksSelection);
                            });
                        }), this.setSelection(nodesSelection, linksSelection);
                    }, SankeyDiagram.prototype.selectMany = function(selectionIds, clear) {
                        var _this = this;
                        if (void 0 === clear && (clear = !1), clear) return this.selectionManager.clear().then(function() {
                            return _this.selectMany(selectionIds, !1);
                        });
                        var selectionDeffered = selectionIds.map(function(id) {
                            return _this.selectionManager.select(id, !0);
                        });
                        return $.when.apply(null, selectionDeffered);
                    }, SankeyDiagram.prototype.setSelection = function(nodes, links) {
                        var selectionIds = this.selectionManager.getSelectionIds();
                        if (nodes.classed("selected", selectionIds.length > 0), links.classed("selected", !1), 
                        0 !== selectionIds.length) {
                            var selectedNodesSelection = nodes.filter(function(node) {
                                return selectionIds.some(function(selectedId) {
                                    return node.selectionIds.some(function(x) {
                                        return x.getKey() === selectedId.getKey();
                                    });
                                });
                            }), selectedLinksSelection = links.filter(function(link) {
                                return selectionIds.some(function(selectionId) {
                                    return selectionId.getKey() === link.selectionId.getKey();
                                });
                            });
                            selectedNodesSelection.classed("selected", !1), selectedLinksSelection.classed("selected", !0);
                        }
                    }, SankeyDiagram.prototype.enumerateObjectInstances = function(options) {
                        var enumeration = new visuals.ObjectEnumerationBuilder();
                        if (!this.dataView) return [];
                        switch (options.objectName) {
                          case "labels":
                            this.enumerateLabels(enumeration);
                            break;

                          case "links":
                            this.enumerateLinks(enumeration);
                        }
                        return enumeration.complete();
                    }, SankeyDiagram.prototype.enumerateLabels = function(enumeration) {
                        var labels, settings = this.dataView.settings;
                        settings && (labels = {
                            objectName: "labels",
                            displayName: "labels",
                            selector: null,
                            properties: {
                                show: settings.isVisibleLabels,
                                fill: settings.colourOfLabels,
                                fontSize: settings.fontSize
                            }
                        }, enumeration.pushInstance(labels));
                    }, SankeyDiagram.prototype.enumerateLinks = function(enumeration) {
                        var links = this.dataView.links;
                        links && links.length > 0 && links.forEach(function(link) {
                            enumeration.pushInstance({
                                objectName: "links",
                                displayName: link.source.label.formattedName + " - " + link.destination.label.formattedName,
                                selector: visuals.ColorHelper.normalizeSelector(link.selectionId.getSelector(), !1),
                                properties: {
                                    fill: {
                                        solid: {
                                            color: link.colour
                                        }
                                    }
                                }
                            });
                        });
                    }, SankeyDiagram.ClassName = "sankeyDiagram", SankeyDiagram.Nodes = {
                        class: "nodes",
                        selector: ".nodes"
                    }, SankeyDiagram.Node = {
                        class: "node",
                        selector: ".node"
                    }, SankeyDiagram.NodeRect = {
                        class: "nodeRect",
                        selector: ".nodeRect"
                    }, SankeyDiagram.NodeLabel = {
                        class: "nodeLabel",
                        selector: ".nodeLabel"
                    }, SankeyDiagram.Links = {
                        class: "links",
                        selector: ".links"
                    }, SankeyDiagram.Link = {
                        class: "link",
                        selector: ".link"
                    }, SankeyDiagram.DefaultColourOfNode = "rgb(62, 187, 162)", SankeyDiagram.DefaultColourOfLink = "black", 
                    SankeyDiagram.DefaultSettings = {
                        isVisibleLabels: !0,
                        scale: {
                            x: 1,
                            y: 1
                        },
                        colourOfLabels: "black",
                        fontSize: 12
                    }, SankeyDiagram.MinWidthOfLabel = 35, SankeyDiagram.NodeBottomMargin = 5, SankeyDiagram.NodeMargin = 5, 
                    SankeyDiagram.LabelMargin = 4, SankeyDiagram.RoleNames = {
                        rows: "Source",
                        columns: "Destination",
                        values: "Weight"
                    }, SankeyDiagram.capabilities = {
                        dataRoles: [ {
                            name: SankeyDiagram.RoleNames.rows,
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: SankeyDiagram.RoleNames.rows
                        }, {
                            name: SankeyDiagram.RoleNames.columns,
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: SankeyDiagram.RoleNames.columns
                        }, {
                            name: SankeyDiagram.RoleNames.values,
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: SankeyDiagram.RoleNames.values
                        } ],
                        dataViewMappings: [ {
                            conditions: [ {
                                Source: {
                                    min: 0,
                                    max: 1
                                },
                                Destination: {
                                    min: 0,
                                    max: 1
                                },
                                Weight: {
                                    min: 0,
                                    max: 0
                                }
                            }, {
                                Source: {
                                    min: 0,
                                    max: 1
                                },
                                Destination: {
                                    min: 0,
                                    max: 1
                                },
                                Weight: {
                                    min: 1,
                                    max: 1
                                }
                            } ],
                            categorical: {
                                categories: {
                                    select: [ {
                                        for: {
                                            in: SankeyDiagram.RoleNames.rows
                                        }
                                    }, {
                                        for: {
                                            in: SankeyDiagram.RoleNames.columns
                                        }
                                    } ],
                                    dataReductionAlgorithm: {
                                        top: {}
                                    }
                                },
                                values: {
                                    for: {
                                        in: SankeyDiagram.RoleNames.values
                                    }
                                }
                            }
                        } ],
                        objects: {
                            general: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_General"),
                                properties: {
                                    formatString: {
                                        type: {
                                            formatting: {
                                                formatString: !0
                                            }
                                        }
                                    }
                                }
                            },
                            labels: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_DataPointsLabels"),
                                properties: {
                                    show: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    fill: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Fill"),
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    fontSize: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_TextSize"),
                                        type: {
                                            formatting: {
                                                fontSize: !0
                                            }
                                        }
                                    }
                                }
                            },
                            links: {
                                displayName: "Links",
                                properties: {
                                    fill: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Fill"),
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }, SankeyDiagram.Properties = SankeyDiagram.getProperties(SankeyDiagram.capabilities), 
                    SankeyDiagram;
                }();
                samples.SankeyDiagram = SankeyDiagram;
            }(samples = visuals.samples || (visuals.samples = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, jsCommon = window.jsCommon, powerbi = window.powerbi;
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var samples;
            !function(samples) {
                var PixelConverter = jsCommon.PixelConverter, createEnumType = powerbi.createEnumType, VisualDataRoleKind = powerbi.VisualDataRoleKind, DataViewObjects = powerbi.DataViewObjects, TextMeasurementService = powerbi.TextMeasurementService, TooltipManager = powerbi.visuals.TooltipManager, appendClearCatcher = powerbi.visuals.appendClearCatcher, createInteractivityService = powerbi.visuals.createInteractivityService, valueFormatter = powerbi.visuals.valueFormatter, TooltipBuilder = powerbi.visuals.TooltipBuilder, ObjectEnumerationBuilder = powerbi.visuals.ObjectEnumerationBuilder, converterHelper = powerbi.visuals.converterHelper, SelectionIdBuilder = powerbi.visuals.SelectionIdBuilder, AxisHelper = powerbi.visuals.AxisHelper, axisScale = powerbi.visuals.axisScale;
                !function(BulletChartOrientation) {
                    BulletChartOrientation[BulletChartOrientation.HorizontalLeft = "Horizontal Left"] = "HorizontalLeft", 
                    BulletChartOrientation[BulletChartOrientation.HorizontalRight = "Horizontal Right"] = "HorizontalRight", 
                    BulletChartOrientation[BulletChartOrientation.VerticalTop = "Vertical Top"] = "VerticalTop", 
                    BulletChartOrientation[BulletChartOrientation.VerticalBottom = "Vertical Bottom"] = "VerticalBottom";
                }(samples.BulletChartOrientation || (samples.BulletChartOrientation = {}));
                var BulletChartOrientation = samples.BulletChartOrientation, VisualLayout = function() {
                    function VisualLayout(defaultViewport, defaultMargin) {
                        this.defaultViewport = defaultViewport || {
                            width: 0,
                            height: 0
                        }, this.defaultMargin = defaultMargin || {
                            top: 0,
                            bottom: 0,
                            right: 0,
                            left: 0
                        };
                    }
                    return Object.defineProperty(VisualLayout.prototype, "viewport", {
                        get: function() {
                            return this.viewportValue || (this.viewportValue = this.defaultViewport);
                        },
                        set: function(value) {
                            var _this = this;
                            this.previousOriginalViewportValue = _.clone(this.originalViewportValue), this.originalViewportValue = _.clone(value), 
                            this.setUpdateObject(value, function(v) {
                                return _this.viewportValue = v;
                            }, function(o) {
                                return VisualLayout.restrictToMinMax(o, _this.minViewport);
                            });
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(VisualLayout.prototype, "viewportCopy", {
                        get: function() {
                            return _.clone(this.viewport);
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(VisualLayout.prototype, "viewportIn", {
                        get: function() {
                            return this.viewportInValue || this.viewport;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(VisualLayout.prototype, "minViewport", {
                        get: function() {
                            return this.minViewportValue || {
                                width: 0,
                                height: 0
                            };
                        },
                        set: function(value) {
                            var _this = this;
                            this.setUpdateObject(value, function(v) {
                                return _this.minViewportValue = v;
                            }, VisualLayout.restrictToMinMax);
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(VisualLayout.prototype, "margin", {
                        get: function() {
                            return this.marginValue || (this.marginValue = this.defaultMargin);
                        },
                        set: function(value) {
                            var _this = this;
                            this.setUpdateObject(value, function(v) {
                                return _this.marginValue = v;
                            }, VisualLayout.restrictToMinMax);
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(VisualLayout.prototype, "viewportChanged", {
                        get: function() {
                            return !(!this.originalViewportValue || this.previousOriginalViewportValue && this.previousOriginalViewportValue.height === this.originalViewportValue.height && this.previousOriginalViewportValue.width === this.originalViewportValue.width);
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(VisualLayout.prototype, "viewportInIsZero", {
                        get: function() {
                            return 0 === this.viewportIn.width || 0 === this.viewportIn.height;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), VisualLayout.prototype.resetMargin = function() {
                        this.margin = this.defaultMargin;
                    }, VisualLayout.prototype.update = function() {
                        this.viewportInValue = VisualLayout.restrictToMinMax({
                            width: this.viewport.width - (this.margin.left + this.margin.right),
                            height: this.viewport.height - (this.margin.top + this.margin.bottom)
                        }, this.minViewportValue);
                    }, VisualLayout.prototype.setUpdateObject = function(object, setObjectFn, beforeUpdateFn) {
                        var _this = this;
                        object = _.clone(object), setObjectFn(VisualLayout.createNotifyChangedObject(object, function(o) {
                            beforeUpdateFn && beforeUpdateFn(object), _this.update();
                        })), beforeUpdateFn && beforeUpdateFn(object), this.update();
                    }, VisualLayout.createNotifyChangedObject = function(object, objectChanged) {
                        var result = {};
                        return _.keys(object).forEach(function(key) {
                            return Object.defineProperty(result, key, {
                                get: function() {
                                    return object[key];
                                },
                                set: function(value) {
                                    object[key] = value, objectChanged(object, key);
                                },
                                enumerable: !0,
                                configurable: !0
                            });
                        }), result;
                    }, VisualLayout.restrictToMinMax = function(value, minValue) {
                        return _.keys(value).forEach(function(x) {
                            return value[x] = Math.max(minValue && minValue[x] || 0, value[x]);
                        }), value;
                    }, VisualLayout;
                }(), BulletChartSettings = function() {
                    function BulletChartSettings() {
                        this.values = {
                            targetValue: null,
                            targetValue2: null,
                            minimumPercent: 0,
                            needsImprovementPercent: null,
                            satisfactoryPercent: null,
                            goodPercent: null,
                            veryGoodPercent: null,
                            maximumPercent: null
                        }, this.labels = {
                            show: !0,
                            labelColor: "Black",
                            fontSize: 11
                        }, this.orientation = {
                            orientation: BulletChartOrientation.HorizontalLeft
                        }, this.colors = {
                            minColor: "Darkred",
                            needsImprovementColor: "Red",
                            satisfactoryColor: "Yellow",
                            goodColor: "Green",
                            veryGoodColor: "Darkgreen",
                            bulletColor: "Black"
                        }, this.axis = {
                            axis: !0,
                            axisColor: "Grey",
                            measureUnits: "",
                            unitsColor: "Grey"
                        };
                    }
                    return Object.defineProperty(BulletChartSettings, "Default", {
                        get: function() {
                            return new this();
                        },
                        enumerable: !0,
                        configurable: !0
                    }), BulletChartSettings.parse = function(dataView, capabilities) {
                        var settings = new this();
                        if (!dataView || !dataView.metadata || !dataView.metadata.objects) return settings;
                        var properties = this.getProperties(capabilities);
                        for (var objectKey in capabilities.objects) for (var propKey in capabilities.objects[objectKey].properties) if (settings[objectKey] && _.has(settings[objectKey], propKey)) {
                            var type = capabilities.objects[objectKey].properties[propKey].type, getValueFn = this.getValueFnByType(type);
                            settings[objectKey][propKey] = getValueFn(dataView.metadata.objects, properties[objectKey][propKey], settings[objectKey][propKey]);
                        }
                        return settings;
                    }, BulletChartSettings.getProperties = function(capabilities) {
                        var objects = _.merge({
                            general: {
                                properties: {
                                    formatString: {}
                                }
                            }
                        }, capabilities.objects), properties = {};
                        for (var objectKey in objects) {
                            properties[objectKey] = {};
                            for (var propKey in objects[objectKey].properties) properties[objectKey][propKey] = {
                                objectName: objectKey,
                                propertyName: propKey
                            };
                        }
                        return properties;
                    }, BulletChartSettings.createEnumTypeFromEnum = function(type) {
                        var even = !1;
                        return createEnumType(Object.keys(type).filter(function(key, i) {
                            return !!(i % 2) === even && type[key] === key && !void (even = !even) || !!(i % 2) !== even;
                        }).map(function(x) {
                            return {
                                value: x,
                                displayName: x
                            };
                        }));
                    }, BulletChartSettings.getValueFnByType = function(type) {
                        switch (_.keys(type)[0]) {
                          case "fill":
                            return DataViewObjects.getFillColor;

                          default:
                            return DataViewObjects.getValue;
                        }
                    }, BulletChartSettings.enumerateObjectInstances = function(settings, options, capabilities) {
                        void 0 === settings && (settings = new this());
                        var enumeration = new ObjectEnumerationBuilder(), object = settings && settings[options.objectName];
                        if (!object) return enumeration;
                        var instance = {
                            objectName: options.objectName,
                            selector: null,
                            properties: {}
                        };
                        for (var key in object) _.has(object, key) && (instance.properties[key] = object[key]);
                        return enumeration.pushInstance(instance), enumeration;
                    }, BulletChartSettings.prototype.createOriginalSettings = function() {
                        this.originalSettings = _.cloneDeep(this);
                    }, BulletChartSettings;
                }();
                samples.BulletChartSettings = BulletChartSettings;
                var BulletChartColumns = function() {
                    function BulletChartColumns() {
                        this.Category = null, this.Value = null, this.TargetValue = null, this.Minimum = null, 
                        this.NeedsImprovement = null, this.Satisfactory = null, this.Good = null, this.VeryGood = null, 
                        this.Maximum = null, this.TargetValue2 = null;
                    }
                    return BulletChartColumns.getColumnSources = function(dataView) {
                        return this.getColumnSourcesT(dataView);
                    }, BulletChartColumns.getTableValues = function(dataView) {
                        var table = dataView && dataView.table, columns = this.getColumnSourcesT(dataView);
                        return columns && table && _.mapValues(columns, function(n, i) {
                            return n && table.rows.map(function(row) {
                                return row[n.index];
                            });
                        });
                    }, BulletChartColumns.getTableRows = function(dataView) {
                        var table = dataView && dataView.table, columns = this.getColumnSourcesT(dataView);
                        return columns && table && table.rows.map(function(row) {
                            return _.mapValues(columns, function(n, i) {
                                return n && row[n.index];
                            });
                        });
                    }, BulletChartColumns.getCategoricalValues = function(dataView) {
                        var categorical = dataView && dataView.categorical, categories = categorical && categorical.categories || [], values = categorical && categorical.values || [], series = categorical && values.source && this.getSeriesValues(dataView);
                        return categorical && _.mapValues(new this(), function(n, i) {
                            return _.toArray(categories).concat(_.toArray(values)).filter(function(x) {
                                return x.source.roles && x.source.roles[i];
                            }).map(function(x) {
                                return x.values;
                            })[0] || values.source && values.source.roles && values.source.roles[i] && series;
                        });
                    }, BulletChartColumns.getSeriesValues = function(dataView) {
                        return dataView && dataView.categorical && dataView.categorical.values && dataView.categorical.values.map(function(x) {
                            return converterHelper.getSeriesName(x.source);
                        });
                    }, BulletChartColumns.getCategoricalColumns = function(dataView) {
                        var categorical = dataView && dataView.categorical, categories = categorical && categorical.categories || [], values = categorical && categorical.values || [];
                        return categorical && _.mapValues(new this(), function(n, i) {
                            return categories.filter(function(x) {
                                return x.source.roles && x.source.roles[i];
                            })[0] || values.source && values.source.roles && values.source.roles[i] && values || values.filter(function(x) {
                                return x.source.roles && x.source.roles[i];
                            });
                        });
                    }, BulletChartColumns.getGroupedValueColumns = function(dataView) {
                        var _this = this, categorical = dataView && dataView.categorical, values = categorical && categorical.values, grouped = values && values.grouped();
                        return grouped && grouped.map(function(g) {
                            return _.mapValues(new _this(), function(n, i) {
                                return g.values.filter(function(v) {
                                    return v.source.roles[i];
                                })[0];
                            });
                        });
                    }, BulletChartColumns.getColumnSourcesT = function(dataView) {
                        var columns = dataView && dataView.metadata && dataView.metadata.columns;
                        return columns && _.mapValues(new this(), function(n, i) {
                            return columns.filter(function(x) {
                                return x.roles && x.roles[i];
                            })[0];
                        });
                    }, BulletChartColumns.Roles = Object.freeze(_.mapValues(new BulletChartColumns(), function(x, i) {
                        return i;
                    })), BulletChartColumns;
                }();
                samples.BulletChartColumns = BulletChartColumns;
                var BulletChart = function() {
                    function BulletChart() {
                        this.baselineDelta = 0;
                    }
                    return Object.defineProperty(BulletChart.prototype, "settings", {
                        get: function() {
                            return this.data && this.data.settings;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(BulletChart.prototype, "reverse", {
                        get: function() {
                            switch (this.settings && this.settings.orientation.orientation) {
                              case BulletChartOrientation.HorizontalRight:
                              case BulletChartOrientation.VerticalBottom:
                                return !0;

                              default:
                                return !1;
                            }
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(BulletChart.prototype, "vertical", {
                        get: function() {
                            switch (this.settings && this.settings.orientation.orientation) {
                              case BulletChartOrientation.VerticalTop:
                              case BulletChartOrientation.VerticalBottom:
                                return !0;

                              default:
                                return !1;
                            }
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(BulletChart.prototype, "viewportScroll", {
                        get: function() {
                            return {
                                width: Math.max(0, this.layout.viewportIn.width - BulletChart.ScrollBarSize),
                                height: Math.max(0, this.layout.viewportIn.height - BulletChart.ScrollBarSize)
                            };
                        },
                        enumerable: !0,
                        configurable: !0
                    }), BulletChart.getTextProperties = function(text, fontSize) {
                        return {
                            fontFamily: BulletChart.FontFamily,
                            fontSize: PixelConverter.fromPoint(fontSize),
                            text: text
                        };
                    }, BulletChart.converter = function(dataView, options) {
                        var categorical = BulletChartColumns.getCategoricalColumns(dataView);
                        if (!categorical || !categorical.Category || _.isEmpty(categorical.Category.values) || !categorical.Value || !categorical.Value[0]) return null;
                        var categoricalValues = BulletChartColumns.getCategoricalValues(dataView), settings = BulletChart.parseSettings(dataView), properties = BulletChartSettings.getProperties(BulletChart.capabilities), bulletModel = {
                            settings: settings,
                            bars: [],
                            barRects: [],
                            valueRects: [],
                            targetValues: [],
                            viewportLength: 0
                        }, verticalOrientation = settings.orientation.orientation === BulletChartOrientation.VerticalBottom || settings.orientation.orientation === BulletChartOrientation.VerticalTop, reversedOrientation = settings.orientation.orientation === BulletChartOrientation.HorizontalRight || settings.orientation.orientation === BulletChartOrientation.VerticalBottom;
                        bulletModel.labelHeight = (settings.labels.show || 0) && parseFloat(PixelConverter.fromPoint(settings.labels.fontSize)), 
                        bulletModel.labelHeightTop = (settings.labels.show || 0) && parseFloat(PixelConverter.fromPoint(settings.labels.fontSize)) / 1.4, 
                        bulletModel.spaceRequiredForBarHorizontally = Math.max(60, bulletModel.labelHeight + 20), 
                        bulletModel.viewportLength = Math.max(0, (verticalOrientation ? options.viewport.height - bulletModel.labelHeightTop - BulletChart.SubtitleMargin - 20 - 2 * BulletChart.YMarginVertical : options.viewport.width - BulletChart.MaxLabelWidth - BulletChart.XMarginHorizontalLeft - BulletChart.XMarginHorizontalRight) - BulletChart.ScrollBarSize), 
                        bulletModel.hasHighlights = !!(dataView.categorical.values.length > 0 && dataView.categorical.values[0].highlights);
                        for (var valueFormatString = valueFormatter.getFormatString(categorical.Value[0].source, properties.general.formatString), categoryFormatString = valueFormatter.getFormatString(categorical.Category.source, properties.general.formatString), _loop_1 = function(idx, length_1) {
                            var category = valueFormatter.format(categoricalValues.Category[idx], categoryFormatString);
                            category = TextMeasurementService.getTailoredTextOrDefault(BulletChart.getTextProperties(category, settings.labels.fontSize), BulletChart.MaxLabelWidth);
                            var toolTipItems = [], value = categoricalValues.Value[idx] || 0;
                            toolTipItems.push({
                                value: value,
                                metadata: categorical.Value[0]
                            });
                            var targetValue = categoricalValues.TargetValue ? categoricalValues.TargetValue[idx] : settings.values.targetValue;
                            _.isNumber(targetValue) && toolTipItems.push({
                                value: targetValue,
                                metadata: categorical.TargetValue[0]
                            });
                            var targetValue2 = categoricalValues.TargetValue2 ? categoricalValues.TargetValue2[idx] : settings.values.targetValue2;
                            _.isNumber(targetValue2) && toolTipItems.push({
                                value: targetValue2,
                                metadata: categorical.TargetValue2[0]
                            });
                            var getRangeValue = function(cValues, sValue) {
                                return cValues ? cValues[idx] : _.isNumber(targetValue) && _.isNumber(sValue) ? sValue * targetValue / 100 : null;
                            }, minimum = getRangeValue(categoricalValues.Minimum, settings.values.minimumPercent), needsImprovement = getRangeValue(categoricalValues.NeedsImprovement, settings.values.needsImprovementPercent), satisfactory = getRangeValue(categoricalValues.Satisfactory, settings.values.satisfactoryPercent), good = getRangeValue(categoricalValues.Good, settings.values.goodPercent), veryGood = getRangeValue(categoricalValues.VeryGood, settings.values.veryGoodPercent), maximum = getRangeValue(categoricalValues.Maximum, settings.values.maximumPercent), anyRangeIsDefined = [ needsImprovement, satisfactory, good, veryGood ].some(_.isNumber);
                            minimum = _.isNumber(minimum) ? Math.max(minimum, 0) : 0, needsImprovement = _.isNumber(needsImprovement) ? Math.max(minimum, needsImprovement) : needsImprovement, 
                            satisfactory = _.isNumber(satisfactory) ? Math.max(satisfactory, needsImprovement) : satisfactory, 
                            good = _.isNumber(good) ? Math.max(good, satisfactory) : good, veryGood = _.isNumber(veryGood) ? Math.max(veryGood, good) : veryGood;
                            var minMaxValue = _.max([ minimum, needsImprovement, satisfactory, good, veryGood, value, targetValue, targetValue2 ].filter(_.isNumber));
                            maximum = _.isNumber(maximum) ? Math.max(maximum, minMaxValue) : minMaxValue, veryGood = _.isNumber(veryGood) ? veryGood : maximum, 
                            good = _.isNumber(good) ? good : veryGood, satisfactory = _.isNumber(satisfactory) ? satisfactory : good, 
                            needsImprovement = _.isNumber(needsImprovement) ? needsImprovement : satisfactory;
                            var scale = d3.scale.linear().clamp(!0).domain([ minimum, maximum ]).range(verticalOrientation ? [ bulletModel.viewportLength, 0 ] : [ 0, bulletModel.viewportLength ]), firstScale = scale(minimum), secondScale = scale(needsImprovement), thirdScale = scale(satisfactory), fourthScale = scale(good), fifthScale = scale(veryGood), lastScale = scale(maximum), valueScale = scale(value), firstColor = settings.colors.minColor, secondColor = settings.colors.needsImprovementColor, thirdColor = settings.colors.satisfactoryColor, fourthColor = settings.colors.goodColor, lastColor = settings.colors.veryGoodColor, highlight = categorical.Value[0].highlights && null !== categorical.Value[0].highlights[idx];
                            anyRangeIsDefined && (BulletChart.addItemToBarArray(bulletModel.barRects, idx, firstScale, secondScale, firstColor, properties.general.formatString, toolTipItems, categorical.Category, idx, highlight), 
                            BulletChart.addItemToBarArray(bulletModel.barRects, idx, secondScale, thirdScale, secondColor, properties.general.formatString, toolTipItems, categorical.Category, idx, highlight), 
                            BulletChart.addItemToBarArray(bulletModel.barRects, idx, thirdScale, fourthScale, thirdColor, properties.general.formatString, toolTipItems, categorical.Category, idx, highlight), 
                            BulletChart.addItemToBarArray(bulletModel.barRects, idx, fourthScale, fifthScale, fourthColor, properties.general.formatString, toolTipItems, categorical.Category, idx, highlight), 
                            BulletChart.addItemToBarArray(bulletModel.barRects, idx, fifthScale, lastScale, lastColor, properties.general.formatString, toolTipItems, categorical.Category, idx, highlight)), 
                            BulletChart.addItemToBarArray(bulletModel.valueRects, idx, firstScale, valueScale, settings.colors.bulletColor, properties.general.formatString, toolTipItems, categorical.Category, idx, highlight), 
                            bulletModel.targetValues.push({
                                barIndex: idx,
                                value: targetValue && scale(targetValue),
                                fill: settings.colors.bulletColor,
                                key: SelectionIdBuilder.builder().withCategory(categorical.Category, idx).withMeasure(scale(targetValue || 0).toString()).createSelectionId().getKey(),
                                value2: targetValue2 && scale(targetValue2)
                            });
                            var xAxisProperties = null;
                            settings.axis.axis && (xAxisProperties = AxisHelper.createAxis({
                                pixelSpan: bulletModel.viewportLength,
                                dataDomain: scale.domain(),
                                metaDataColumn: categorical.Value[0].source,
                                formatString: valueFormatString,
                                outerPadding: 0,
                                isScalar: !0,
                                isVertical: verticalOrientation,
                                isCategoryAxis: !1,
                                scaleType: axisScale.linear
                            }));
                            var bar = {
                                scale: scale,
                                barIndex: idx,
                                categoryLabel: category,
                                x: verticalOrientation ? BulletChart.XMarginVertical + BulletChart.SpaceRequiredForBarVertically * idx : reversedOrientation ? BulletChart.XMarginHorizontalRight : BulletChart.XMarginHorizontalLeft,
                                y: verticalOrientation ? BulletChart.YMarginVertical : BulletChart.YMarginHorizontal + bulletModel.spaceRequiredForBarHorizontally * idx,
                                xAxisProperties: xAxisProperties,
                                key: SelectionIdBuilder.builder().withCategory(categorical.Category, idx).createSelectionId().getKey()
                            };
                            bulletModel.bars.push(bar);
                        }, idx = 0, length_1 = categoricalValues.Category.length; idx < length_1; idx++) _loop_1(idx, length_1);
                        return bulletModel;
                    }, BulletChart.parseSettings = function(dataView) {
                        var settings = BulletChartSettings.parse(dataView, BulletChart.capabilities);
                        settings.values.minimumPercent = Math.max(settings.values.minimumPercent, 0);
                        var minValue = settings.values.minimumPercent;
                        return settings.values.needsImprovementPercent = _.isNumber(settings.values.needsImprovementPercent) ? minValue = Math.max(minValue, settings.values.needsImprovementPercent) : settings.values.needsImprovementPercent, 
                        settings.values.satisfactoryPercent = _.isNumber(settings.values.satisfactoryPercent) ? minValue = Math.max(minValue, settings.values.satisfactoryPercent) : settings.values.satisfactoryPercent, 
                        settings.values.goodPercent = _.isNumber(settings.values.goodPercent) ? minValue = Math.max(minValue, settings.values.goodPercent) : settings.values.goodPercent, 
                        settings.values.veryGoodPercent = _.isNumber(settings.values.veryGoodPercent) ? minValue = Math.max(minValue, settings.values.veryGoodPercent) : settings.values.veryGoodPercent, 
                        settings.values.maximumPercent = _.isNumber(settings.values.maximumPercent) ? minValue = Math.max(minValue, settings.values.maximumPercent, 100) : settings.values.maximumPercent, 
                        settings.createOriginalSettings(), settings.axis.measureUnits = TextMeasurementService.getTailoredTextOrDefault(BulletChart.getTextProperties(settings.axis.measureUnits, BulletChart.DefaultSubtitleFontSizeInPt), BulletChart.MaxLabelWidth), 
                        settings;
                    }, BulletChart.addItemToBarArray = function(collection, barIndex, start, end, fill, formatString, tooltipInfo, column, index, highlight) {
                        isNaN(start) || isNaN(end) || collection.push({
                            barIndex: barIndex,
                            start: start,
                            end: end,
                            fill: fill,
                            tooltipInfo: TooltipBuilder.createTooltipInfo(formatString, null, null, null, null, tooltipInfo),
                            selected: !1,
                            identity: SelectionIdBuilder.builder().withCategory(column, index).createSelectionId(),
                            key: SelectionIdBuilder.builder().withCategory(column, index).withMeasure(start + " " + end).createSelectionId().getKey(),
                            highlight: highlight
                        });
                    }, BulletChart.prototype.init = function(options) {
                        var body = d3.select(options.element.get(0));
                        this.layout = new VisualLayout(options.viewport), this.hostService = options.host, 
                        this.bulletBody = body.append("div").classed("bulletChart", !0).attr("drag-resize-disabled", !0), 
                        this.scrollContainer = this.bulletBody.append("svg").classed("bullet-scroll-region", !0), 
                        this.clearCatcher = appendClearCatcher(this.scrollContainer), this.labelGraphicsContext = this.scrollContainer.append("g"), 
                        this.bulletGraphicsContext = this.scrollContainer.append("g"), this.behavior = new BulletWebBehavior(), 
                        this.interactivityService = createInteractivityService(options.host);
                    }, BulletChart.prototype.update = function(options) {
                        if (options.dataViews && options.dataViews[0]) {
                            var dataView = options.dataViews[0];
                            this.layout.viewport = options.viewport;
                            var data = BulletChart.converter(dataView, options);
                            this.ClearViewport(), data && (this.data = data, this.baselineDelta = TextMeasurementHelper.estimateSvgTextBaselineDelta(BulletChart.getTextProperties("1", this.data.settings.labels.fontSize)), 
                            this.interactivityService && this.interactivityService.applySelectionStateToData(this.data.barRects), 
                            this.bulletBody.style({
                                height: this.layout.viewportIn.height + "px",
                                width: this.layout.viewportIn.width + "px"
                            }), this.vertical ? this.scrollContainer.attr({
                                width: this.data.bars.length * BulletChart.SpaceRequiredForBarVertically + BulletChart.XMarginVertical + "px",
                                height: this.viewportScroll.height + "px"
                            }) : this.scrollContainer.attr({
                                height: this.data.bars.length * (this.data.spaceRequiredForBarHorizontally || 0) + "px",
                                width: this.viewportScroll.width + "px"
                            }), this.vertical ? this.setUpBulletsVertically(this.bulletBody, this.data, this.reverse) : this.setUpBulletsHorizontally(this.bulletBody, this.data, this.reverse), 
                            this.behavior.renderSelection(this.interactivityService.hasSelection()));
                        }
                    }, BulletChart.prototype.ClearViewport = function() {
                        this.labelGraphicsContext.selectAll("text").remove(), this.bulletGraphicsContext.selectAll("rect").remove(), 
                        this.bulletGraphicsContext.selectAll("text").remove(), this.bulletGraphicsContext.selectAll("axis").remove(), 
                        this.bulletGraphicsContext.selectAll("path").remove(), this.bulletGraphicsContext.selectAll("line").remove(), 
                        this.bulletGraphicsContext.selectAll("tick").remove(), this.bulletGraphicsContext.selectAll("g").remove();
                    }, BulletChart.prototype.onClearSelection = function() {
                        this.interactivityService && this.interactivityService.clearSelection();
                    }, BulletChart.prototype.calculateLabelWidth = function(barData, bar, reversed) {
                        return (reversed ? BulletChart.XMarginHorizontalRight : barData.x + BulletChart.MaxLabelWidth + BulletChart.XMarginHorizontalLeft) + (bar ? bar.start : 0);
                    }, BulletChart.prototype.calculateLabelHeight = function(barData, bar, reversed) {
                        return BulletChart.YMarginVertical + (reversed ? 5 : barData.y + this.data.labelHeightTop + BulletChart.BarMargin + BulletChart.SubtitleMargin) + (bar ? bar.end : 0);
                    }, BulletChart.prototype.setUpBulletsHorizontally = function(bulletBody, model, reveresed) {
                        var _this = this, bars = model.bars, rects = model.barRects, valueRects = model.valueRects, targetValues = model.targetValues, barSelection = this.labelGraphicsContext.selectAll("text").data(bars, function(d) {
                            return d.key;
                        }), rectSelection = this.bulletGraphicsContext.selectAll("rect.range").data(rects, function(d) {
                            return d.key;
                        }), bullets = rectSelection.enter().append("rect").attr({
                            x: function(d) {
                                return Math.max(0, _this.calculateLabelWidth(bars[d.barIndex], d, reveresed));
                            },
                            y: function(d) {
                                return Math.max(0, bars[d.barIndex].y - BulletChart.BulletSize / 2);
                            },
                            width: function(d) {
                                return Math.max(0, d.end - d.start);
                            },
                            height: BulletChart.BulletSize
                        }).classed("range", !0).style({
                            fill: function(d) {
                                return d.fill;
                            }
                        });
                        rectSelection.exit();
                        var valueSelection = this.bulletGraphicsContext.selectAll("rect.value").data(valueRects, function(d) {
                            return d.key;
                        });
                        if (valueSelection.enter().append("rect").attr({
                            x: function(d) {
                                return Math.max(0, _this.calculateLabelWidth(bars[d.barIndex], d, reveresed));
                            },
                            y: function(d) {
                                return Math.max(0, bars[d.barIndex].y - BulletChart.BulletSize / 8);
                            },
                            width: function(d) {
                                return Math.max(0, d.end - d.start);
                            },
                            height: 1 * BulletChart.BulletSize / 4
                        }).classed("value", !0).style({
                            fill: function(d) {
                                return d.fill;
                            }
                        }), valueSelection.exit(), this.drawFirstTargets(targetValues, function(d) {
                            return _this.calculateLabelWidth(bars[d.barIndex], null, reveresed) + d.value;
                        }, function(d) {
                            return _this.calculateLabelWidth(bars[d.barIndex], null, reveresed) + d.value;
                        }, function(d) {
                            return bars[d.barIndex].y - BulletChart.MarkerMarginHorizontal;
                        }, function(d) {
                            return bars[d.barIndex].y + BulletChart.MarkerMarginHorizontal;
                        }), this.drawSecondTargets(targetValues, function(d) {
                            return _this.calculateLabelWidth(bars[d.barIndex], null, reveresed) + d.value2;
                        }, function(d) {
                            return bars[d.barIndex].y;
                        }), model.settings.axis.axis) for (var _loop_2 = function() {
                            var bar = bars[idx], barGroup = this_1.bulletGraphicsContext.append("g");
                            barGroup.append("g").attr({
                                transform: function() {
                                    var xLocation = _this.calculateLabelWidth(bar, null, reveresed), yLocation = bar.y + BulletChart.BulletSize / 2;
                                    return "translate(" + xLocation + "," + yLocation + ")";
                                }
                            }).classed("axis", !0).call(bar.xAxisProperties.axis).style({
                                fill: model.settings.axis.axisColor,
                                "font-size": PixelConverter.fromPoint(BulletChart.AxisFontSizeInPt)
                            }).selectAll("line").style({
                                stroke: model.settings.axis.axisColor
                            }), barGroup.selectAll(".tick text").call(AxisHelper.LabelLayoutStrategy.clip, bar.xAxisProperties.xLabelMaxWidth, TextMeasurementService.svgEllipsis);
                        }, this_1 = this, idx = 0; idx < bars.length; idx++) _loop_2();
                        model.settings.labels.show && barSelection.enter().append("text").classed("title", !0).attr({
                            x: function(d) {
                                return reveresed ? BulletChart.XMarginHorizontalLeft + BulletChart.XMarginHorizontalRight + model.viewportLength : d.x;
                            },
                            y: function(d) {
                                return d.y + _this.baselineDelta;
                            },
                            fill: model.settings.labels.labelColor,
                            "font-size": PixelConverter.fromPoint(model.settings.labels.fontSize)
                        }).text(function(d) {
                            return d.categoryLabel;
                        });
                        var measureUnitsText = TextMeasurementService.getTailoredTextOrDefault(BulletChart.getTextProperties(model.settings.axis.measureUnits, BulletChart.DefaultSubtitleFontSizeInPt), BulletChart.MaxMeasureUnitWidth);
                        if (model.settings.axis.measureUnits && barSelection.enter().append("text").attr({
                            x: function(d) {
                                return reveresed ? BulletChart.XMarginHorizontalLeft + BulletChart.XMarginHorizontalRight + model.viewportLength + BulletChart.SubtitleMargin : d.x - BulletChart.SubtitleMargin;
                            },
                            y: function(d) {
                                return d.y + _this.data.labelHeight / 2 + 12;
                            },
                            fill: model.settings.axis.unitsColor,
                            "font-size": PixelConverter.fromPoint(BulletChart.DefaultSubtitleFontSizeInPt)
                        }).text(measureUnitsText), this.interactivityService) {
                            var behaviorOptions = {
                                rects: bullets,
                                valueRects: valueSelection,
                                clearCatcher: this.clearCatcher,
                                interactivityService: this.interactivityService,
                                bulletChartSettings: this.data.settings,
                                hasHighlights: this.data.hasHighlights
                            }, targetCollection = this.data.barRects.concat(this.data.valueRects);
                            this.interactivityService.bind(targetCollection, this.behavior, behaviorOptions);
                        }
                        barSelection.exit(), TooltipManager.addTooltip(valueSelection, function(tooltipEvent) {
                            return tooltipEvent.data.tooltipInfo;
                        }, !0), TooltipManager.addTooltip(rectSelection, function(tooltipEvent) {
                            return tooltipEvent.data.tooltipInfo;
                        }, !0);
                    }, BulletChart.prototype.setUpBulletsVertically = function(bulletBody, model, reveresed) {
                        var _this = this, bars = model.bars, rects = model.barRects, valueRects = model.valueRects, targetValues = model.targetValues, barSelection = this.labelGraphicsContext.selectAll("text").data(bars, function(d) {
                            return d.key;
                        }), rectSelection = this.bulletGraphicsContext.selectAll("rect.range").data(rects, function(d) {
                            return d.key;
                        }), bullets = rectSelection.enter().append("rect").attr({
                            x: function(d) {
                                return Math.max(0, bars[d.barIndex].x);
                            },
                            y: function(d) {
                                return Math.max(0, _this.calculateLabelHeight(bars[d.barIndex], d, reveresed));
                            },
                            height: function(d) {
                                return Math.max(0, d.start - d.end);
                            },
                            width: BulletChart.BulletSize
                        }).classed("range", !0).style({
                            fill: function(d) {
                                return d.fill;
                            }
                        });
                        rectSelection.exit();
                        var valueSelection = this.bulletGraphicsContext.selectAll("rect.value").data(valueRects, function(d) {
                            return d.key;
                        });
                        if (valueSelection.enter().append("rect").attr({
                            x: function(d) {
                                return Math.max(0, bars[d.barIndex].x + BulletChart.BulletSize / 3);
                            },
                            y: function(d) {
                                return Math.max(0, _this.calculateLabelHeight(bars[d.barIndex], d, reveresed));
                            },
                            height: function(d) {
                                return Math.max(0, d.start - d.end);
                            },
                            width: 1 * BulletChart.BulletSize / 4
                        }).classed("value", !0).style({
                            fill: function(d) {
                                return d.fill;
                            }
                        }), valueSelection.exit(), this.drawFirstTargets(targetValues, function(d) {
                            return bars[d.barIndex].x + BulletChart.MarkerMarginVertical;
                        }, function(d) {
                            return bars[d.barIndex].x + 3 * BulletChart.MarkerMarginVertical;
                        }, function(d) {
                            return _this.calculateLabelHeight(bars[d.barIndex], null, reveresed) + d.value;
                        }, function(d) {
                            return _this.calculateLabelHeight(bars[d.barIndex], null, reveresed) + d.value;
                        }), this.drawSecondTargets(targetValues, function(d) {
                            return bars[d.barIndex].x + BulletChart.BulletSize / 3 + BulletChart.BulletSize / 8;
                        }, function(d) {
                            return _this.calculateLabelHeight(bars[d.barIndex], null, reveresed) + d.value2;
                        }), model.settings.axis.axis) {
                            for (var idx = 0; idx < bars.length; idx++) {
                                var bar = bars[idx];
                                this.bulletGraphicsContext.append("g").attr({
                                    transform: function() {
                                        var xLocation = bar.x, yLocation = _this.calculateLabelHeight(bar, null, reveresed);
                                        return "translate(" + xLocation + "," + yLocation + ")";
                                    }
                                }).classed("axis", !0).call(bar.xAxisProperties.axis).style({
                                    fill: model.settings.axis.axisColor,
                                    "font-size": PixelConverter.fromPoint(BulletChart.AxisFontSizeInPt)
                                }).selectAll("line").style({
                                    stroke: model.settings.axis.axisColor
                                });
                            }
                            this.bulletGraphicsContext.selectAll("g.axis > .tick text").call(AxisHelper.LabelLayoutStrategy.clip, BulletChart.XMarginVertical - 10, TextMeasurementService.svgEllipsis);
                        }
                        var labelsStartPos = BulletChart.YMarginVertical + (reveresed ? model.viewportLength + 15 : 0) + this.data.labelHeightTop;
                        model.settings.labels.show && barSelection.enter().append("text").classed("title", !0).attr({
                            x: function(d) {
                                return d.x;
                            },
                            y: function(d) {
                                return labelsStartPos;
                            },
                            fill: model.settings.labels.labelColor,
                            "font-size": PixelConverter.fromPoint(model.settings.labels.fontSize)
                        }).text(function(d) {
                            return d.categoryLabel;
                        });
                        var measureUnitsText = TextMeasurementService.getTailoredTextOrDefault(BulletChart.getTextProperties(model.settings.axis.measureUnits, BulletChart.DefaultSubtitleFontSizeInPt), BulletChart.MaxMeasureUnitWidth);
                        if (model.settings.axis.measureUnits && barSelection.enter().append("text").attr({
                            x: function(d) {
                                return d.x + BulletChart.BulletSize;
                            },
                            y: function(d) {
                                return labelsStartPos + BulletChart.SubtitleMargin + 12;
                            },
                            fill: model.settings.axis.unitsColor,
                            "font-size": PixelConverter.fromPoint(BulletChart.DefaultSubtitleFontSizeInPt)
                        }).text(measureUnitsText), this.interactivityService) {
                            var behaviorOptions = {
                                rects: bullets,
                                valueRects: valueSelection,
                                clearCatcher: this.clearCatcher,
                                interactivityService: this.interactivityService,
                                bulletChartSettings: this.data.settings,
                                hasHighlights: !1
                            }, targetCollection = this.data.barRects.concat(this.data.valueRects);
                            this.interactivityService.bind(targetCollection, this.behavior, behaviorOptions);
                        }
                        barSelection.exit(), TooltipManager.addTooltip(valueSelection, function(tooltipEvent) {
                            return tooltipEvent.data.tooltipInfo;
                        }, !0), TooltipManager.addTooltip(rectSelection, function(tooltipEvent) {
                            return tooltipEvent.data.tooltipInfo;
                        }, !0);
                    }, BulletChart.prototype.drawFirstTargets = function(targetValues, x1, x2, y1, y2) {
                        var selection = this.bulletGraphicsContext.selectAll("line.target").data(targetValues.filter(function(x) {
                            return _.isNumber(x.value);
                        }));
                        selection.enter().append("line").attr({
                            x1: x1,
                            x2: x2,
                            y1: y1,
                            y2: y2
                        }).style({
                            stroke: function(d) {
                                return d.fill;
                            },
                            "stroke-width": 2
                        }).classed("target", !0), selection.exit().remove();
                    }, BulletChart.prototype.drawSecondTargets = function(targetValues, getX, getY) {
                        var selection = this.bulletGraphicsContext.selectAll("line.target2").data(targetValues.filter(function(x) {
                            return _.isNumber(x.value2);
                        })), enterSelection = selection.enter(), targetStyle = {
                            stroke: function(d) {
                                return d.fill;
                            },
                            "stroke-width": 2
                        };
                        enterSelection.append("line").attr({
                            x1: function(d) {
                                return getX(d) - BulletChart.SecondTargetLineSize;
                            },
                            y1: function(d) {
                                return getY(d) - BulletChart.SecondTargetLineSize;
                            },
                            x2: function(d) {
                                return getX(d) + BulletChart.SecondTargetLineSize;
                            },
                            y2: function(d) {
                                return getY(d) + BulletChart.SecondTargetLineSize;
                            }
                        }).style(targetStyle).classed("target2", !0), enterSelection.append("line").attr({
                            x1: function(d) {
                                return getX(d) + BulletChart.SecondTargetLineSize;
                            },
                            y1: function(d) {
                                return getY(d) - BulletChart.SecondTargetLineSize;
                            },
                            x2: function(d) {
                                return getX(d) - BulletChart.SecondTargetLineSize;
                            },
                            y2: function(d) {
                                return getY(d) + BulletChart.SecondTargetLineSize;
                            }
                        }).style(targetStyle).classed("target2", !0), selection.exit().remove();
                    }, BulletChart.prototype.destroy = function() {}, BulletChart.prototype.enumerateObjectInstances = function(options) {
                        if (this.settings) {
                            var enumeration = BulletChartSettings.enumerateObjectInstances(this.settings.originalSettings, options, BulletChart.capabilities);
                            return enumeration.complete();
                        }
                    }, BulletChart.ScrollBarSize = 22, BulletChart.SpaceRequiredForBarVertically = 100, 
                    BulletChart.XMarginHorizontalLeft = 20, BulletChart.XMarginHorizontalRight = 55, 
                    BulletChart.YMarginHorizontal = 30, BulletChart.XMarginVertical = 70, BulletChart.YMarginVertical = 10, 
                    BulletChart.BulletSize = 25, BulletChart.DefaultSubtitleFontSizeInPt = 9, BulletChart.BarMargin = 10, 
                    BulletChart.MaxLabelWidth = 80, BulletChart.MaxMeasureUnitWidth = BulletChart.MaxLabelWidth - 20, 
                    BulletChart.SubtitleMargin = 10, BulletChart.AxisFontSizeInPt = 8, BulletChart.SecondTargetLineSize = 7, 
                    BulletChart.MarkerMarginHorizontal = BulletChart.BulletSize / 3, BulletChart.MarkerMarginVertical = BulletChart.BulletSize / 4, 
                    BulletChart.FontFamily = "Segoe UI", BulletChart.capabilities = {
                        dataRoles: [ {
                            name: "Category",
                            kind: VisualDataRoleKind.Grouping,
                            displayName: "Category"
                        }, {
                            name: "Value",
                            kind: VisualDataRoleKind.Measure,
                            displayName: "Value"
                        }, {
                            name: "TargetValue",
                            kind: VisualDataRoleKind.Measure,
                            displayName: "Target Value"
                        }, {
                            name: "Minimum",
                            kind: VisualDataRoleKind.Measure,
                            displayName: "Minimum"
                        }, {
                            name: "NeedsImprovement",
                            kind: VisualDataRoleKind.Measure,
                            displayName: "Needs Improvement"
                        }, {
                            name: "Satisfactory",
                            kind: VisualDataRoleKind.Measure,
                            displayName: "Satisfactory"
                        }, {
                            name: "Good",
                            kind: VisualDataRoleKind.Measure,
                            displayName: "Good"
                        }, {
                            name: "VeryGood",
                            kind: VisualDataRoleKind.Measure,
                            displayName: "Very Good"
                        }, {
                            name: "Maximum",
                            kind: VisualDataRoleKind.Measure,
                            displayName: "Maximum"
                        }, {
                            name: "TargetValue2",
                            kind: VisualDataRoleKind.Measure,
                            displayName: "Target Value 2"
                        } ],
                        objects: {
                            general: {
                                displayName: "General",
                                properties: {
                                    formatString: {
                                        type: {
                                            formatting: {
                                                formatString: !0
                                            }
                                        }
                                    }
                                }
                            },
                            values: {
                                displayName: "Data values",
                                properties: {
                                    targetValue: {
                                        displayName: "Target Value",
                                        type: {
                                            numeric: !0
                                        }
                                    },
                                    targetValue2: {
                                        displayName: "Target Value 2",
                                        type: {
                                            numeric: !0
                                        }
                                    },
                                    minimumPercent: {
                                        displayName: "Minimum %",
                                        type: {
                                            numeric: !0
                                        }
                                    },
                                    needsImprovementPercent: {
                                        displayName: "Needs Improvement %",
                                        type: {
                                            numeric: !0
                                        }
                                    },
                                    satisfactoryPercent: {
                                        displayName: "Satisfactory %",
                                        type: {
                                            numeric: !0
                                        }
                                    },
                                    goodPercent: {
                                        displayName: "Good %",
                                        type: {
                                            numeric: !0
                                        }
                                    },
                                    veryGoodPercent: {
                                        displayName: "Very Good %",
                                        type: {
                                            numeric: !0
                                        }
                                    },
                                    maximumPercent: {
                                        displayName: "Maximum %",
                                        type: {
                                            numeric: !0
                                        }
                                    }
                                }
                            },
                            labels: {
                                displayName: "Category labels",
                                properties: {
                                    show: {
                                        displayName: "Show",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    labelColor: {
                                        displayName: "Color",
                                        description: "Select color for data labels",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    fontSize: {
                                        displayName: "Text Size",
                                        type: {
                                            formatting: {
                                                fontSize: !0
                                            }
                                        }
                                    }
                                }
                            },
                            orientation: {
                                displayName: "Orientation",
                                properties: {
                                    orientation: {
                                        displayName: "Orientation",
                                        type: {
                                            enumeration: BulletChartSettings.createEnumTypeFromEnum(BulletChartOrientation)
                                        }
                                    }
                                }
                            },
                            colors: {
                                displayName: "Colors",
                                properties: {
                                    minColor: {
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        },
                                        displayName: "Minimum Color"
                                    },
                                    needsImprovementColor: {
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        },
                                        displayName: "Needs Improvement Color"
                                    },
                                    satisfactoryColor: {
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        },
                                        displayName: "Satisfactory Color"
                                    },
                                    goodColor: {
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        },
                                        displayName: "Good Color"
                                    },
                                    veryGoodColor: {
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        },
                                        displayName: "Very Good Color"
                                    },
                                    bulletColor: {
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        },
                                        displayName: "Bullet Color"
                                    }
                                }
                            },
                            axis: {
                                displayName: "Axis",
                                properties: {
                                    axis: {
                                        displayName: "Axis",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    axisColor: {
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        },
                                        displayName: "Axis Color"
                                    },
                                    measureUnits: {
                                        type: {
                                            text: !0
                                        },
                                        displayName: "Measure Units "
                                    },
                                    unitsColor: {
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        },
                                        displayName: "Units Color"
                                    }
                                }
                            }
                        },
                        dataViewMappings: [ {
                            conditions: [ {
                                Category: {
                                    max: 1
                                },
                                Value: {
                                    max: 1
                                },
                                TargetValue: {
                                    max: 1
                                },
                                Minimum: {
                                    max: 1
                                },
                                NeedsImprovement: {
                                    max: 1
                                },
                                Satisfactory: {
                                    max: 1
                                },
                                Good: {
                                    max: 1
                                },
                                VeryGood: {
                                    max: 1
                                },
                                Maximum: {
                                    max: 1
                                },
                                TargetValue2: {
                                    max: 1
                                }
                            } ],
                            categorical: {
                                categories: {
                                    for: {
                                        in: "Category"
                                    },
                                    dataReductionAlgorithm: {
                                        top: {}
                                    }
                                },
                                values: {
                                    select: [ {
                                        bind: {
                                            to: "Value"
                                        }
                                    }, {
                                        bind: {
                                            to: "TargetValue"
                                        }
                                    }, {
                                        bind: {
                                            to: "TargetValue2"
                                        }
                                    }, {
                                        bind: {
                                            to: "Minimum"
                                        }
                                    }, {
                                        bind: {
                                            to: "NeedsImprovement"
                                        }
                                    }, {
                                        bind: {
                                            to: "Satisfactory"
                                        }
                                    }, {
                                        bind: {
                                            to: "Good"
                                        }
                                    }, {
                                        bind: {
                                            to: "VeryGood"
                                        }
                                    }, {
                                        bind: {
                                            to: "Maximum"
                                        }
                                    } ]
                                }
                            }
                        } ],
                        supportsHighlight: !0,
                        sorting: {
                            default: {}
                        },
                        drilldown: {
                            roles: [ "Category" ]
                        }
                    }, BulletChart;
                }();
                samples.BulletChart = BulletChart;
                var TextMeasurementHelper;
                !function(TextMeasurementHelper) {
                    function estimateSvgTextBaselineDelta(textProperties) {
                        var rect = estimateSvgTextRect(textProperties);
                        return rect.y + rect.height;
                    }
                    function ensureDOM() {
                        spanElement || (spanElement = $("<span/>"), $("body").append(spanElement), svgTextElement = d3.select($("body").get(0)).append("svg").style({
                            height: "0px",
                            width: "0px",
                            position: "absolute"
                        }).append("text"), canvasCtx = $("<canvas/>").get(0).getContext("2d"));
                    }
                    function measureSvgTextRect(textProperties) {
                        return ensureDOM(), svgTextElement.style(null), svgTextElement.text(textProperties.text).attr({
                            visibility: "hidden",
                            "font-family": textProperties.fontFamily,
                            "font-size": textProperties.fontSize,
                            "font-weight": textProperties.fontWeight,
                            "font-style": textProperties.fontStyle,
                            "white-space": textProperties.whiteSpace || "nowrap"
                        }), svgTextElement.node().getBBox();
                    }
                    function estimateSvgTextRect(textProperties) {
                        var estimatedTextProperties = {
                            fontFamily: textProperties.fontFamily,
                            fontSize: textProperties.fontSize,
                            text: "M"
                        }, rect = measureSvgTextRect(estimatedTextProperties);
                        return rect;
                    }
                    var spanElement, svgTextElement, canvasCtx;
                    TextMeasurementHelper.estimateSvgTextBaselineDelta = estimateSvgTextBaselineDelta;
                }(TextMeasurementHelper = samples.TextMeasurementHelper || (samples.TextMeasurementHelper = {}));
                var BulletWebBehavior = function() {
                    function BulletWebBehavior() {}
                    return BulletWebBehavior.getFillOpacity = function(selected, highlight, hasSelection, hasPartialHighlights) {
                        return hasPartialHighlights && !highlight || hasSelection && !selected ? BulletWebBehavior.DimmedOpacity : BulletWebBehavior.DefaultOpacity;
                    }, BulletWebBehavior.prototype.bindEvents = function(options, selectionHandler) {
                        this.options = options;
                        var clearCatcher = options.clearCatcher;
                        options.valueRects.on("click", function(d) {
                            selectionHandler.handleSelection(d, d3.event.ctrlKey);
                        }), options.rects.on("click", function(d) {
                            selectionHandler.handleSelection(d, d3.event.ctrlKey);
                        }), clearCatcher.on("click", function() {
                            selectionHandler.handleClearSelection();
                        });
                    }, BulletWebBehavior.prototype.renderSelection = function(hasSelection) {
                        var options = this.options, hasHighlights = options.hasHighlights;
                        options.valueRects.style("opacity", function(d) {
                            return BulletWebBehavior.getFillOpacity(d.selected, d.highlight, !d.highlight && hasSelection, !d.selected && hasHighlights);
                        }), options.rects.style("opacity", function(d) {
                            return BulletWebBehavior.getFillOpacity(d.selected, d.highlight, !d.highlight && hasSelection, !d.selected && hasHighlights);
                        });
                    }, BulletWebBehavior.DimmedOpacity = .4, BulletWebBehavior.DefaultOpacity = 1, BulletWebBehavior;
                }();
                samples.BulletWebBehavior = BulletWebBehavior;
            }(samples = visuals.samples || (visuals.samples = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi);
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var samples;
            !function(samples) {
                var ValueFormatter = powerbi.visuals.valueFormatter, getAnimationDuration = visuals.AnimatorCommon.GetAnimationDuration;
                !function(WordCloudScaleType) {
                    WordCloudScaleType[WordCloudScaleType.logn = 0] = "logn", WordCloudScaleType[WordCloudScaleType.sqrt = 1] = "sqrt", 
                    WordCloudScaleType[WordCloudScaleType.value = 2] = "value";
                }(samples.WordCloudScaleType || (samples.WordCloudScaleType = {}));
                var WordCloudScaleType = samples.WordCloudScaleType, ValueSelectionManager = function() {
                    function ValueSelectionManager(hostServices, getSelectionIds) {
                        this.selectedValuesValue = [], this.hostServices = hostServices, this.selectionManager = new visuals.utility.SelectionManager({
                            hostServices: hostServices
                        }), this.getSelectionIds = function(value) {
                            return _.isArray(value) ? _.flatten(value.map(function(x) {
                                return getSelectionIds(x);
                            })) : getSelectionIds(value);
                        };
                    }
                    return Object.defineProperty(ValueSelectionManager.prototype, "selectedValues", {
                        get: function() {
                            return this.selectedValuesValue;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(ValueSelectionManager.prototype, "selectionIds", {
                        get: function() {
                            return this.getSelectionIds(this.selectedValues);
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(ValueSelectionManager.prototype, "hasSelection", {
                        get: function() {
                            return this.selectedValues.length > 0;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(ValueSelectionManager.prototype, "getSelectionIdValues", {
                        get: function() {
                            var _this = this;
                            return this.selectedValues.map(function(v) {
                                return {
                                    value: v,
                                    selectionId: _this.getSelectionIds(v)
                                };
                            });
                        },
                        enumerable: !0,
                        configurable: !0
                    }), ValueSelectionManager.prototype.selectAndSendSelection = function(value, multiSelect) {
                        void 0 === multiSelect && (multiSelect = !1);
                        var values = _.isArray(value) ? value : [ value ];
                        return this.hostServices.shouldRetainSelection() ? this.sendSelectionToHost(this.getSelectionIds(values)) : (this.selectInternal(values, multiSelect), 
                        this.sendSelection());
                    }, ValueSelectionManager.prototype.select = function(value, multiSelect) {
                        void 0 === multiSelect && (multiSelect = !1);
                        var values = _.isArray(value) ? value : [ value ];
                        this.selectInternal(values, multiSelect);
                    }, ValueSelectionManager.prototype.isSelected = function(selectionId) {
                        var _this = this, values = _.isArray(selectionId) ? selectionId : [ selectionId ];
                        return values.every(function(v) {
                            return _this.selectedValues.some(function(s) {
                                return s === v;
                            });
                        });
                    }, ValueSelectionManager.prototype.sendSelection = function() {
                        return this.sendSelectionToHost(this.selectionIds);
                    }, ValueSelectionManager.prototype.clear = function(sendToHost) {
                        return this.selectedValues.length = 0, sendToHost ? this.sendSelection() : $.Deferred().resolve();
                    }, ValueSelectionManager.prototype.selectInternal = function(values, multiSelect) {
                        var _this = this, resultValues = [];
                        resultValues = this.isSelected(values) ? multiSelect ? this.selectedValues.filter(function(s) {
                            return !values.some(function(v) {
                                return v === s;
                            });
                        }) : this.selectedValues.length === values.length ? [] : values : multiSelect ? values.filter(function(x) {
                            return !_this.isSelected(x);
                        }).concat(this.selectedValues) : values, this.selectedValues.length = 0, resultValues.forEach(function(x) {
                            return _this.selectedValues.push(x);
                        });
                    }, ValueSelectionManager.prototype.sendSelectionToHost = function(ids) {
                        var deferred = $.Deferred();
                        return this.selectionManager.sendSelectionToHost(ids), deferred.resolve(this.selectionIds), 
                        deferred;
                    }, ValueSelectionManager;
                }(), VisualLayout = function() {
                    function VisualLayout(defaultViewport, defaultMargin) {
                        this.defaultViewport = defaultViewport || {
                            width: 0,
                            height: 0
                        }, this.defaultMargin = defaultMargin || {
                            top: 0,
                            bottom: 0,
                            right: 0,
                            left: 0
                        };
                    }
                    return Object.defineProperty(VisualLayout.prototype, "viewport", {
                        get: function() {
                            return this.viewportValue || (this.viewportValue = this.defaultViewport);
                        },
                        set: function(value) {
                            var _this = this;
                            this.previousOriginalViewportValue = _.clone(this.originalViewportValue), this.originalViewportValue = _.clone(value), 
                            this.setUpdateObject(value, function(v) {
                                return _this.viewportValue = v;
                            }, function(o) {
                                return VisualLayout.restrictToMinMax(o, _this.minViewport);
                            });
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(VisualLayout.prototype, "viewportCopy", {
                        get: function() {
                            return _.clone(this.viewport);
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(VisualLayout.prototype, "viewportIn", {
                        get: function() {
                            return this.viewportInValue || this.viewport;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(VisualLayout.prototype, "minViewport", {
                        get: function() {
                            return this.minViewportValue || {
                                width: 0,
                                height: 0
                            };
                        },
                        set: function(value) {
                            var _this = this;
                            this.setUpdateObject(value, function(v) {
                                return _this.minViewportValue = v;
                            }, VisualLayout.restrictToMinMax);
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(VisualLayout.prototype, "margin", {
                        get: function() {
                            return this.marginValue || (this.marginValue = this.defaultMargin);
                        },
                        set: function(value) {
                            var _this = this;
                            this.setUpdateObject(value, function(v) {
                                return _this.marginValue = v;
                            }, VisualLayout.restrictToMinMax);
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(VisualLayout.prototype, "viewportChanged", {
                        get: function() {
                            return !(!this.originalViewportValue || this.previousOriginalViewportValue && this.previousOriginalViewportValue.height === this.originalViewportValue.height && this.previousOriginalViewportValue.width === this.originalViewportValue.width);
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(VisualLayout.prototype, "viewportInIsZero", {
                        get: function() {
                            return 0 === this.viewportIn.width || 0 === this.viewportIn.height;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), VisualLayout.prototype.resetMargin = function() {
                        this.margin = this.defaultMargin;
                    }, VisualLayout.prototype.update = function() {
                        this.viewportInValue = VisualLayout.restrictToMinMax({
                            width: this.viewport.width - (this.margin.left + this.margin.right),
                            height: this.viewport.height - (this.margin.top + this.margin.bottom)
                        }, this.minViewportValue);
                    }, VisualLayout.prototype.setUpdateObject = function(object, setObjectFn, beforeUpdateFn) {
                        var _this = this;
                        object = _.clone(object), setObjectFn(VisualLayout.createNotifyChangedObject(object, function(o) {
                            beforeUpdateFn && beforeUpdateFn(object), _this.update();
                        })), beforeUpdateFn && beforeUpdateFn(object), this.update();
                    }, VisualLayout.createNotifyChangedObject = function(object, objectChanged) {
                        var result = {};
                        return _.keys(object).forEach(function(key) {
                            return Object.defineProperty(result, key, {
                                get: function() {
                                    return object[key];
                                },
                                set: function(value) {
                                    object[key] = value, objectChanged(object, key);
                                },
                                enumerable: !0,
                                configurable: !0
                            });
                        }), result;
                    }, VisualLayout.restrictToMinMax = function(value, minValue) {
                        return _.keys(value).forEach(function(x) {
                            return value[x] = Math.max(minValue && minValue[x] || 0, value[x]);
                        }), value;
                    }, VisualLayout;
                }(), WordCloudSettings = function() {
                    function WordCloudSettings() {
                        this.general = {
                            maxNumberOfWords: 200,
                            minFontSize: 20 / WordCloud.FontSizePercentageCoefficent,
                            maxFontSize: 100 / WordCloud.FontSizePercentageCoefficent,
                            isBrokenText: !0
                        }, this.stopWords = {
                            show: !0,
                            isDefaultStopWords: !1,
                            words: null
                        }, this.rotateText = {
                            show: !0,
                            minAngle: -60,
                            maxAngle: 90,
                            maxNumberOfOrientations: 2
                        };
                    }
                    return Object.defineProperty(WordCloudSettings, "Default", {
                        get: function() {
                            return new this();
                        },
                        enumerable: !0,
                        configurable: !0
                    }), WordCloudSettings.parse = function(dataView, capabilities) {
                        var settings = new this();
                        if (!dataView || !dataView.metadata || !dataView.metadata.objects) return settings;
                        var properties = this.getProperties(capabilities);
                        for (var objectKey in capabilities.objects) for (var propKey in capabilities.objects[objectKey].properties) if (settings[objectKey] && _.has(settings[objectKey], propKey)) {
                            var type = capabilities.objects[objectKey].properties[propKey].type, getValueFn = this.getValueFnByType(type);
                            settings[objectKey][propKey] = getValueFn(dataView.metadata.objects, properties[objectKey][propKey], settings[objectKey][propKey]);
                        }
                        return settings;
                    }, WordCloudSettings.getProperties = function(capabilities) {
                        var objects = _.merge({
                            general: {
                                properties: {
                                    formatString: {}
                                }
                            }
                        }, capabilities.objects), properties = {};
                        for (var objectKey in objects) {
                            properties[objectKey] = {};
                            for (var propKey in objects[objectKey].properties) properties[objectKey][propKey] = {
                                objectName: objectKey,
                                propertyName: propKey
                            };
                        }
                        return properties;
                    }, WordCloudSettings.createEnumTypeFromEnum = function(type) {
                        var even = !1;
                        return powerbi.createEnumType(Object.keys(type).filter(function(key, i) {
                            return !!(i % 2) === even && type[key] === key && !void (even = !even) || !!(i % 2) !== even;
                        }).map(function(x) {
                            return {
                                value: x,
                                displayName: x
                            };
                        }));
                    }, WordCloudSettings.getValueFnByType = function(type) {
                        switch (_.keys(type)[0]) {
                          case "fill":
                            return powerbi.DataViewObjects.getFillColor;

                          default:
                            return powerbi.DataViewObjects.getValue;
                        }
                    }, WordCloudSettings.enumerateObjectInstances = function(settings, options, capabilities) {
                        void 0 === settings && (settings = new this());
                        var enumeration = new visuals.ObjectEnumerationBuilder(), object = settings && settings[options.objectName];
                        if (!object) return enumeration;
                        var instance = {
                            objectName: options.objectName,
                            selector: null,
                            properties: {}
                        };
                        for (var key in object) _.has(object, key) && (instance.properties[key] = object[key]);
                        return enumeration.pushInstance(instance), enumeration;
                    }, WordCloudSettings.prototype.createOriginalSettings = function() {
                        this.originalSettings = _.cloneDeep(this);
                    }, WordCloudSettings;
                }();
                samples.WordCloudSettings = WordCloudSettings;
                var WordCloudColumns = function() {
                    function WordCloudColumns() {
                        this.Category = null, this.Values = null;
                    }
                    return WordCloudColumns.getColumnSources = function(dataView) {
                        return this.getColumnSourcesT(dataView);
                    }, WordCloudColumns.getTableValues = function(dataView) {
                        var table = dataView && dataView.table, columns = this.getColumnSourcesT(dataView);
                        return columns && table && _.mapValues(columns, function(n, i) {
                            return n && table.rows.map(function(row) {
                                return row[n.index];
                            });
                        });
                    }, WordCloudColumns.getTableRows = function(dataView) {
                        var table = dataView && dataView.table, columns = this.getColumnSourcesT(dataView);
                        return columns && table && table.rows.map(function(row) {
                            return _.mapValues(columns, function(n, i) {
                                return n && row[n.index];
                            });
                        });
                    }, WordCloudColumns.getCategoricalValues = function(dataView) {
                        var categorical = dataView && dataView.categorical, categories = categorical && categorical.categories || [], values = categorical && categorical.values || [], series = categorical && values.source && this.getSeriesValues(dataView);
                        return categorical && _.mapValues(new this(), function(n, i) {
                            return _.toArray(categories).concat(_.toArray(values)).filter(function(x) {
                                return x.source.roles && x.source.roles[i];
                            }).map(function(x) {
                                return x.values;
                            })[0] || values.source && values.source.roles && values.source.roles[i] && series;
                        });
                    }, WordCloudColumns.getSeriesValues = function(dataView) {
                        return dataView && dataView.categorical && dataView.categorical.values && dataView.categorical.values.map(function(x) {
                            return visuals.converterHelper.getSeriesName(x.source);
                        });
                    }, WordCloudColumns.getCategoricalColumns = function(dataView) {
                        var categorical = dataView && dataView.categorical, categories = categorical && categorical.categories || [], values = categorical && categorical.values || [];
                        return categorical && _.mapValues(new this(), function(n, i) {
                            return categories.filter(function(x) {
                                return x.source.roles && x.source.roles[i];
                            })[0] || values.source && values.source.roles && values.source.roles[i] && values || values.filter(function(x) {
                                return x.source.roles && x.source.roles[i];
                            });
                        });
                    }, WordCloudColumns.getColumnSourcesT = function(dataView) {
                        var columns = dataView && dataView.metadata && dataView.metadata.columns;
                        return columns && _.mapValues(new this(), function(n, i) {
                            return columns.filter(function(x) {
                                return x.roles && x.roles[i];
                            })[0];
                        });
                    }, WordCloudColumns.Roles = Object.freeze(_.mapValues(new WordCloudColumns(), function(x, i) {
                        return i;
                    })), WordCloudColumns;
                }();
                samples.WordCloudColumns = WordCloudColumns;
                var WordCloud = function() {
                    function WordCloud(options) {
                        this.durationAnimations = 500, this.fakeViewport = {
                            width: 1500,
                            height: 1e3
                        }, this.canvasViewport = {
                            width: 128,
                            height: 2048
                        }, options && (this.svg = options.svg || this.svg, this.layout = new VisualLayout(null, options.margin || WordCloud.DefaultMargin), 
                        options.animator && (this.animator = options.animator)), this.isUpdating = !1;
                    }
                    return WordCloud.converter = function(dataView, colors, previousData) {
                        var categorical = WordCloudColumns.getCategoricalColumns(dataView);
                        if (!categorical || !categorical.Category || _.isEmpty(categorical.Category.values)) return null;
                        var catValues = WordCloudColumns.getCategoricalValues(dataView), properties = WordCloudSettings.getProperties(WordCloud.capabilities), settings = WordCloud.parseSettings(dataView, previousData && previousData.settings), wordValueFormatter = ValueFormatter.create({
                            format: ValueFormatter.getFormatString(categorical.Category.source, properties.general.formatString)
                        }), stopWords = _.isString(settings.stopWords.words) ? settings.stopWords.words.split(WordCloud.StopWordsDelemiter) : [];
                        stopWords = settings.stopWords.isDefaultStopWords ? stopWords.concat(WordCloud.StopWords) : stopWords;
                        var colorHelper = new visuals.ColorHelper(colors, properties.dataPoint.fill, explore.util.getRandomColor()), texts = catValues.Category.filter(function(x) {
                            return null !== x && void 0 !== x && x.toString().length > 0;
                        }).map(function(item, index) {
                            var color;
                            color = categorical.Category.objects && categorical.Category.objects[index] ? explore.util.hexToRgb(colorHelper.getColorForMeasure(categorical.Category.objects[index], "")) : previousData && previousData.texts && previousData.texts[index] ? previousData.texts[index].color : explore.util.getRandomColor();
                            var selectionId = new visuals.SelectionIdBuilder().withCategory(dataView.categorical.categories[0], index).createSelectionId();
                            return item = wordValueFormatter.format(item), {
                                text: item,
                                count: catValues.Values && catValues.Values[index] && !isNaN(catValues.Values[index]) ? catValues.Values[index] : 1,
                                index: index,
                                selectionId: selectionId,
                                color: color,
                                textGroup: item
                            };
                        }), reducedTexts = WordCloud.getReducedText(texts, stopWords, settings), dataPoints = WordCloud.getDataPoints(reducedTexts, settings);
                        return {
                            dataView: dataView,
                            settings: settings,
                            texts: texts,
                            dataPoints: dataPoints
                        };
                    }, WordCloud.parseSettings = function(dataView, previousSettings) {
                        var settings = WordCloudSettings.parse(dataView, WordCloud.capabilities);
                        return settings.general.minFontSize = Math.max(settings.general.minFontSize, 1), 
                        settings.general.maxFontSize = Math.max(settings.general.maxFontSize, 1), settings.general.maxFontSize = Math.max(settings.general.maxFontSize, settings.general.minFontSize), 
                        settings.rotateText.minAngle = Math.max(Math.min(settings.rotateText.minAngle, WordCloud.MaxAngle), WordCloud.MinAngle), 
                        settings.rotateText.maxAngle = Math.max(Math.min(settings.rotateText.maxAngle, WordCloud.MaxAngle), WordCloud.MinAngle), 
                        settings.rotateText.maxAngle = Math.max(settings.rotateText.maxAngle, settings.rotateText.minAngle), 
                        settings.general.maxNumberOfWords = Math.max(Math.min(settings.general.maxNumberOfWords, WordCloud.MaxNumberOfWords), 1), 
                        settings.rotateText.maxNumberOfOrientations = Math.max(Math.min(settings.rotateText.maxNumberOfOrientations, WordCloud.MaxNumberOfWords), 1), 
                        settings.createOriginalSettings(), settings;
                    }, WordCloud.getReducedText = function(texts, stopWords, settings) {
                        var brokenStrings = WordCloud.getBrokenWords(texts, stopWords, settings), result = _.values(_.groupBy(brokenStrings, function(x) {
                            return x.text;
                        }));
                        return result = result.map(function(texts) {
                            return _.sortBy(texts, function(x) {
                                return x.textGroup.length;
                            });
                        });
                    }, WordCloud.getBrokenWords = function(words, stopWords, settings) {
                        var brokenStrings = [], whiteSpaceRegExp = /\s/, punctuatuinRegExp = new RegExp("[" + WordCloud.Punctuation.join("\\") + "]", "gim");
                        return settings.general.isBrokenText ? (words.forEach(function(item) {
                            if ("string" == typeof item.text) {
                                var splittedWords = item.text.replace(punctuatuinRegExp, " ").split(whiteSpaceRegExp);
                                settings.stopWords.show && (splittedWords = splittedWords.filter(function(value) {
                                    return value.length > 0 && !stopWords.some(function(removeWord) {
                                        return value.toLocaleLowerCase() === removeWord.toLocaleLowerCase();
                                    });
                                })), splittedWords.forEach(function(splittedWord) {
                                    if (0 !== splittedWord.length && !whiteSpaceRegExp.test(splittedWord)) {
                                        var existingWord = _.find(words, function(w) {
                                            return w.text.toString().toLocaleLowerCase() === splittedWord.toLocaleLowerCase();
                                        });
                                        existingWord && existingWord !== item && (splittedWord = existingWord.text), brokenStrings.push({
                                            text: splittedWord,
                                            textGroup: item.textGroup,
                                            count: item.count,
                                            index: item.index,
                                            selectionId: item.selectionId,
                                            color: item.color
                                        });
                                    }
                                });
                            } else brokenStrings.push(item);
                        }), brokenStrings) : words;
                    }, WordCloud.getDataPoints = function(textGroups, settings) {
                        if (_.isEmpty(textGroups)) return [];
                        var returnValues = textGroups.map(function(values) {
                            return {
                                text: values[0].text,
                                x: 0,
                                y: 0,
                                rotate: WordCloud.getAngle(settings),
                                padding: 1,
                                width: 0,
                                height: 0,
                                xOff: 0,
                                yOff: 0,
                                x0: 0,
                                y0: 0,
                                x1: 0,
                                y1: 0,
                                color: values[0].color,
                                selectionIds: values.map(function(x) {
                                    return x.selectionId;
                                }),
                                wordIndex: values[0].index,
                                count: _.sum(values, function(x) {
                                    return x.count;
                                })
                            };
                        }), minValue = _.min(returnValues, function(x) {
                            return x.count;
                        }).count, maxValue = _.max(returnValues, function(x) {
                            return x.count;
                        }).count, texts = textGroups.map(function(x) {
                            return x[0];
                        });
                        return returnValues.forEach(function(x) {
                            return x.size = WordCloud.getWordFontSize(texts, settings, x.count, minValue, maxValue);
                        }), returnValues.sort(function(a, b) {
                            return b.count - a.count;
                        });
                    }, WordCloud.getWordFontSize = function(texts, settings, value, minValue, maxValue, scaleType) {
                        void 0 === scaleType && (scaleType = WordCloudScaleType.value);
                        var weight, fontSize, minFontSize = settings.general.minFontSize * WordCloud.FontSizePercentageCoefficent, maxFontSize = settings.general.maxFontSize * WordCloud.FontSizePercentageCoefficent;
                        if (texts.length < 2) return maxFontSize;
                        switch (scaleType) {
                          case WordCloudScaleType.logn:
                            weight = Math.log(value);

                          case WordCloudScaleType.sqrt:
                            weight = Math.sqrt(value);

                          case WordCloudScaleType.value:
                            weight = value;
                        }
                        return fontSize = weight > minValue && maxValue - minValue !== 0 ? maxFontSize * (weight - minValue) / (maxValue - minValue) : 0, 
                        fontSize = 100 * fontSize / maxFontSize, fontSize = fontSize * (maxFontSize - minFontSize) / 100 + minFontSize;
                    }, WordCloud.getAngle = function(settings) {
                        if (!settings.rotateText.show) return 0;
                        var angle = (settings.rotateText.maxAngle - settings.rotateText.minAngle) / settings.rotateText.maxNumberOfOrientations * Math.floor(Math.random() * settings.rotateText.maxNumberOfOrientations);
                        return settings.rotateText.minAngle + angle;
                    }, Object.defineProperty(WordCloud.prototype, "settings", {
                        get: function() {
                            return this.data && this.data.settings;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), WordCloud.prototype.init = function(options) {
                        var _this = this;
                        this.svg ? this.root = this.svg : this.root = d3.select(options.element.get(0)).append("svg"), 
                        this.colors = options.style.colorPalette.dataColors, this.hostService = options.host, 
                        this.selectionManager = new ValueSelectionManager(this.hostService, function(w) {
                            var dataPoints = _this.data && _this.data.dataPoints && _this.data.dataPoints.filter(function(x) {
                                return x.text === w;
                            });
                            return dataPoints && dataPoints[0] && dataPoints[0].selectionIds;
                        }), this.layout = new VisualLayout(null, WordCloud.DefaultMargin), this.root.classed(WordCloud.ClassName, !0), 
                        this.root.on("click", function() {
                            _this.setSelection(null);
                        }), this.fontFamily = this.root.style("font-family"), this.main = this.root.append("g"), 
                        this.wordsContainerSelection = this.main.append("g").classed(WordCloud.Words.class, !0), 
                        this.canvas = document.createElement("canvas");
                    }, WordCloud.prototype.update = function(visualUpdateOptions) {
                        var _this = this;
                        if (visualUpdateOptions && visualUpdateOptions.viewport && visualUpdateOptions.dataViews && visualUpdateOptions.dataViews[0] && visualUpdateOptions.viewport && visualUpdateOptions.viewport.height >= 0 && visualUpdateOptions.viewport.width >= 0 && (visualUpdateOptions !== this.visualUpdateOptions && (this.incomingUpdateOptions = visualUpdateOptions), 
                        !this.isUpdating && this.incomingUpdateOptions !== this.visualUpdateOptions)) {
                            this.visualUpdateOptions = this.incomingUpdateOptions, this.layout.viewport = this.visualUpdateOptions.viewport;
                            var dataView = visualUpdateOptions.dataViews[0];
                            if (this.layout.viewportInIsZero) return;
                            this.durationAnimations = getAnimationDuration(this.animator, visualUpdateOptions.suppressAnimations), 
                            this.UpdateSize();
                            var data = WordCloud.converter(dataView, this.colors, this.data);
                            if (!data) return void this.clear();
                            this.data = data, this.computePositions(function(wordCloudDataView) {
                                return _this.render(wordCloudDataView);
                            });
                        }
                    }, WordCloud.prototype.clear = function() {
                        this.main.select(WordCloud.Words.selector).selectAll(WordCloud.WordGroup.selector).remove();
                    }, WordCloud.prototype.computePositions = function(onPositionsComputed) {
                        var _this = this, words = this.data.dataPoints;
                        return _.isEmpty(words) ? void this.clear() : void requestAnimationFrame(function() {
                            var surface = _.range(0, (_this.specialViewport.width >> 5) * _this.specialViewport.height, 0);
                            words.forEach(function(data) {
                                data.getWidthOfWord = function() {
                                    return data.widthOfWord || (data.widthOfWord = powerbi.TextMeasurementService.measureSvgTextWidth({
                                        fontFamily: _this.fontFamily,
                                        fontSize: data.size + 1 + WordCloud.Size,
                                        text: data.text
                                    }) + 2);
                                };
                            }), _this.computeCycle(words, _this.getCanvasContext(), surface, null, onPositionsComputed, [], 0);
                        });
                    }, WordCloud.prototype.computeCycle = function(words, context, surface, borders, onPositionsComputed, wordsForDraw, index) {
                        void 0 === wordsForDraw && (wordsForDraw = []), void 0 === index && (index = 0);
                        var word = words[index], ratio = 1;
                        words.length <= 10 ? ratio = 5 : words.length <= 25 ? ratio = 3 : words.length <= 75 ? ratio = 1.5 : words.length <= 100 && (ratio = 1.25), 
                        word.x = this.specialViewport.width / ratio * (Math.random() + .5) >> 1, word.y = this.specialViewport.height / ratio * (Math.random() + .5) >> 1, 
                        word.sprite || this.generateSprites(context, words, index), word.sprite && this.findPosition(surface, word, borders) && (wordsForDraw.push(word), 
                        borders = this.updateBorders(word, borders), word.x -= this.specialViewport.width >> 1, 
                        word.y -= this.specialViewport.height >> 1, wordsForDraw.length >= this.settings.general.maxNumberOfWords && (index = words.length - 1)), 
                        ++index < words.length && this.root ? this.computeCycle(words, context, surface, borders, onPositionsComputed, wordsForDraw, index) : onPositionsComputed({
                            data: wordsForDraw,
                            leftBorder: borders && borders[0],
                            rightBorder: borders && borders[1]
                        });
                    }, WordCloud.prototype.updateBorders = function(word, borders) {
                        if (borders && 2 === borders.length) {
                            var leftBorder = borders[0], rightBorder = borders[1];
                            word.x + word.x0 < leftBorder.x && (leftBorder.x = word.x + word.x0), word.y + word.y0 < leftBorder.y && (leftBorder.y = word.y + word.y0), 
                            word.x + word.x1 > rightBorder.x && (rightBorder.x = word.x + word.x1), word.y + word.y1 > rightBorder.y && (rightBorder.y = word.y + word.y1);
                        } else borders = [ {
                            x: word.x + word.x0,
                            y: word.y + word.y0
                        }, {
                            x: word.x + word.x1,
                            y: word.y + word.y1
                        } ];
                        return borders;
                    }, WordCloud.prototype.generateSprites = function(context, words, startIndex) {
                        context.clearRect(0, 0, this.canvasViewport.width << 5, this.canvasViewport.height);
                        for (var x = 0, y = 0, maxHeight = 0, i = startIndex, length = words.length; i < length; i++) {
                            var currentWordData = words[i], widthOfWord = currentWordData.getWidthOfWord(), heightOfWord = currentWordData.size << 1;
                            if (currentWordData.rotate) {
                                var sr = Math.sin(currentWordData.rotate * WordCloud.Radians), cr = Math.cos(currentWordData.rotate * WordCloud.Radians), widthCr = widthOfWord * cr, widthSr = widthOfWord * sr, heightCr = heightOfWord * cr, heightSr = heightOfWord * sr;
                                widthOfWord = Math.max(Math.abs(widthCr + heightSr), Math.abs(widthCr - heightSr)) + 31 >> 5 << 5, 
                                heightOfWord = Math.floor(Math.max(Math.abs(widthSr + heightCr), Math.abs(widthSr - heightCr)));
                            } else widthOfWord = widthOfWord + 31 >> 5 << 5;
                            heightOfWord > maxHeight && (maxHeight = heightOfWord), x + widthOfWord >= this.canvasViewport.width << 5 && (x = 0, 
                            y += maxHeight, maxHeight = 0), context.save(), context.font = "normal normal " + (currentWordData.size + 1) + WordCloud.Size + " " + this.fontFamily, 
                            context.translate(x + (widthOfWord >> 1), y + (heightOfWord >> 1)), currentWordData.rotate && context.rotate(currentWordData.rotate * WordCloud.Radians), 
                            context.fillText(currentWordData.text, 0, 0), currentWordData.padding && (context.lineWidth = 2 * currentWordData.padding, 
                            context.strokeText(currentWordData.text, 0, 0)), context.restore(), currentWordData.width = widthOfWord, 
                            currentWordData.height = heightOfWord, currentWordData.xOff = x, currentWordData.yOff = y, 
                            currentWordData.x1 = widthOfWord >> 1, currentWordData.y1 = heightOfWord >> 1, currentWordData.x0 = -currentWordData.x1, 
                            currentWordData.y0 = -currentWordData.y1, x += widthOfWord;
                        }
                        this.setSprites(context, words);
                    }, WordCloud.prototype.setSprites = function(context, words) {
                        for (var pixels = context.getImageData(0, 0, this.canvasViewport.width << 5, this.canvasViewport.height).data, sprites = [], i = words.length - 1; i >= 0; i--) {
                            var currentWordData = words[i], width = currentWordData.width, width32 = width >> 5, height = currentWordData.y1 - currentWordData.y0, x = 0, y = 0, seen = 0, seenRow = 0;
                            if (currentWordData.xOff + width >= this.canvasViewport.width << 5 || currentWordData.yOff + height >= this.canvasViewport.height) currentWordData.sprite = null; else {
                                for (var j = 0; j < height * width32; j++) sprites[j] = 0;
                                if (null === currentWordData.xOff) return;
                                x = currentWordData.xOff, y = currentWordData.yOff, seen = 0, seenRow = -1;
                                for (var j = 0; j < height; j++) {
                                    for (var k = 0; k < width; k++) {
                                        var l = width32 * j + (k >> 5), index = (y + j) * (this.canvasViewport.width << 5) + (x + k) << 2, m = pixels[index] ? 1 << 31 - k % 32 : 0;
                                        sprites[l] |= m, seen |= m;
                                    }
                                    seen ? seenRow = j : (currentWordData.y0++, height--, j--, y++);
                                }
                                currentWordData.y1 = currentWordData.y0 + seenRow, currentWordData.sprite = sprites.slice(0, (currentWordData.y1 - currentWordData.y0) * width32);
                            }
                        }
                    }, WordCloud.prototype.findPosition = function(surface, word, borders) {
                        for (var point, dx, dy, startPoint = {
                            x: word.x,
                            y: word.y
                        }, delta = Math.sqrt(this.specialViewport.width * this.specialViewport.width + this.specialViewport.height * this.specialViewport.height), dt = Math.random() < .5 ? 1 : -1, shift = -dt; ;) {
                            if (shift += dt, point = this.archimedeanSpiral(shift), dx = Math.floor(point.x), 
                            dy = Math.floor(point.y), Math.min(Math.abs(dx), Math.abs(dy)) >= delta) break;
                            if (word.x = startPoint.x + dx, word.y = startPoint.y + dy, !(word.x + word.x0 < 0 || word.y + word.y0 < 0 || word.x + word.x1 > this.specialViewport.width || word.y + word.y1 > this.specialViewport.height) && (!borders || !this.checkIntersect(word, surface)) && (!borders || this.checkIntersectOfRectangles(word, borders[0], borders[1]))) {
                                for (var sprite = word.sprite, width = word.width >> 5, shiftWidth = this.specialViewport.width >> 5, lx = word.x - (width << 4), sx = 127 & lx, msx = 32 - sx, height = word.y1 - word.y0, x = (word.y + word.y0) * shiftWidth + (lx >> 5), i = 0; i < height; i++) {
                                    for (var lastSprite = 0, j = 0; j <= width; j++) {
                                        var rightMask, leftMask = lastSprite << msx;
                                        j < width && (lastSprite = sprite[i * width + j]), rightMask = j < width ? lastSprite >>> sx : 0, 
                                        surface[x + j] |= leftMask | rightMask;
                                    }
                                    x += shiftWidth;
                                }
                                return word.sprite = null, !0;
                            }
                        }
                        return !1;
                    }, WordCloud.prototype.archimedeanSpiral = function(value) {
                        var ratio = this.specialViewport.width / this.specialViewport.height;
                        return value = .1 * value, {
                            x: ratio * value * Math.cos(value),
                            y: value * Math.sin(value)
                        };
                    }, WordCloud.prototype.checkIntersect = function(word, surface) {
                        for (var shiftWidth = this.specialViewport.width >> 5, sprite = word.sprite, widthOfWord = word.width >> 5, lx = word.x - (widthOfWord << 4), sx = 127 & lx, msx = 32 - sx, heightOfWord = word.y1 - word.y0, x = (word.y + word.y0) * shiftWidth + (lx >> 5), i = 0; i < heightOfWord; i++) {
                            for (var lastSprite = 0, j = 0; j <= widthOfWord; j++) {
                                var leftMask, mask = 0, intersectMask = 0;
                                if (leftMask = lastSprite << msx, j < widthOfWord && (lastSprite = sprite[i * widthOfWord + j]), 
                                mask = j < widthOfWord ? lastSprite >>> sx : 0, intersectMask = (leftMask | mask) & surface[x + j]) return !0;
                            }
                            x += shiftWidth;
                        }
                        return !1;
                    }, WordCloud.prototype.checkIntersectOfRectangles = function(word, leftBorder, rightBorder) {
                        return word.x + word.x1 > leftBorder.x && word.x + word.x0 < rightBorder.x && word.y + word.y1 > leftBorder.y && word.y + word.y0 < rightBorder.y;
                    }, WordCloud.prototype.getCanvasContext = function() {
                        if (!this.canvasViewport) return null;
                        this.canvas.width = 1, this.canvas.height = 1;
                        var context = this.canvas.getContext("2d");
                        return this.canvas.width = this.canvasViewport.width << 5, this.canvas.height = this.canvasViewport.height, 
                        context = this.canvas.getContext("2d"), context.fillStyle = context.strokeStyle = "red", 
                        context.textAlign = "center", context;
                    }, WordCloud.prototype.UpdateSize = function() {
                        var fakeWidth, fakeHeight, ratio;
                        ratio = Math.sqrt(this.fakeViewport.width * this.fakeViewport.height / (this.layout.viewportIn.width * this.layout.viewportIn.height)), 
                        isNaN(ratio) ? fakeHeight = fakeWidth = 1 : (fakeHeight = this.layout.viewportIn.height * ratio, 
                        fakeWidth = this.layout.viewportIn.width * ratio), this.specialViewport = {
                            height: fakeHeight,
                            width: fakeWidth
                        }, this.root.attr({
                            height: this.layout.viewport.height,
                            width: this.layout.viewport.width
                        });
                    }, WordCloud.prototype.render = function(wordCloudDataView) {
                        var _this = this;
                        if (wordCloudDataView && wordCloudDataView.data) {
                            this.scaleMainView(wordCloudDataView), this.wordsGroupUpdateSelection = this.main.select(WordCloud.Words.selector).selectAll("g").data(wordCloudDataView.data);
                            var wordGroupEnterSelection = this.wordsGroupUpdateSelection.enter().append("svg:g").classed(WordCloud.WordGroup.class, !0);
                            wordGroupEnterSelection.append("svg:text").style("font-size", "1px").attr("pointer-events", "none"), 
                            wordGroupEnterSelection.append("svg:rect"), this.wordsGroupUpdateSelection.exit().remove(), 
                            this.wordsGroupUpdateSelection.attr("transform", function(d) {
                                return visuals.SVGUtil.translate(d.x, d.y) + " rotate(" + d.rotate + ")";
                            }).sort(function(a, b) {
                                return b.height * b.width - a.height * a.width;
                            }), this.wordsTextUpdateSelection = this.wordsGroupUpdateSelection.selectAll("text").data(function(d) {
                                return [ d ];
                            }), this.wordsTextUpdateSelection.text(function(d) {
                                return d.text;
                            }), this.animation(this.wordsTextUpdateSelection, this.durationAnimations).style({
                                "font-size": function(item) {
                                    return "" + item.size + WordCloud.Size;
                                },
                                fill: function(item) {
                                    return item.color;
                                }
                            }), this.wordsGroupUpdateSelection.selectAll("rect").data(function(d) {
                                return [ d ];
                            }).attr({
                                x: function(d) {
                                    return .5 * -d.getWidthOfWord();
                                },
                                width: function(d) {
                                    return d.getWidthOfWord();
                                },
                                y: function(d) {
                                    return .75 * -d.size;
                                },
                                height: function(d) {
                                    return .85 * d.size;
                                },
                                fill: function(d) {
                                    return "rgba(63, 191, 191, 0.0)";
                                }
                            }).on("click", function(d) {
                                _this.setSelection(d), d3.event.stopPropagation();
                            }), this.clearIntorrectSelection(this.data.dataView), this.renderSelection(), this.isUpdating = !1, 
                            this.incomingUpdateOptions !== this.visualUpdateOptions && this.update(this.incomingUpdateOptions);
                        }
                    }, WordCloud.prototype.clearIntorrectSelection = function(dataView) {
                        var _this = this, categories = dataView && dataView.categorical && dataView.categorical.categories, identityKeys = categories && categories[0] && categories[0].identity && categories[0].identity.map(function(x) {
                            return x.key;
                        }), oldIdentityKeys = this.oldIdentityKeys;
                        if (this.oldIdentityKeys = identityKeys, oldIdentityKeys && oldIdentityKeys.length > identityKeys.length) return void this.selectionManager.clear(!1);
                        if (!_.isEmpty(identityKeys)) {
                            var incorrectValues = this.selectionManager.getSelectionIdValues.filter(function(x) {
                                return x.selectionId.some(function(s) {
                                    return _.contains(identityKeys, s.getKey());
                                });
                            });
                            incorrectValues.forEach(function(v) {
                                return _this.selectionManager.selectedValues.splice(_this.selectionManager.selectedValues.indexOf(v.value), 1);
                            });
                        }
                    }, WordCloud.prototype.setSelection = function(dataPoint) {
                        var _this = this;
                        return dataPoint ? void this.selectionManager.selectAndSendSelection(dataPoint.text, d3.event.ctrlKey).then(function() {
                            return _this.renderSelection();
                        }) : void this.selectionManager.clear(!0).then(function() {
                            return _this.renderSelection();
                        });
                    }, WordCloud.prototype.scaleMainView = function(wordCloudDataView) {
                        var rectangles = wordCloudDataView.data.map(function(d) {
                            var hw = d.width / 2, hh = d.height / 2;
                            return {
                                left: d.x - hw,
                                top: d.y - hh,
                                right: d.x + hw,
                                bottom: d.y + hh
                            };
                        });
                        if (!_.isEmpty(rectangles)) {
                            var rectangle = {
                                left: _.min(rectangles, function(x) {
                                    return x.left;
                                }).left,
                                top: _.min(rectangles, function(x) {
                                    return x.top;
                                }).top,
                                right: _.max(rectangles, function(x) {
                                    return x.right;
                                }).right,
                                bottom: _.max(rectangles, function(x) {
                                    return x.bottom;
                                }).bottom
                            };
                            rectangle.width = rectangle.right - rectangle.left, rectangle.height = rectangle.bottom - rectangle.top;
                            var scaleByX = this.layout.viewportIn.width / rectangle.width, scaleByY = this.layout.viewportIn.height / rectangle.height, scale = Math.min(scaleByX, scaleByY), x = -rectangle.left * scale + 5, y = -rectangle.top * scale + 5;
                            this.main.style("line-height", "5px"), this.main.attr("transform", visuals.SVGUtil.translate(x, y) + " scale(" + scale + ")").style("line-height", "10px");
                        }
                    }, WordCloud.prototype.renderSelection = function() {
                        var _this = this;
                        if (this.wordsTextUpdateSelection) {
                            if (!this.selectionManager.hasSelection) return void this.setOpacity(this.wordsTextUpdateSelection, WordCloud.MaxOpacity);
                            var selectedColumns = this.wordsTextUpdateSelection.filter(function(d) {
                                return _this.selectionManager.isSelected(d.text);
                            });
                            this.setOpacity(this.wordsTextUpdateSelection, WordCloud.MinOpacity), this.setOpacity(selectedColumns, WordCloud.MaxOpacity);
                        }
                    }, WordCloud.prototype.setOpacity = function(element, opacityValue) {
                        element.style("fill-opacity", opacityValue), this.main && (this.main.style("line-height", "14px"), 
                        this.animation(this.main, 0, this.durationAnimations).style("line-height", "15px"));
                    }, WordCloud.prototype.enumerateObjectInstances = function(options) {
                        var _this = this, instances = WordCloudSettings.enumerateObjectInstances(this.settings && this.settings.originalSettings, options, WordCloud.capabilities);
                        switch (options.objectName) {
                          case "dataPoint":
                            if (this.data && this.data.dataPoints) {
                                var wordCategoriesIndex = [];
                                _.unique(this.data.dataPoints, function(x) {
                                    return x.wordIndex;
                                }).forEach(function(item) {
                                    wordCategoriesIndex.indexOf(item.wordIndex) === -1 && (wordCategoriesIndex.push(item.wordIndex), 
                                    instances.pushInstance({
                                        objectName: options.objectName,
                                        displayName: _this.data.texts[item.wordIndex].text,
                                        selector: visuals.ColorHelper.normalizeSelector(item.selectionIds[0].getSelector(), !1),
                                        properties: {
                                            fill: {
                                                solid: {
                                                    color: item.color
                                                }
                                            }
                                        }
                                    }));
                                });
                            }
                        }
                        return instances.complete();
                    }, WordCloud.prototype.animation = function(element, duration, delay, callback) {
                        return void 0 === duration && (duration = 0), void 0 === delay && (delay = 0), element.transition().delay(delay).duration(duration).each("end", callback);
                    }, WordCloud.prototype.destroy = function() {
                        this.root = null, this.canvas = null;
                    }, WordCloud.ClassName = "wordCloud", WordCloud.Words = {
                        class: "words",
                        selector: ".words"
                    }, WordCloud.WordGroup = {
                        class: "word",
                        selector: ".word"
                    }, WordCloud.Size = "px", WordCloud.StopWordsDelemiter = " ", WordCloud.Radians = Math.PI / 180, 
                    WordCloud.MinAngle = -180, WordCloud.MaxAngle = 180, WordCloud.MaxNumberOfWords = 2500, 
                    WordCloud.MinOpacity = .2, WordCloud.MaxOpacity = 1, WordCloud.FontSizePercentageCoefficent = 1, 
                    WordCloud.capabilities = {
                        dataRoles: [ {
                            name: WordCloudColumns.Roles.Category,
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: "Category"
                        }, {
                            name: WordCloudColumns.Roles.Values,
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: "Values"
                        } ],
                        dataViewMappings: [ {
                            conditions: [ {
                                Category: {
                                    min: 1,
                                    max: 1
                                },
                                Values: {
                                    min: 0,
                                    max: 1
                                }
                            } ],
                            categorical: {
                                categories: {
                                    for: {
                                        in: "Category"
                                    },
                                    dataReductionAlgorithm: {
                                        top: {
                                            count: WordCloud.MaxNumberOfWords
                                        }
                                    }
                                },
                                values: {
                                    for: {
                                        in: "Values"
                                    }
                                }
                            }
                        } ],
                        sorting: {
                            implicit: {
                                clauses: [ {
                                    role: "Values",
                                    direction: 2
                                } ]
                            }
                        },
                        objects: {
                            general: {
                                displayName: "General",
                                properties: {
                                    formatString: {
                                        type: {
                                            formatting: {
                                                formatString: !0
                                            }
                                        }
                                    },
                                    maxNumberOfWords: {
                                        displayName: "Max number of words",
                                        type: {
                                            numeric: !0
                                        }
                                    },
                                    minFontSize: {
                                        displayName: "Min Font",
                                        type: {
                                            formatting: {
                                                fontSize: !0
                                            }
                                        }
                                    },
                                    maxFontSize: {
                                        displayName: "Max Font",
                                        type: {
                                            formatting: {
                                                fontSize: !0
                                            }
                                        }
                                    },
                                    isBrokenText: {
                                        displayName: "Word-breaking",
                                        type: {
                                            bool: !0
                                        }
                                    }
                                }
                            },
                            dataPoint: {
                                displayName: "Data colors",
                                properties: {
                                    fill: {
                                        displayName: "Fill",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    }
                                }
                            },
                            stopWords: {
                                displayName: "Stop Words",
                                properties: {
                                    show: {
                                        displayName: "Show",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    isDefaultStopWords: {
                                        displayName: "Default Stop Words",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    words: {
                                        displayName: "Words",
                                        type: {
                                            text: !0
                                        }
                                    }
                                }
                            },
                            rotateText: {
                                displayName: "Rotate Text",
                                properties: {
                                    show: {
                                        displayName: "Show",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    minAngle: {
                                        displayName: "Min Angle",
                                        type: {
                                            numeric: !0
                                        }
                                    },
                                    maxAngle: {
                                        displayName: "Max Angle",
                                        type: {
                                            numeric: !0
                                        }
                                    },
                                    maxNumberOfOrientations: {
                                        displayName: "Max number of orientations",
                                        type: {
                                            numeric: !0
                                        }
                                    }
                                }
                            }
                        }
                    }, WordCloud.Punctuation = [ "!", ".", ":", "'", ";", ",", "!", "@", "#", "$", "%", "^", "&", "*", "(", ")", "[", "]", '"', "\\", "/", "-", "_", "+", "=" ], 
                    WordCloud.StopWords = [ "a", "able", "about", "across", "after", "all", "almost", "also", "am", "among", "an", "and", "any", "are", "as", "at", "be", "because", "been", "but", "by", "can", "cannot", "could", "did", "do", "does", "either", "else", "ever", "every", "for", "from", "get", "got", "had", "has", "have", "he", "her", "hers", "him", "his", "how", "however", "i", "if", "in", "into", "is", "it", "its", "just", "least", "let", "like", "likely", "may", "me", "might", "most", "must", "my", "neither", "no", "nor", "not", "of", "off", "often", "on", "only", "or", "other", "our", "own", "rather", "said", "say", "says", "she", "should", "since", "so", "some", "than", "that", "the", "their", "them", "then", "there", "these", "they", "this", "tis", "to", "too", "twas", "us", "wants", "was", "we", "were", "what", "when", "where", "which", "while", "who", "whom", "why", "will", "with", "would", "yet", "you", "your" ], 
                    WordCloud.DefaultMargin = {
                        top: 10,
                        right: 10,
                        bottom: 10,
                        left: 10
                    }, WordCloud;
                }();
                samples.WordCloud = WordCloud;
                var explore;
                !function(explore) {
                    var util;
                    !function(util) {
                        function hexToRgb(hex) {
                            var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
                            hex = hex.replace(shorthandRegex, function(m, r, g, b) {
                                return r + r + g + g + b + b;
                            });
                            var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                            return result ? "rgb(" + parseInt(result[1], 16) + "," + parseInt(result[2], 16) + "," + parseInt(result[3], 16) + ")" : null;
                        }
                        function getRandomColor() {
                            var red = Math.floor(255 * Math.random()), green = Math.floor(255 * Math.random()), blue = Math.floor(255 * Math.random());
                            return "rgb(" + red + "," + green + "," + blue + ")";
                        }
                        util.hexToRgb = hexToRgb, util.getRandomColor = getRandomColor;
                    }(util = explore.util || (explore.util = {}));
                }(explore || (explore = {}));
            }(samples = visuals.samples || (visuals.samples = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, jsCommon = window.jsCommon, powerbi = window.powerbi;
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var samples;
            !function(samples) {
                var TableViewFactory, createClassAndSelector = jsCommon.CssConstants.createClassAndSelector, PixelConverter = jsCommon.PixelConverter, createEnumType = powerbi.createEnumType, DataViewObjects = powerbi.DataViewObjects, VisualDataRoleKind = powerbi.VisualDataRoleKind, DataViewAnalysis = powerbi.DataViewAnalysis, TextMeasurementService = powerbi.TextMeasurementService, SQExprConverter = powerbi.data.SQExprConverter, Selector = powerbi.data.Selector, valueFormatter = powerbi.visuals.valueFormatter, createInteractivityService = powerbi.visuals.createInteractivityService, isCategoryColumnSelected = powerbi.visuals.isCategoryColumnSelected, converterHelper = powerbi.visuals.converterHelper, SelectionIdBuilder = powerbi.visuals.SelectionIdBuilder;
                !function(TableViewFactory) {
                    function createTableView(options) {
                        return new TableView(options);
                    }
                    TableViewFactory.createTableView = createTableView;
                }(TableViewFactory = samples.TableViewFactory || (samples.TableViewFactory = {}));
                var TableView = function() {
                    function TableView(options) {
                        this.options = $.extend(!0, {}, options), this.options.baseContainer.style("overflow-y", "auto").attr("drag-resize-disabled", !0), 
                        this.scrollContainer = options.baseContainer.append("div").attr("class", "scrollRegion"), 
                        this.visibleGroupContainer = this.scrollContainer.append("div").attr("class", "visibleGroup"), 
                        TableView.SetDefaultOptions(options);
                    }
                    return TableView.SetDefaultOptions = function(options) {
                        options.rowHeight = options.rowHeight || TableView.defaultRowHeight;
                    }, Object.defineProperty(TableView.prototype, "computedColumns", {
                        get: function() {
                            return this.computedOptions ? this.computedOptions.columns : 0;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(TableView.prototype, "computedRows", {
                        get: function() {
                            return this.computedOptions ? this.computedOptions.rows : 0;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), TableView.prototype.rowHeight = function(rowHeight) {
                        return this.options.rowHeight = Math.ceil(rowHeight), this;
                    }, TableView.prototype.columnWidth = function(columnWidth) {
                        return this.options.columnWidth = Math.ceil(columnWidth), this;
                    }, TableView.prototype.orientation = function(orientation) {
                        return this.options.orientation = orientation, this;
                    }, TableView.prototype.rows = function(rows) {
                        return this.options.rows = Math.ceil(rows), this;
                    }, TableView.prototype.columns = function(columns) {
                        return this.options.columns = Math.ceil(columns), this;
                    }, TableView.prototype.data = function(data, getDatumIndex, dataReset) {
                        return void 0 === dataReset && (dataReset = !1), this._data = data, this.getDatumIndex = getDatumIndex, 
                        this.setTotalRows(), dataReset && $(this.options.baseContainer.node()).scrollTop(0), 
                        this;
                    }, TableView.prototype.viewport = function(viewport) {
                        return this.options.viewport = viewport, this;
                    }, TableView.prototype.empty = function() {
                        return this._data = [], this.render(), this;
                    }, TableView.prototype.setTotalRows = function() {
                        var count = this._data.length, rows = Math.min(this.options.rows, count), columns = Math.min(this.options.columns, count);
                        columns > 0 && rows > 0 ? (this._totalColumns = columns, this._totalRows = rows) : rows > 0 ? (this._totalRows = rows, 
                        this._totalColumns = Math.ceil(count / rows)) : columns > 0 ? (this._totalColumns = columns, 
                        this._totalRows = Math.ceil(count / columns)) : (this._totalColumns = TableView.defaultColumns, 
                        this._totalRows = Math.ceil(count / TableView.defaultColumns));
                    }, TableView.prototype.getGroupedData = function() {
                        var options = this.options, groupedData = [], totalRows = options.rows, totalColumns = options.columns, totalItems = this._data.length, totalRows = options.rows > totalItems ? totalItems : options.rows, totalColumns = options.columns > totalItems ? totalItems : options.columns;
                        if (0 === totalColumns && 0 === totalRows ? options.orientation === Orientation.HORIZONTAL ? (totalColumns = totalItems, 
                        totalRows = 1) : (totalColumns = 1, totalRows = totalItems) : 0 === totalColumns && totalRows > 0 ? totalColumns = Math.ceil(totalItems / totalRows) : totalColumns > 0 && 0 === totalRows && (totalRows = Math.ceil(totalItems / totalColumns)), 
                        this.options.orientation === Orientation.VERTICAL) {
                            var n = totalRows;
                            totalRows = totalColumns, totalColumns = n;
                        } else this.options.orientation === Orientation.HORIZONTAL && (0 === totalRows && (totalRows = this._totalRows), 
                        0 === totalColumns && (totalColumns = this._totalColumns));
                        for (var m = 0, k = 0, i = 0; i < totalRows; i++) if (this.options.orientation === Orientation.VERTICAL && 0 === options.rows && totalItems % options.columns > 0 && options.columns <= totalItems) totalItems % options.columns > i ? (m = i * Math.ceil(totalItems / options.columns), 
                        k = m + Math.ceil(totalItems / options.columns), this.addDataToArray(groupedData, this._data, m, k)) : (this.addDataToArray(groupedData, this._data, k, k + Math.floor(totalItems / options.columns)), 
                        k += Math.floor(totalItems / options.columns)); else if (this.options.orientation === Orientation.HORIZONTAL && 0 === options.columns && totalItems % options.rows > 0 && options.rows <= totalItems) totalItems % options.rows > i ? (m = i * Math.ceil(totalItems / options.rows), 
                        k = m + Math.ceil(totalItems / options.rows), this.addDataToArray(groupedData, this._data, m, k)) : (this.addDataToArray(groupedData, this._data, k, k + Math.floor(totalItems / options.rows)), 
                        k += Math.floor(totalItems / options.rows)); else {
                            var k = i * totalColumns;
                            this.addDataToArray(groupedData, this._data, k, k + totalColumns);
                        }
                        return this.computedOptions = this.getComputedOptions(groupedData, this.options.orientation), 
                        {
                            data: groupedData,
                            totalColumns: totalColumns,
                            totalRows: totalRows
                        };
                    }, TableView.prototype.addDataToArray = function(array, data, start, end) {
                        if (array && data) {
                            var elements = data.slice(start, end);
                            elements && elements.length > 0 && array.push(elements);
                        }
                    }, TableView.prototype.getComputedOptions = function(data, orientation) {
                        var rows, columns = 0;
                        rows = data ? data.length : 0;
                        for (var i = 0; i < rows; i++) {
                            var currentRow = data[i];
                            currentRow && currentRow.length > columns && (columns = currentRow.length);
                        }
                        return orientation === Orientation.HORIZONTAL ? {
                            columns: columns,
                            rows: rows
                        } : {
                            columns: rows,
                            rows: columns
                        };
                    }, TableView.prototype.render = function() {
                        var rowSelection, cellSelection, options = this.options, visibleGroupContainer = this.visibleGroupContainer, rowHeight = options.rowHeight || TableView.defaultRowHeight, groupedData = this.getGroupedData();
                        if (rowSelection = visibleGroupContainer.selectAll(TableView.RowSelector.selector).data(groupedData.data), 
                        rowSelection.enter().append("div").classed(TableView.RowSelector.class, !0), cellSelection = rowSelection.selectAll(TableView.CellSelector.selector).data(function(dataPoints) {
                            return dataPoints;
                        }), cellSelection.enter().append("div").classed(TableView.CellSelector.class, !0), 
                        cellSelection.call(function(selection) {
                            options.enter(selection);
                        }), cellSelection.call(function(selection) {
                            options.update(selection);
                        }), cellSelection.style({
                            height: rowHeight > 0 ? rowHeight + "px" : "auto"
                        }), this.options.orientation === Orientation.VERTICAL) {
                            for (var realColumnNumber = 0, i = 0; i < groupedData.data.length; i++) 0 !== groupedData.data[i].length && (realColumnNumber = i + 1);
                            cellSelection.style({
                                width: "100%"
                            }), rowSelection.style({
                                width: options.columnWidth > 0 ? options.columnWidth + "px" : 100 / realColumnNumber + "%"
                            });
                        } else cellSelection.style({
                            width: options.columnWidth > 0 ? options.columnWidth + "px" : 100 / groupedData.totalColumns + "%"
                        }), rowSelection.style({
                            width: null
                        });
                        cellSelection.exit().remove(), rowSelection.exit().call(function(d) {
                            return options.exit(d);
                        }).remove();
                    }, TableView.RowSelector = createClassAndSelector("row"), TableView.CellSelector = createClassAndSelector("cell"), 
                    TableView.defaultRowHeight = 0, TableView.defaultColumns = 1, TableView;
                }();
                samples.TableView = TableView, samples.chicletSlicerProps = {
                    general: {
                        orientation: {
                            objectName: "general",
                            propertyName: "orientation"
                        },
                        columns: {
                            objectName: "general",
                            propertyName: "columns"
                        },
                        rows: {
                            objectName: "general",
                            propertyName: "rows"
                        },
                        showDisabled: {
                            objectName: "general",
                            propertyName: "showDisabled"
                        },
                        multiselect: {
                            objectName: "general",
                            propertyName: "multiselect"
                        },
                        selection: {
                            objectName: "general",
                            propertyName: "selection"
                        },
                        selfFilterEnabled: {
                            objectName: "general",
                            propertyName: "selfFilterEnabled"
                        }
                    },
                    header: {
                        show: {
                            objectName: "header",
                            propertyName: "show"
                        },
                        title: {
                            objectName: "header",
                            propertyName: "title"
                        },
                        fontColor: {
                            objectName: "header",
                            propertyName: "fontColor"
                        },
                        background: {
                            objectName: "header",
                            propertyName: "background"
                        },
                        outline: {
                            objectName: "header",
                            propertyName: "outline"
                        },
                        textSize: {
                            objectName: "header",
                            propertyName: "textSize"
                        },
                        outlineColor: {
                            objectName: "header",
                            propertyName: "outlineColor"
                        },
                        outlineWeight: {
                            objectName: "header",
                            propertyName: "outlineWeight"
                        }
                    },
                    rows: {
                        fontColor: {
                            objectName: "rows",
                            propertyName: "fontColor"
                        },
                        textSize: {
                            objectName: "rows",
                            propertyName: "textSize"
                        },
                        height: {
                            objectName: "rows",
                            propertyName: "height"
                        },
                        width: {
                            objectName: "rows",
                            propertyName: "width"
                        },
                        background: {
                            objectName: "rows",
                            propertyName: "background"
                        },
                        transparency: {
                            objectName: "rows",
                            propertyName: "transparency"
                        },
                        selectedColor: {
                            objectName: "rows",
                            propertyName: "selectedColor"
                        },
                        hoverColor: {
                            objectName: "rows",
                            propertyName: "hoverColor"
                        },
                        unselectedColor: {
                            objectName: "rows",
                            propertyName: "unselectedColor"
                        },
                        disabledColor: {
                            objectName: "rows",
                            propertyName: "disabledColor"
                        },
                        outline: {
                            objectName: "rows",
                            propertyName: "outline"
                        },
                        outlineColor: {
                            objectName: "rows",
                            propertyName: "outlineColor"
                        },
                        outlineWeight: {
                            objectName: "rows",
                            propertyName: "outlineWeight"
                        },
                        borderStyle: {
                            objectName: "rows",
                            propertyName: "borderStyle"
                        }
                    },
                    images: {
                        imageSplit: {
                            objectName: "images",
                            propertyName: "imageSplit"
                        },
                        stretchImage: {
                            objectName: "images",
                            propertyName: "stretchImage"
                        },
                        bottomImage: {
                            objectName: "images",
                            propertyName: "bottomImage"
                        }
                    },
                    selectedPropertyIdentifier: {
                        objectName: "general",
                        propertyName: "selected"
                    },
                    filterPropertyIdentifier: {
                        objectName: "general",
                        propertyName: "filter"
                    },
                    formatString: {
                        objectName: "general",
                        propertyName: "formatString"
                    },
                    hasSavedSelection: !0
                };
                var ChicletBorderStyle;
                !function(ChicletBorderStyle) {
                    ChicletBorderStyle.ROUNDED = "Rounded", ChicletBorderStyle.CUT = "Cut", ChicletBorderStyle.SQUARE = "Square", 
                    ChicletBorderStyle.type = createEnumType([ {
                        value: ChicletBorderStyle.ROUNDED,
                        displayName: ChicletBorderStyle.ROUNDED
                    }, {
                        value: ChicletBorderStyle.CUT,
                        displayName: ChicletBorderStyle.CUT
                    }, {
                        value: ChicletBorderStyle.SQUARE,
                        displayName: ChicletBorderStyle.SQUARE
                    } ]);
                }(ChicletBorderStyle || (ChicletBorderStyle = {}));
                var ChicletSlicerShowDisabled;
                !function(ChicletSlicerShowDisabled) {
                    ChicletSlicerShowDisabled.INPLACE = "Inplace", ChicletSlicerShowDisabled.BOTTOM = "Bottom", 
                    ChicletSlicerShowDisabled.HIDE = "Hide", ChicletSlicerShowDisabled.type = createEnumType([ {
                        value: ChicletSlicerShowDisabled.INPLACE,
                        displayName: ChicletSlicerShowDisabled.INPLACE
                    }, {
                        value: ChicletSlicerShowDisabled.BOTTOM,
                        displayName: ChicletSlicerShowDisabled.BOTTOM
                    }, {
                        value: ChicletSlicerShowDisabled.HIDE,
                        displayName: ChicletSlicerShowDisabled.HIDE
                    } ]);
                }(ChicletSlicerShowDisabled || (ChicletSlicerShowDisabled = {}));
                var Orientation;
                !function(Orientation) {
                    Orientation.HORIZONTAL = "Horizontal", Orientation.VERTICAL = "Vertical", Orientation.type = createEnumType([ {
                        value: Orientation.HORIZONTAL,
                        displayName: Orientation.HORIZONTAL
                    }, {
                        value: Orientation.VERTICAL,
                        displayName: Orientation.VERTICAL
                    } ]);
                }(Orientation || (Orientation = {}));
                var ChicletSlicer = function() {
                    function ChicletSlicer(options) {
                        options && options.behavior && (this.behavior = options.behavior), this.behavior || (this.behavior = new ChicletSlicerWebBehavior());
                    }
                    return ChicletSlicer.DefaultStyleProperties = function() {
                        return {
                            general: {
                                orientation: Orientation.VERTICAL,
                                columns: 3,
                                rows: 0,
                                multiselect: !0,
                                showDisabled: ChicletSlicerShowDisabled.INPLACE,
                                selection: null,
                                selfFilterEnabled: !1
                            },
                            margin: {
                                top: 50,
                                bottom: 50,
                                right: 50,
                                left: 50
                            },
                            header: {
                                borderBottomWidth: 1,
                                show: !0,
                                outline: "BottomOnly",
                                fontColor: "#a6a6a6",
                                background: null,
                                textSize: 10,
                                outlineColor: "#a6a6a6",
                                outlineWeight: 1,
                                title: ""
                            },
                            headerText: {
                                marginLeft: 8,
                                marginTop: 0
                            },
                            slicerText: {
                                textSize: 10,
                                height: 0,
                                width: 0,
                                fontColor: "#666666",
                                hoverColor: "#212121",
                                selectedColor: "#BDD7EE",
                                unselectedColor: "#ffffff",
                                disabledColor: "grey",
                                marginLeft: 8,
                                outline: "Frame",
                                background: null,
                                transparency: 0,
                                outlineColor: "#000000",
                                outlineWeight: 1,
                                borderStyle: "Cut"
                            },
                            slicerItemContainer: {
                                marginTop: 5,
                                marginLeft: 0
                            },
                            images: {
                                imageSplit: 50,
                                stretchImage: !1,
                                bottomImage: !1
                            }
                        };
                    }, ChicletSlicer.getValidImageSplit = function(imageSplit) {
                        return imageSplit < ChicletSlicer.MinImageSplit ? ChicletSlicer.MinImageSplit : imageSplit > ChicletSlicer.MaxImageSplit ? ChicletSlicer.MaxImageSplit : imageSplit;
                    }, ChicletSlicer.converter = function(dataView, searchText, interactivityService) {
                        if (dataView && dataView.categorical && dataView.categorical.categories && dataView.categorical.categories[0] && dataView.categorical.categories[0].values && dataView.categorical.categories[0].values.length > 0) {
                            var converter = new ChicletSlicerChartConversion.ChicletSlicerConverter(dataView, interactivityService);
                            converter.convert();
                            var slicerData, defaultSettings = this.DefaultStyleProperties(), objects = dataView.metadata.objects;
                            objects && (defaultSettings.general.orientation = DataViewObjects.getValue(objects, samples.chicletSlicerProps.general.orientation, defaultSettings.general.orientation), 
                            defaultSettings.general.columns = DataViewObjects.getValue(objects, samples.chicletSlicerProps.general.columns, defaultSettings.general.columns), 
                            defaultSettings.general.rows = DataViewObjects.getValue(objects, samples.chicletSlicerProps.general.rows, defaultSettings.general.rows), 
                            defaultSettings.general.multiselect = DataViewObjects.getValue(objects, samples.chicletSlicerProps.general.multiselect, defaultSettings.general.multiselect), 
                            defaultSettings.general.showDisabled = DataViewObjects.getValue(objects, samples.chicletSlicerProps.general.showDisabled, defaultSettings.general.showDisabled), 
                            defaultSettings.general.selection = DataViewObjects.getValue(dataView.metadata.objects, samples.chicletSlicerProps.general.selection, defaultSettings.general.selection), 
                            defaultSettings.general.selfFilterEnabled = DataViewObjects.getValue(objects, samples.chicletSlicerProps.general.selfFilterEnabled, defaultSettings.general.selfFilterEnabled), 
                            defaultSettings.header.show = DataViewObjects.getValue(objects, samples.chicletSlicerProps.header.show, defaultSettings.header.show), 
                            defaultSettings.header.title = DataViewObjects.getValue(objects, samples.chicletSlicerProps.header.title, defaultSettings.header.title), 
                            defaultSettings.header.fontColor = DataViewObjects.getFillColor(objects, samples.chicletSlicerProps.header.fontColor, defaultSettings.header.fontColor), 
                            defaultSettings.header.background = DataViewObjects.getFillColor(objects, samples.chicletSlicerProps.header.background, defaultSettings.header.background), 
                            defaultSettings.header.textSize = DataViewObjects.getValue(objects, samples.chicletSlicerProps.header.textSize, defaultSettings.header.textSize), 
                            defaultSettings.header.outline = DataViewObjects.getValue(objects, samples.chicletSlicerProps.header.outline, defaultSettings.header.outline), 
                            defaultSettings.header.outlineColor = DataViewObjects.getFillColor(objects, samples.chicletSlicerProps.header.outlineColor, defaultSettings.header.outlineColor), 
                            defaultSettings.header.outlineWeight = DataViewObjects.getValue(objects, samples.chicletSlicerProps.header.outlineWeight, defaultSettings.header.outlineWeight), 
                            defaultSettings.slicerText.textSize = DataViewObjects.getValue(objects, samples.chicletSlicerProps.rows.textSize, defaultSettings.slicerText.textSize), 
                            defaultSettings.slicerText.height = DataViewObjects.getValue(objects, samples.chicletSlicerProps.rows.height, defaultSettings.slicerText.height), 
                            defaultSettings.slicerText.width = DataViewObjects.getValue(objects, samples.chicletSlicerProps.rows.width, defaultSettings.slicerText.width), 
                            defaultSettings.slicerText.selectedColor = DataViewObjects.getFillColor(objects, samples.chicletSlicerProps.rows.selectedColor, defaultSettings.slicerText.selectedColor), 
                            defaultSettings.slicerText.hoverColor = DataViewObjects.getFillColor(objects, samples.chicletSlicerProps.rows.hoverColor, defaultSettings.slicerText.hoverColor), 
                            defaultSettings.slicerText.unselectedColor = DataViewObjects.getFillColor(objects, samples.chicletSlicerProps.rows.unselectedColor, defaultSettings.slicerText.unselectedColor), 
                            defaultSettings.slicerText.disabledColor = DataViewObjects.getFillColor(objects, samples.chicletSlicerProps.rows.disabledColor, defaultSettings.slicerText.disabledColor), 
                            defaultSettings.slicerText.background = DataViewObjects.getFillColor(objects, samples.chicletSlicerProps.rows.background, defaultSettings.slicerText.background), 
                            defaultSettings.slicerText.transparency = DataViewObjects.getValue(objects, samples.chicletSlicerProps.rows.transparency, defaultSettings.slicerText.transparency), 
                            defaultSettings.slicerText.fontColor = DataViewObjects.getFillColor(objects, samples.chicletSlicerProps.rows.fontColor, defaultSettings.slicerText.fontColor), 
                            defaultSettings.slicerText.outline = DataViewObjects.getValue(objects, samples.chicletSlicerProps.rows.outline, defaultSettings.slicerText.outline), 
                            defaultSettings.slicerText.outlineColor = DataViewObjects.getFillColor(objects, samples.chicletSlicerProps.rows.outlineColor, defaultSettings.slicerText.outlineColor), 
                            defaultSettings.slicerText.outlineWeight = DataViewObjects.getValue(objects, samples.chicletSlicerProps.rows.outlineWeight, defaultSettings.slicerText.outlineWeight), 
                            defaultSettings.slicerText.borderStyle = DataViewObjects.getValue(objects, samples.chicletSlicerProps.rows.borderStyle, defaultSettings.slicerText.borderStyle), 
                            defaultSettings.images.imageSplit = DataViewObjects.getValue(objects, samples.chicletSlicerProps.images.imageSplit, defaultSettings.images.imageSplit), 
                            defaultSettings.images.stretchImage = DataViewObjects.getValue(objects, samples.chicletSlicerProps.images.stretchImage, defaultSettings.images.stretchImage), 
                            defaultSettings.images.bottomImage = DataViewObjects.getValue(objects, samples.chicletSlicerProps.images.bottomImage, defaultSettings.images.bottomImage)), 
                            defaultSettings.general.selfFilterEnabled && searchText && (searchText = searchText.toLowerCase(), 
                            converter.dataPoints.forEach(function(x) {
                                return x.filtered = x.category.toLowerCase().indexOf(searchText) < 0;
                            }));
                            var categories = dataView.categorical.categories[0];
                            return slicerData = {
                                categorySourceName: categories.source.displayName,
                                formatString: valueFormatter.getFormatString(categories.source, samples.chicletSlicerProps.formatString),
                                slicerSettings: defaultSettings,
                                slicerDataPoints: converter.dataPoints
                            }, slicerData.hasSelectionOverride = converter.hasSelectionOverride, slicerData;
                        }
                    }, ChicletSlicer.prototype.init = function(options) {
                        this.element = options.element, this.currentViewport = options.viewport, this.behavior && (this.interactivityService = createInteractivityService(options.host)), 
                        this.hostServices = options.host, this.hostServices.canSelect = ChicletSlicer.canSelect, 
                        this.settings = ChicletSlicer.DefaultStyleProperties(), this.initContainer();
                    }, ChicletSlicer.canSelect = function(args) {
                        var selectors = _.map(args.visualObjects, function(visualObject) {
                            return Selector.convertSelectorsByColumnToSelector(visualObject.selectorsByColumn);
                        });
                        return !(selectors && selectors.length > 1 && selectors.some(function(value) {
                            return value && value.data && value.data.length > 1;
                        }));
                    }, ChicletSlicer.prototype.update = function(options) {
                        if (options && options.dataViews && options.dataViews[0] && options.viewport) {
                            var existingDataView = this.dataView;
                            this.dataView = options.dataViews[0];
                            var resetScrollbarPosition = !0;
                            existingDataView && (resetScrollbarPosition = !DataViewAnalysis.hasSameCategoryIdentity(existingDataView, this.dataView)), 
                            options.viewport.height === this.currentViewport.height && options.viewport.width === this.currentViewport.width ? this.waitingForData = !1 : this.currentViewport = options.viewport, 
                            this.updateInternal(resetScrollbarPosition);
                        }
                    }, ChicletSlicer.prototype.onResizing = function(finalViewport) {
                        this.currentViewport = finalViewport, this.updateInternal(!1);
                    }, ChicletSlicer.prototype.enumerateObjectInstances = function(options) {
                        var data = this.slicerData;
                        if (data) switch (options.objectName) {
                          case "rows":
                            return this.enumerateRows(data);

                          case "header":
                            return this.enumerateHeader(data);

                          case "general":
                            return this.enumerateGeneral(data);

                          case "images":
                            return this.enumerateImages(data);
                        }
                    }, ChicletSlicer.prototype.enumerateHeader = function(data) {
                        var slicerSettings = this.settings;
                        return [ {
                            selector: null,
                            objectName: "header",
                            properties: {
                                show: slicerSettings.header.show,
                                title: slicerSettings.header.title,
                                fontColor: slicerSettings.header.fontColor,
                                background: slicerSettings.header.background,
                                textSize: slicerSettings.header.textSize,
                                outline: slicerSettings.header.outline,
                                outlineColor: slicerSettings.header.outlineColor,
                                outlineWeight: slicerSettings.header.outlineWeight
                            }
                        } ];
                    }, ChicletSlicer.prototype.enumerateRows = function(data) {
                        var slicerSettings = this.settings;
                        return [ {
                            selector: null,
                            objectName: "rows",
                            properties: {
                                textSize: slicerSettings.slicerText.textSize,
                                height: slicerSettings.slicerText.height,
                                width: slicerSettings.slicerText.width,
                                background: slicerSettings.slicerText.background,
                                transparency: slicerSettings.slicerText.transparency,
                                selectedColor: slicerSettings.slicerText.selectedColor,
                                hoverColor: slicerSettings.slicerText.hoverColor,
                                unselectedColor: slicerSettings.slicerText.unselectedColor,
                                disabledColor: slicerSettings.slicerText.disabledColor,
                                outline: slicerSettings.slicerText.outline,
                                outlineColor: slicerSettings.slicerText.outlineColor,
                                outlineWeight: slicerSettings.slicerText.outlineWeight,
                                fontColor: slicerSettings.slicerText.fontColor,
                                borderStyle: slicerSettings.slicerText.borderStyle
                            }
                        } ];
                    }, ChicletSlicer.prototype.enumerateGeneral = function(data) {
                        var slicerSettings = this.settings;
                        return [ {
                            selector: null,
                            objectName: "general",
                            properties: {
                                orientation: slicerSettings.general.orientation,
                                columns: slicerSettings.general.columns,
                                rows: slicerSettings.general.rows,
                                showDisabled: slicerSettings.general.showDisabled,
                                multiselect: slicerSettings.general.multiselect,
                                selfFilterEnabled: slicerSettings.general.selfFilterEnabled
                            }
                        } ];
                    }, ChicletSlicer.prototype.enumerateImages = function(data) {
                        var slicerSettings = this.settings;
                        return [ {
                            selector: null,
                            objectName: "images",
                            properties: {
                                imageSplit: slicerSettings.images.imageSplit,
                                stretchImage: slicerSettings.images.stretchImage,
                                bottomImage: slicerSettings.images.bottomImage
                            }
                        } ];
                    }, ChicletSlicer.prototype.updateInternal = function(resetScrollbarPosition) {
                        var _this = this, data = ChicletSlicer.converter(this.dataView, this.searchInput.val(), this.interactivityService);
                        if (!data) return void this.tableView.empty();
                        this.interactivityService && this.interactivityService.applySelectionStateToData(data.slicerDataPoints), 
                        data.slicerSettings.header.outlineWeight = data.slicerSettings.header.outlineWeight < 0 ? 0 : data.slicerSettings.header.outlineWeight, 
                        data.slicerSettings.slicerText.outlineWeight = data.slicerSettings.slicerText.outlineWeight < 0 ? 0 : data.slicerSettings.slicerText.outlineWeight, 
                        data.slicerSettings.slicerText.height = data.slicerSettings.slicerText.height < 0 ? 0 : data.slicerSettings.slicerText.height, 
                        data.slicerSettings.slicerText.width = data.slicerSettings.slicerText.width < 0 ? 0 : data.slicerSettings.slicerText.width, 
                        data.slicerSettings.images.imageSplit = ChicletSlicer.getValidImageSplit(data.slicerSettings.images.imageSplit), 
                        data.slicerSettings.general.columns = data.slicerSettings.general.columns < 0 ? 0 : data.slicerSettings.general.columns, 
                        data.slicerSettings.general.rows = data.slicerSettings.general.rows < 0 ? 0 : data.slicerSettings.general.rows, 
                        data.slicerSettings.general.getSavedSelection = function() {
                            try {
                                return JSON.parse(_this.slicerData.slicerSettings.general.selection) || [];
                            } catch (ex) {
                                return [];
                            }
                        }, data.slicerSettings.general.setSavedSelection = function(filter, selectionIds) {
                            _this.isSelectionSaved = !0, _this.hostServices.persistProperties({
                                merge: [ {
                                    objectName: "general",
                                    selector: null,
                                    properties: {
                                        filter: filter,
                                        selection: selectionIds && JSON.stringify(selectionIds) || ""
                                    }
                                } ]
                            });
                        }, this.slicerData ? this.isSelectionSaved ? this.isSelectionLoaded = !0 : this.isSelectionLoaded = this.slicerData.slicerSettings.general.selection === data.slicerSettings.general.selection : this.isSelectionLoaded = !1, 
                        this.slicerData = data, this.settings = this.slicerData.slicerSettings, this.updateSlicerBodyDimensions(), 
                        this.settings.general.showDisabled === ChicletSlicerShowDisabled.BOTTOM ? data.slicerDataPoints.sort(function(a, b) {
                            return a.selectable === b.selectable ? 0 : a.selectable && !b.selectable ? -1 : 1;
                        }) : this.settings.general.showDisabled === ChicletSlicerShowDisabled.HIDE && (data.slicerDataPoints = data.slicerDataPoints.filter(function(x) {
                            return x.selectable;
                        }));
                        var height = this.settings.slicerText.height;
                        if (0 === height) {
                            var extraSpaceForCell = ChicletSlicer.cellTotalInnerPaddings + ChicletSlicer.cellTotalInnerBorders, textProperties = ChicletSlicer.getChicletTextProperties(this.settings.slicerText.textSize);
                            height = TextMeasurementService.estimateSvgTextHeight(textProperties) + TextMeasurementService.estimateSvgTextBaselineDelta(textProperties) + extraSpaceForCell;
                            var hasImage = _.any(data.slicerDataPoints, function(dataPoint) {
                                return "" !== dataPoint.imageURL && "undefined" != typeof dataPoint.imageURL;
                            });
                            hasImage && (height += 100);
                        }
                        this.tableView.rowHeight(height).columnWidth(this.settings.slicerText.width).orientation(this.settings.general.orientation).rows(this.settings.general.rows).columns(this.settings.general.columns).data(data.slicerDataPoints.filter(function(x) {
                            return !x.filtered;
                        }), function(d) {
                            return $.inArray(d, data.slicerDataPoints);
                        }, resetScrollbarPosition).viewport(this.getSlicerBodyViewport(this.currentViewport)).render(), 
                        this.updateSearchHeader();
                    }, ChicletSlicer.prototype.initContainer = function() {
                        var _this = this, settings = this.settings, slicerBodyViewport = this.getSlicerBodyViewport(this.currentViewport), slicerContainer = d3.select(this.element.get(0)).append("div").classed(ChicletSlicer.ContainerSelector.class, !0);
                        this.slicerHeader = slicerContainer.append("div").classed(ChicletSlicer.HeaderSelector.class, !0), 
                        this.slicerHeader.append("span").classed(ChicletSlicer.ClearSelector.class, !0).attr("title", "Clear"), 
                        this.slicerHeader.append("div").classed(ChicletSlicer.HeaderTextSelector.class, !0).style({
                            "margin-left": PixelConverter.toString(settings.headerText.marginLeft),
                            "margin-top": PixelConverter.toString(settings.headerText.marginTop),
                            "border-style": this.getBorderStyle(settings.header.outline),
                            "border-color": settings.header.outlineColor,
                            "border-width": this.getBorderWidth(settings.header.outline, settings.header.outlineWeight),
                            "font-size": PixelConverter.fromPoint(settings.header.textSize)
                        }), this.createSearchHeader($(slicerContainer.node())), this.slicerBody = slicerContainer.append("div").classed(ChicletSlicer.BodySelector.class, !0).classed(ChicletSlicer.SlicerBodyHorizontalSelector.class, settings.general.orientation === Orientation.HORIZONTAL).classed(ChicletSlicer.SlicerBodyVerticalSelector.class, settings.general.orientation === Orientation.VERTICAL).style({
                            height: PixelConverter.toString(slicerBodyViewport.height),
                            width: "100%"
                        });
                        var rowEnter = function(rowSelection) {
                            _this.enterSelection(rowSelection);
                        }, rowUpdate = function(rowSelection) {
                            _this.updateSelection(rowSelection);
                        }, rowExit = function(rowSelection) {
                            rowSelection.remove();
                        }, tableViewOptions = {
                            rowHeight: this.getRowHeight(),
                            columnWidth: this.settings.slicerText.width,
                            orientation: this.settings.general.orientation,
                            rows: this.settings.general.rows,
                            columns: this.settings.general.columns,
                            enter: rowEnter,
                            exit: rowExit,
                            update: rowUpdate,
                            loadMoreData: function() {
                                return _this.onLoadMoreData();
                            },
                            scrollEnabled: !0,
                            viewport: this.getSlicerBodyViewport(this.currentViewport),
                            baseContainer: this.slicerBody
                        };
                        this.tableView = TableViewFactory.createTableView(tableViewOptions);
                    }, ChicletSlicer.prototype.enterSelection = function(rowSelection) {
                        var settings = this.settings, ulItemElement = rowSelection.selectAll("ul").data(function(dataPoint) {
                            return [ dataPoint ];
                        });
                        ulItemElement.enter().append("ul"), ulItemElement.exit().remove();
                        var listItemElement = ulItemElement.selectAll(ChicletSlicer.ItemContainerSelector.selector).data(function(dataPoint) {
                            return [ dataPoint ];
                        });
                        listItemElement.enter().append("li").classed(ChicletSlicer.ItemContainerSelector.class, !0), 
                        listItemElement.style({
                            "margin-left": PixelConverter.toString(settings.slicerItemContainer.marginLeft)
                        });
                        var slicerImgWrapperSelection = listItemElement.selectAll(ChicletSlicer.SlicerImgWrapperSelector.selector).data(function(dataPoint) {
                            return [ dataPoint ];
                        });
                        slicerImgWrapperSelection.enter().append("img").classed(ChicletSlicer.SlicerImgWrapperSelector.class, !0), 
                        slicerImgWrapperSelection.exit().remove();
                        var slicerTextWrapperSelection = listItemElement.selectAll(ChicletSlicer.SlicerTextWrapperSelector.selector).data(function(dataPoint) {
                            return [ dataPoint ];
                        });
                        slicerTextWrapperSelection.enter().append("div").classed(ChicletSlicer.SlicerTextWrapperSelector.class, !0);
                        var labelTextSelection = slicerTextWrapperSelection.selectAll(ChicletSlicer.LabelTextSelector.selector).data(function(dataPoint) {
                            return [ dataPoint ];
                        });
                        labelTextSelection.enter().append("span").classed(ChicletSlicer.LabelTextSelector.class, !0), 
                        labelTextSelection.style({
                            "font-size": PixelConverter.fromPoint(settings.slicerText.textSize)
                        }), labelTextSelection.exit().remove(), slicerTextWrapperSelection.exit().remove(), 
                        listItemElement.exit().remove();
                    }, ChicletSlicer.prototype.updateSelection = function(rowSelection) {
                        var _this = this, settings = this.settings, data = this.slicerData;
                        if (data && settings) {
                            this.slicerHeader.classed("hidden", !settings.header.show), this.slicerHeader.select(ChicletSlicer.HeaderTextSelector.selector).text("" !== settings.header.title.trim() ? settings.header.title.trim() : this.slicerData.categorySourceName).style({
                                "border-style": this.getBorderStyle(settings.header.outline),
                                "border-color": settings.header.outlineColor,
                                "border-width": this.getBorderWidth(settings.header.outline, settings.header.outlineWeight),
                                color: settings.header.fontColor,
                                "background-color": settings.header.background,
                                "font-size": PixelConverter.fromPoint(settings.header.textSize)
                            }), this.slicerBody.classed(ChicletSlicer.SlicerBodyHorizontalSelector.class, settings.general.orientation === Orientation.HORIZONTAL).classed(ChicletSlicer.SlicerBodyVerticalSelector.class, settings.general.orientation === Orientation.VERTICAL);
                            var slicerText = rowSelection.selectAll(ChicletSlicer.LabelTextSelector.selector), textProperties = ChicletSlicer.getChicletTextProperties(settings.slicerText.textSize), formatString = data.formatString;
                            if (slicerText.text(function(d) {
                                var maxWidth = 0;
                                if (textProperties.text = valueFormatter.format(d.category, formatString), 0 === _this.settings.slicerText.width) {
                                    var slicerBodyViewport = _this.getSlicerBodyViewport(_this.currentViewport);
                                    return maxWidth = slicerBodyViewport.width / (_this.tableView.computedColumns || 1) - ChicletSlicer.chicletTotalInnerRightLeftPaddings - ChicletSlicer.cellTotalInnerBorders - settings.slicerText.outlineWeight, 
                                    TextMeasurementService.getTailoredTextOrDefault(textProperties, maxWidth);
                                }
                                return maxWidth = _this.settings.slicerText.width - ChicletSlicer.chicletTotalInnerRightLeftPaddings - ChicletSlicer.cellTotalInnerBorders - settings.slicerText.outlineWeight, 
                                TextMeasurementService.getTailoredTextOrDefault(textProperties, maxWidth);
                            }), rowSelection.selectAll(ChicletSlicer.SlicerImgWrapperSelector.selector).style({
                                "max-height": settings.images.imageSplit + "%",
                                display: function(dataPoint) {
                                    return dataPoint.imageURL ? "flex" : "none";
                                }
                            }).classed({
                                hidden: function(dataPoint) {
                                    return !dataPoint.imageURL || (settings.images.imageSplit < 10 || void 0);
                                },
                                stretchImage: settings.images.stretchImage,
                                bottomImage: settings.images.bottomImage
                            }).attr("src", function(d) {
                                return d.imageURL ? d.imageURL : "";
                            }), rowSelection.selectAll(".slicer-text-wrapper").style("height", function(d) {
                                return d.imageURL ? 100 - settings.images.imageSplit + "%" : "100%";
                            }).classed("hidden", function(d) {
                                if (settings.images.imageSplit > 90) return !0;
                            }), rowSelection.selectAll(".slicerItemContainer").style({
                                color: settings.slicerText.fontColor,
                                "border-style": this.getBorderStyle(settings.slicerText.outline),
                                "border-color": settings.slicerText.outlineColor,
                                "border-width": this.getBorderWidth(settings.slicerText.outline, settings.slicerText.outlineWeight),
                                "font-size": PixelConverter.fromPoint(settings.slicerText.textSize),
                                "border-radius": this.getBorderRadius(settings.slicerText.borderStyle)
                            }), settings.slicerText.background) {
                                var backgroundColor = explore.util.hexToRGBString(settings.slicerText.background, (100 - settings.slicerText.transparency) / 100);
                                this.slicerBody.style("background-color", backgroundColor);
                            } else this.slicerBody.style("background-color", null);
                            if (this.interactivityService && this.slicerBody) {
                                this.interactivityService.applySelectionStateToData(data.slicerDataPoints);
                                var slicerBody = this.slicerBody.attr("width", this.currentViewport.width), slicerItemContainers = slicerBody.selectAll(ChicletSlicer.ItemContainerSelector.selector), slicerItemLabels = slicerBody.selectAll(ChicletSlicer.LabelTextSelector.selector), slicerItemInputs = slicerBody.selectAll(ChicletSlicer.InputSelector.selector), slicerClear = this.slicerHeader.select(ChicletSlicer.ClearSelector.selector), behaviorOptions = {
                                    dataPoints: data.slicerDataPoints,
                                    slicerItemContainers: slicerItemContainers,
                                    slicerItemLabels: slicerItemLabels,
                                    slicerItemInputs: slicerItemInputs,
                                    slicerClear: slicerClear,
                                    interactivityService: this.interactivityService,
                                    slicerSettings: data.slicerSettings,
                                    isSelectionLoaded: this.isSelectionLoaded
                                };
                                this.interactivityService.bind(data.slicerDataPoints, this.behavior, behaviorOptions, {
                                    overrideSelectionFromData: !0,
                                    hasSelectionOverride: data.hasSelectionOverride
                                }), this.behavior.styleSlicerInputs(rowSelection.select(ChicletSlicer.ItemContainerSelector.selector), this.interactivityService.hasSelection());
                            } else this.behavior.styleSlicerInputs(rowSelection.select(ChicletSlicer.ItemContainerSelector.selector), !1);
                        }
                    }, ChicletSlicer.prototype.createSearchHeader = function(container) {
                        var _this = this;
                        this.searchHeader = $("<div>").appendTo(container).addClass("searchHeader").addClass("collapsed"), 
                        $("<div>").appendTo(this.searchHeader).attr("title", "Search").addClass("search");
                        var counter = 0;
                        this.searchInput = $("<input>").appendTo(this.searchHeader).attr("type", "text").attr("drag-resize-disabled", "true").addClass("searchInput").on("input", function() {
                            return _this.hostServices.persistProperties({
                                merge: [ {
                                    objectName: "general",
                                    selector: null,
                                    properties: {
                                        counter: counter++
                                    }
                                } ]
                            });
                        });
                    }, ChicletSlicer.prototype.updateSearchHeader = function() {
                        this.searchHeader.toggleClass("show", this.slicerData.slicerSettings.general.selfFilterEnabled), 
                        this.searchHeader.toggleClass("collapsed", !this.slicerData.slicerSettings.general.selfFilterEnabled);
                    }, ChicletSlicer.prototype.onLoadMoreData = function() {
                        !this.waitingForData && this.dataView.metadata && this.dataView.metadata.segment && (this.hostServices.loadMoreData(), 
                        this.waitingForData = !0);
                    }, ChicletSlicer.prototype.getSlicerBodyViewport = function(currentViewport) {
                        var settings = this.settings, headerHeight = settings.header.show ? this.getHeaderHeight() : 0, borderHeight = settings.header.outlineWeight, height = currentViewport.height - (headerHeight + borderHeight + settings.header.borderBottomWidth), width = currentViewport.width - ChicletSlicer.WidthOfScrollbar;
                        return {
                            height: Math.max(height, ChicletSlicer.MinSizeOfViewport),
                            width: Math.max(width, ChicletSlicer.MinSizeOfViewport)
                        };
                    }, ChicletSlicer.prototype.updateSlicerBodyDimensions = function() {
                        var slicerViewport = this.getSlicerBodyViewport(this.currentViewport);
                        this.slicerBody.style({
                            height: PixelConverter.toString(slicerViewport.height),
                            width: "100%"
                        });
                    }, ChicletSlicer.getChicletTextProperties = function(textSize) {
                        return {
                            fontFamily: ChicletSlicer.DefaultFontFamily,
                            fontSize: PixelConverter.fromPoint(textSize || ChicletSlicer.DefaultFontSizeInPt)
                        };
                    }, ChicletSlicer.prototype.getHeaderHeight = function() {
                        return TextMeasurementService.estimateSvgTextHeight(ChicletSlicer.getChicletTextProperties(this.settings.header.textSize));
                    }, ChicletSlicer.prototype.getRowHeight = function() {
                        var textSettings = this.settings.slicerText;
                        return 0 !== textSettings.height ? textSettings.height : TextMeasurementService.estimateSvgTextHeight(ChicletSlicer.getChicletTextProperties(textSettings.textSize));
                    }, ChicletSlicer.prototype.getBorderStyle = function(outlineElement) {
                        return "0px" === outlineElement ? "none" : "solid";
                    }, ChicletSlicer.prototype.getBorderWidth = function(outlineElement, outlineWeight) {
                        switch (outlineElement) {
                          case "None":
                            return "0px";

                          case "BottomOnly":
                            return "0px 0px " + outlineWeight + "px 0px";

                          case "TopOnly":
                            return outlineWeight + "px 0px 0px 0px";

                          case "TopBottom":
                            return outlineWeight + "px 0px " + outlineWeight + "px 0px";

                          case "LeftRight":
                            return "0px " + outlineWeight + "px 0px " + outlineWeight + "px";

                          case "Frame":
                            return outlineWeight + "px";

                          default:
                            return outlineElement.replace("1", outlineWeight.toString());
                        }
                    }, ChicletSlicer.prototype.getBorderRadius = function(borderType) {
                        switch (borderType) {
                          case ChicletBorderStyle.ROUNDED:
                            return "10px";

                          case ChicletBorderStyle.SQUARE:
                            return "0px";

                          default:
                            return "5px";
                        }
                    }, ChicletSlicer.capabilities = {
                        dataRoles: [ {
                            name: "Category",
                            kind: VisualDataRoleKind.Grouping,
                            displayName: "Category"
                        }, {
                            name: "Values",
                            kind: VisualDataRoleKind.Measure,
                            displayName: "Values"
                        }, {
                            name: "Image",
                            kind: VisualDataRoleKind.Grouping,
                            displayName: "Image"
                        } ],
                        objects: {
                            general: {
                                displayName: "General",
                                properties: {
                                    selection: {
                                        displayName: "Selection",
                                        type: {
                                            text: !0
                                        }
                                    },
                                    orientation: {
                                        displayName: "Orientation",
                                        type: {
                                            enumeration: Orientation.type
                                        }
                                    },
                                    columns: {
                                        displayName: "Columns",
                                        type: {
                                            numeric: !0
                                        }
                                    },
                                    rows: {
                                        displayName: "Rows",
                                        type: {
                                            numeric: !0
                                        }
                                    },
                                    showDisabled: {
                                        displayName: "Show Disabled",
                                        type: {
                                            enumeration: ChicletSlicerShowDisabled.type
                                        }
                                    },
                                    multiselect: {
                                        displayName: "Multiple selection",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    selected: {
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    filter: {
                                        type: {
                                            filter: {}
                                        }
                                    },
                                    selfFilter: {
                                        type: {
                                            filter: {
                                                selfFilter: !0
                                            }
                                        }
                                    },
                                    selfFilterEnabled: {
                                        type: {
                                            operations: {
                                                searchEnabled: !0
                                            }
                                        }
                                    },
                                    formatString: {
                                        type: {
                                            formatting: {
                                                formatString: !0
                                            }
                                        }
                                    }
                                }
                            },
                            header: {
                                displayName: "Header",
                                properties: {
                                    show: {
                                        displayName: "Show",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    title: {
                                        displayName: "Title",
                                        type: {
                                            text: !0
                                        }
                                    },
                                    fontColor: {
                                        displayName: "Font color",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    background: {
                                        displayName: "Background",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    outline: {
                                        displayName: "Outline",
                                        type: {
                                            formatting: {
                                                outline: !0
                                            }
                                        }
                                    },
                                    textSize: {
                                        displayName: "Text Size",
                                        type: {
                                            numeric: !0
                                        }
                                    },
                                    outlineColor: {
                                        displayName: "Outline Color",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    outlineWeight: {
                                        displayName: "Outline Weight",
                                        type: {
                                            numeric: !0
                                        }
                                    }
                                }
                            },
                            rows: {
                                displayName: "Chiclets",
                                properties: {
                                    fontColor: {
                                        displayName: "Text color",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    textSize: {
                                        displayName: "Text Size",
                                        type: {
                                            numeric: !0
                                        }
                                    },
                                    height: {
                                        displayName: "Height",
                                        type: {
                                            numeric: !0
                                        }
                                    },
                                    width: {
                                        displayName: "Width",
                                        type: {
                                            numeric: !0
                                        }
                                    },
                                    selectedColor: {
                                        displayName: "Selected Color",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    hoverColor: {
                                        displayName: "Hover Color",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    unselectedColor: {
                                        displayName: "Unselected Color",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    disabledColor: {
                                        displayName: "Disabled Color",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    background: {
                                        displayName: "Background",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    transparency: {
                                        displayName: "Transparency",
                                        description: "Set transparency for background color",
                                        type: {
                                            numeric: !0
                                        }
                                    },
                                    outline: {
                                        displayName: "Outline",
                                        type: {
                                            formatting: {
                                                outline: !0
                                            }
                                        }
                                    },
                                    outlineColor: {
                                        displayName: "Outline Color",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    outlineWeight: {
                                        displayName: "Outline Weight",
                                        type: {
                                            numeric: !0
                                        }
                                    },
                                    borderStyle: {
                                        displayName: "Outline Style",
                                        type: {
                                            enumeration: ChicletBorderStyle.type
                                        }
                                    }
                                }
                            },
                            images: {
                                displayName: "Images",
                                properties: {
                                    imageSplit: {
                                        displayName: "Image Split",
                                        type: {
                                            numeric: !0
                                        }
                                    },
                                    stretchImage: {
                                        displayName: "Stretch image",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    bottomImage: {
                                        displayName: "Bottom image",
                                        type: {
                                            bool: !0
                                        }
                                    }
                                }
                            }
                        },
                        dataViewMappings: [ {
                            conditions: [ {
                                Category: {
                                    max: 1
                                },
                                Image: {
                                    min: 0,
                                    max: 1
                                },
                                Values: {
                                    min: 0,
                                    max: 1
                                }
                            } ],
                            categorical: {
                                categories: {
                                    for: {
                                        in: "Category"
                                    },
                                    dataReductionAlgorithm: {
                                        top: {
                                            count: 1e4
                                        }
                                    }
                                },
                                values: {
                                    group: {
                                        by: "Image",
                                        select: [ {
                                            bind: {
                                                to: "Values"
                                            }
                                        } ],
                                        dataReductionAlgorithm: {
                                            top: {
                                                count: 1e4
                                            }
                                        }
                                    }
                                },
                                includeEmptyGroups: !0
                            }
                        } ],
                        supportsHighlight: !0,
                        sorting: {
                            default: {}
                        },
                        suppressDefaultTitle: !0
                    }, ChicletSlicer.DefaultFontFamily = "'Segoe UI', 'wf_segoe-ui_normal', helvetica, arial, sans-serif", 
                    ChicletSlicer.DefaultFontSizeInPt = 11, ChicletSlicer.cellTotalInnerPaddings = 8, 
                    ChicletSlicer.cellTotalInnerBorders = 2, ChicletSlicer.chicletTotalInnerRightLeftPaddings = 14, 
                    ChicletSlicer.MinImageSplit = 0, ChicletSlicer.MaxImageSplit = 100, ChicletSlicer.MinSizeOfViewport = 0, 
                    ChicletSlicer.WidthOfScrollbar = 17, ChicletSlicer.ItemContainerSelector = createClassAndSelector("slicerItemContainer"), 
                    ChicletSlicer.SlicerImgWrapperSelector = createClassAndSelector("slicer-img-wrapper"), 
                    ChicletSlicer.SlicerTextWrapperSelector = createClassAndSelector("slicer-text-wrapper"), 
                    ChicletSlicer.SlicerBodyHorizontalSelector = createClassAndSelector("slicerBody-horizontal"), 
                    ChicletSlicer.SlicerBodyVerticalSelector = createClassAndSelector("slicerBody-vertical"), 
                    ChicletSlicer.HeaderTextSelector = createClassAndSelector("headerText"), ChicletSlicer.ContainerSelector = createClassAndSelector("chicletSlicer"), 
                    ChicletSlicer.LabelTextSelector = createClassAndSelector("slicerText"), ChicletSlicer.HeaderSelector = createClassAndSelector("slicerHeader"), 
                    ChicletSlicer.InputSelector = createClassAndSelector("slicerCheckbox"), ChicletSlicer.ClearSelector = createClassAndSelector("clear"), 
                    ChicletSlicer.BodySelector = createClassAndSelector("slicerBody"), ChicletSlicer;
                }();
                samples.ChicletSlicer = ChicletSlicer;
                var ChicletSlicerChartConversion;
                !function(ChicletSlicerChartConversion) {
                    var ChicletSlicerConverter = function() {
                        function ChicletSlicerConverter(dataView, interactivityService) {
                            var dataViewCategorical = dataView.categorical;
                            this.dataViewCategorical = dataViewCategorical, this.dataViewMetadata = dataView.metadata, 
                            dataViewCategorical.categories && dataViewCategorical.categories.length > 0 && (this.category = dataViewCategorical.categories[0], 
                            this.categoryIdentities = this.category.identity, this.categoryValues = this.category.values, 
                            this.categoryColumnRef = this.category.identityFields, this.categoryFormatString = valueFormatter.getFormatString(this.category.source, samples.chicletSlicerProps.formatString)), 
                            this.dataPoints = [], this.interactivityService = interactivityService, this.hasSelectionOverride = !1;
                        }
                        return ChicletSlicerConverter.prototype.convert = function() {
                            if (this.dataPoints = [], this.numberOfCategoriesSelectedInData = 0, this.categoryValues) {
                                var numberOfScopeIds, objects = this.dataViewMetadata ? this.dataViewMetadata.objects : void 0, isInvertedSelectionMode = void 0;
                                if (objects && objects.general && objects.general.filter) {
                                    if (!this.categoryColumnRef) return;
                                    var filter = objects.general.filter, scopeIds = SQExprConverter.asScopeIdsContainer(filter, this.categoryColumnRef);
                                    scopeIds ? (isInvertedSelectionMode = scopeIds.isNot, numberOfScopeIds = scopeIds.scopeIds ? scopeIds.scopeIds.length : 0) : isInvertedSelectionMode = !1;
                                }
                                this.interactivityService && (void 0 === isInvertedSelectionMode ? isInvertedSelectionMode = this.interactivityService.isSelectionModeInverted() : this.interactivityService.setSelectionModeInverted(isInvertedSelectionMode));
                                for (var hasSelection = void 0, idx = 0; idx < this.categoryValues.length; idx++) {
                                    var selected = isCategoryColumnSelected(samples.chicletSlicerProps.selectedPropertyIdentifier, this.category, idx);
                                    if (null != selected) {
                                        hasSelection = selected;
                                        break;
                                    }
                                }
                                for (var dataViewCategorical = this.dataViewCategorical, formatStringProp = samples.chicletSlicerProps.formatString, value = -(1 / 0), imageURL = "", categoryIndex = 0, categoryCount = this.categoryValues.length; categoryIndex < categoryCount; categoryIndex++) {
                                    var categoryIsSelected = isCategoryColumnSelected(samples.chicletSlicerProps.selectedPropertyIdentifier, this.category, categoryIndex), selectable = !0;
                                    null != hasSelection && (isInvertedSelectionMode ? (null == this.category.objects && (categoryIsSelected = void 0), 
                                    null != categoryIsSelected ? categoryIsSelected = hasSelection : null == categoryIsSelected && (categoryIsSelected = !hasSelection)) : null == categoryIsSelected && (categoryIsSelected = !hasSelection)), 
                                    categoryIsSelected && this.numberOfCategoriesSelectedInData++;
                                    var categoryValue = this.categoryValues[categoryIndex], categoryLabel = valueFormatter.format(categoryValue, this.categoryFormatString);
                                    if (this.dataViewCategorical.values) for (var seriesIndex = 0; seriesIndex < this.dataViewCategorical.values.length; seriesIndex++) {
                                        var seriesData = dataViewCategorical.values[seriesIndex];
                                        null != seriesData.values[categoryIndex] && (value = seriesData.values[categoryIndex], 
                                        seriesData.highlights && (selectable = !(null === seriesData.highlights[categoryIndex])), 
                                        seriesData.source.groupName && "" !== seriesData.source.groupName && (imageURL = converterHelper.getFormattedLegendLabel(seriesData.source, dataViewCategorical.values, formatStringProp), 
                                        /^(ftp|http|https):\/\/[^ "]+$/.test(imageURL) || (imageURL = void 0)));
                                    }
                                    var categorySelectionId = SelectionIdBuilder.builder().withCategory(this.category, categoryIndex).createSelectionId();
                                    this.dataPoints.push({
                                        identity: categorySelectionId,
                                        category: categoryLabel,
                                        imageURL: imageURL,
                                        value: value,
                                        selected: categoryIsSelected,
                                        selectable: selectable
                                    });
                                }
                                null != numberOfScopeIds && numberOfScopeIds > this.numberOfCategoriesSelectedInData && (this.hasSelectionOverride = !0);
                            }
                        }, ChicletSlicerConverter;
                    }();
                    ChicletSlicerChartConversion.ChicletSlicerConverter = ChicletSlicerConverter;
                }(ChicletSlicerChartConversion || (ChicletSlicerChartConversion = {}));
                var ChicletSlicerTextMeasurementHelper;
                !function(ChicletSlicerTextMeasurementHelper) {
                    function estimateSvgTextBaselineDelta(textProperties) {
                        var rect = estimateSvgTextRect(textProperties);
                        return rect.y + rect.height;
                    }
                    function ensureDOM() {
                        spanElement || (spanElement = $("<span/>"), $("body").append(spanElement), svgTextElement = d3.select($("body").get(0)).append("svg").style({
                            height: "0px",
                            width: "0px",
                            position: "absolute"
                        }).append("text"), canvasCtx = $("<canvas/>").get(0).getContext("2d"));
                    }
                    function measureSvgTextRect(textProperties) {
                        return ensureDOM(), svgTextElement.style(null), svgTextElement.text(textProperties.text).attr({
                            visibility: "hidden",
                            "font-family": textProperties.fontFamily,
                            "font-size": textProperties.fontSize,
                            "font-weight": textProperties.fontWeight,
                            "font-style": textProperties.fontStyle,
                            "white-space": textProperties.whiteSpace || "nowrap"
                        }), svgTextElement.node().getBBox();
                    }
                    function estimateSvgTextRect(textProperties) {
                        var estimatedTextProperties = {
                            fontFamily: textProperties.fontFamily,
                            fontSize: textProperties.fontSize,
                            text: "M"
                        }, rect = measureSvgTextRect(estimatedTextProperties);
                        return rect;
                    }
                    var spanElement, svgTextElement, canvasCtx;
                    ChicletSlicerTextMeasurementHelper.estimateSvgTextBaselineDelta = estimateSvgTextBaselineDelta;
                }(ChicletSlicerTextMeasurementHelper = samples.ChicletSlicerTextMeasurementHelper || (samples.ChicletSlicerTextMeasurementHelper = {}));
                var ChicletSlicerWebBehavior = function() {
                    function ChicletSlicerWebBehavior() {}
                    return ChicletSlicerWebBehavior.prototype.bindEvents = function(options, selectionHandler) {
                        var _this = this, slicers = this.slicers = options.slicerItemContainers;
                        this.slicerItemLabels = options.slicerItemLabels, this.slicerItemInputs = options.slicerItemInputs;
                        var slicerClear = options.slicerClear;
                        this.dataPoints = options.dataPoints, this.interactivityService = options.interactivityService, 
                        this.slicerSettings = options.slicerSettings, this.options = options, this.options.isSelectionLoaded || this.loadSelection(selectionHandler), 
                        slicers.on("mouseover", function(d) {
                            d.selectable && (d.mouseOver = !0, d.mouseOut = !1, _this.renderMouseover());
                        }), slicers.on("mouseout", function(d) {
                            d.selectable && (d.mouseOver = !1, d.mouseOut = !0, _this.renderMouseover());
                        }), slicers.on("click", function(dataPoint, index) {
                            if (dataPoint.selectable) {
                                d3.event.preventDefault();
                                var settings = _this.slicerSettings;
                                if (d3.event.altKey && settings.general.multiselect) {
                                    var selectedIndexes = jQuery.map(_this.dataPoints, function(d, index) {
                                        if (d.selected) return index;
                                    }), selIndex = selectedIndexes.length > 0 ? selectedIndexes[selectedIndexes.length - 1] : 0;
                                    if (selIndex > index) {
                                        var temp = index;
                                        index = selIndex, selIndex = temp;
                                    }
                                    selectionHandler.handleClearSelection();
                                    for (var i = selIndex; i <= index; i++) selectionHandler.handleSelection(_this.dataPoints[i], !0);
                                } else (d3.event.ctrlKey || d3.event.metaKey) && settings.general.multiselect ? selectionHandler.handleSelection(dataPoint, !0) : selectionHandler.handleSelection(dataPoint, !1);
                                _this.saveSelection(selectionHandler);
                            }
                        }), slicerClear.on("click", function(d) {
                            selectionHandler.handleClearSelection(), _this.saveSelection(selectionHandler);
                        });
                    }, ChicletSlicerWebBehavior.prototype.loadSelection = function(selectionHandler) {
                        selectionHandler.handleClearSelection();
                        var savedSelectionIds = this.slicerSettings.general.getSavedSelection();
                        if (savedSelectionIds.length) {
                            var selectedDataPoints = this.dataPoints.filter(function(d) {
                                return savedSelectionIds.some(function(x) {
                                    return d.identity.getKey() === x;
                                });
                            });
                            selectedDataPoints.forEach(function(x) {
                                return selectionHandler.handleSelection(x, !0);
                            }), selectionHandler.persistSelectionFilter(samples.chicletSlicerProps.filterPropertyIdentifier);
                        }
                    }, ChicletSlicerWebBehavior.getFilterFromSelectors = function(selectionHandler, isSelectionModeInverted) {
                        var selectors = [], selectedIds = selectionHandler.selectedIds;
                        selectedIds.length > 0 && (selectors = _.chain(selectedIds).filter(function(value) {
                            return value.hasIdentity();
                        }).map(function(value) {
                            return value.getSelector();
                        }).value());
                        var filter = Selector.filterFromSelector(selectors, isSelectionModeInverted);
                        return filter;
                    }, ChicletSlicerWebBehavior.prototype.saveSelection = function(selectionHandler) {
                        var filter = ChicletSlicerWebBehavior.getFilterFromSelectors(selectionHandler, this.interactivityService.isSelectionModeInverted()), selectionIdKeys = selectionHandler.selectedIds.map(function(x) {
                            return x.getKey();
                        });
                        this.slicerSettings.general.setSavedSelection(filter, selectionIdKeys);
                    }, ChicletSlicerWebBehavior.prototype.renderSelection = function(hasSelection) {
                        hasSelection || this.interactivityService.isSelectionModeInverted() ? this.styleSlicerInputs(this.slicers, hasSelection) : this.slicers.style("background", this.slicerSettings.slicerText.unselectedColor);
                    }, ChicletSlicerWebBehavior.prototype.renderMouseover = function() {
                        var _this = this;
                        this.slicerItemLabels.style({
                            color: function(d) {
                                return d.mouseOver ? _this.slicerSettings.slicerText.hoverColor : d.mouseOut ? d.selected ? _this.slicerSettings.slicerText.fontColor : _this.slicerSettings.slicerText.fontColor : void 0;
                            }
                        });
                    }, ChicletSlicerWebBehavior.prototype.styleSlicerInputs = function(slicers, hasSelection) {
                        var settings = this.slicerSettings, selectedItems = [];
                        slicers.each(function(d) {
                            d.selectable && d.selected && selectedItems.push(d), d3.select(this).style({
                                background: d.selectable ? d.selected ? settings.slicerText.selectedColor : settings.slicerText.unselectedColor : settings.slicerText.disabledColor
                            }), d3.select(this).classed("slicerItem-disabled", !d.selectable);
                        });
                    }, ChicletSlicerWebBehavior;
                }();
                samples.ChicletSlicerWebBehavior = ChicletSlicerWebBehavior;
                var explore;
                !function(explore) {
                    var util;
                    !function(util) {
                        function hexToRGBString(hex, transparency) {
                            var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
                            hex = hex.replace(shorthandRegex, function(m, r, g, b) {
                                return r + r + g + g + b + b;
                            });
                            var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex), rgb = result ? {
                                r: parseInt(result[1], 16),
                                g: parseInt(result[2], 16),
                                b: parseInt(result[3], 16)
                            } : null;
                            return null === rgb ? "" : transparency || 0 === transparency ? "rgba(" + rgb.r + "," + rgb.g + "," + rgb.b + "," + transparency + ")" : "rgb(" + rgb.r + "," + rgb.g + "," + rgb.b + ")";
                        }
                        util.hexToRGBString = hexToRGBString;
                    }(util = explore.util || (explore.util = {}));
                }(explore || (explore = {}));
            }(samples = visuals.samples || (visuals.samples = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, jsCommon = window.jsCommon, powerbi = window.powerbi;
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var samples;
            !function(samples) {
                var PixelConverter = jsCommon.PixelConverter, createEnumType = powerbi.createEnumType, DataViewObjects = powerbi.DataViewObjects, ObjectEnumerationBuilder = powerbi.visuals.ObjectEnumerationBuilder, dataLabelUtils = powerbi.visuals.dataLabelUtils, converterHelper = powerbi.visuals.converterHelper, VisualDataRoleKind = powerbi.VisualDataRoleKind, createDisplayNameGetter = powerbi.data.createDisplayNameGetter, SelectionManager = powerbi.visuals.utility.SelectionManager, ColorHelper = powerbi.visuals.ColorHelper, valueFormatter = powerbi.visuals.valueFormatter, SelectionId = powerbi.visuals.SelectionId, SelectionIdBuilder = powerbi.visuals.SelectionIdBuilder, TooltipBuilder = powerbi.visuals.TooltipBuilder, AnimatorCommon = powerbi.visuals.AnimatorCommon, DataLabelManager = powerbi.DataLabelManager, shapes = powerbi.visuals.shapes, SVGUtil = powerbi.visuals.SVGUtil, TooltipManager = powerbi.visuals.TooltipManager, lessWithPrecision = powerbi.Double.lessWithPrecision, VisualLayout = function() {
                    function VisualLayout(defaultViewport, defaultMargin) {
                        this.defaultViewport = defaultViewport || {
                            width: 0,
                            height: 0
                        }, this.defaultMargin = defaultMargin || {
                            top: 0,
                            bottom: 0,
                            right: 0,
                            left: 0
                        };
                    }
                    return Object.defineProperty(VisualLayout.prototype, "margin", {
                        get: function() {
                            return this.marginValue || (this.margin = this.defaultMargin);
                        },
                        set: function(value) {
                            this.marginValue = VisualLayout.restrictToMinMax(value), this.update();
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(VisualLayout.prototype, "viewport", {
                        get: function() {
                            return this.viewportValue || (this.viewportValue = this.defaultViewport);
                        },
                        set: function(value) {
                            this.viewportValue = VisualLayout.restrictToMinMax(value, this.minViewport), this.update();
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(VisualLayout.prototype, "viewportIn", {
                        get: function() {
                            return this.viewportInValue || this.viewport;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(VisualLayout.prototype, "minViewport", {
                        get: function() {
                            return this.minViewportValue;
                        },
                        set: function(value) {
                            this.minViewportValue = value;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(VisualLayout.prototype, "viewportInIsZero", {
                        get: function() {
                            return 0 === this.viewportIn.width || 0 === this.viewportIn.height;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), VisualLayout.prototype.resetMargin = function() {
                        this.margin = this.defaultMargin;
                    }, VisualLayout.prototype.update = function() {
                        this.viewportInValue = VisualLayout.restrictToMinMax({
                            width: this.viewport.width - (this.margin.left + this.margin.right),
                            height: this.viewport.height - (this.margin.top + this.margin.bottom)
                        }, this.minViewportValue);
                    }, VisualLayout.restrictToMinMax = function(value, minValue) {
                        var result = $.extend({}, value);
                        return _.keys(value).forEach(function(x) {
                            return result[x] = Math.max(minValue && minValue[x] || 0, value[x]);
                        }), result;
                    }, VisualLayout;
                }(), ChordChartHelpers = function() {
                    function ChordChartHelpers() {}
                    return ChordChartHelpers.interpolateArc = function(arc) {
                        return function(data) {
                            if (!this.oldData) return this.oldData = data, function() {
                                return arc(data);
                            };
                            var interpolation = d3.interpolate(this.oldData, data);
                            return this.oldData = interpolation(0), function(x) {
                                return arc(interpolation(x));
                            };
                        };
                    }, ChordChartHelpers.addContext = function(context, fn) {
                        return function() {
                            return fn.apply(context, [ this ].concat(_.toArray(arguments)));
                        };
                    }, ChordChartHelpers;
                }(), ChordChartSettings = function() {
                    function ChordChartSettings() {
                        this.dataPoint = {
                            defaultColor: null,
                            showAllDataPoints: !1
                        }, this.axis = {
                            show: !0
                        }, this.labels = {
                            show: !0,
                            color: dataLabelUtils.defaultLabelColor,
                            fontSize: dataLabelUtils.DefaultFontSizeInPt
                        };
                    }
                    return Object.defineProperty(ChordChartSettings, "Default", {
                        get: function() {
                            return new this();
                        },
                        enumerable: !0,
                        configurable: !0
                    }), ChordChartSettings.parse = function(dataView, capabilities) {
                        var settings = new this();
                        if (!dataView || !dataView.metadata || !dataView.metadata.objects) return settings;
                        var properties = this.getProperties(capabilities);
                        for (var objectKey in capabilities.objects) for (var propKey in capabilities.objects[objectKey].properties) if (settings[objectKey] && _.has(settings[objectKey], propKey)) {
                            var type = capabilities.objects[objectKey].properties[propKey].type, getValueFn = this.getValueFnByType(type);
                            settings[objectKey][propKey] = getValueFn(dataView.metadata.objects, properties[objectKey][propKey], settings[objectKey][propKey]);
                        }
                        return settings;
                    }, ChordChartSettings.getProperties = function(capabilities) {
                        var objects = _.merge({
                            general: {
                                properties: {
                                    formatString: {}
                                }
                            }
                        }, capabilities.objects), properties = {};
                        for (var objectKey in objects) {
                            properties[objectKey] = {};
                            for (var propKey in objects[objectKey].properties) properties[objectKey][propKey] = {
                                objectName: objectKey,
                                propertyName: propKey
                            };
                        }
                        return properties;
                    }, ChordChartSettings.createEnumTypeFromEnum = function(type) {
                        var even = !1;
                        return createEnumType(Object.keys(type).filter(function(key, i) {
                            return !!(i % 2) === even && type[key] === key && !void (even = !even) || !!(i % 2) !== even;
                        }).map(function(x) {
                            return {
                                value: x,
                                displayName: x
                            };
                        }));
                    }, ChordChartSettings.getValueFnByType = function(type) {
                        switch (_.keys(type)[0]) {
                          case "fill":
                            return DataViewObjects.getFillColor;

                          default:
                            return DataViewObjects.getValue;
                        }
                    }, ChordChartSettings.enumerateObjectInstances = function(settings, options, capabilities) {
                        var enumeration = new ObjectEnumerationBuilder(), object = settings && settings[options.objectName];
                        if (!object) return enumeration;
                        var instance = {
                            objectName: options.objectName,
                            selector: null,
                            properties: {}
                        };
                        for (var key in object) _.has(object, key) && (instance.properties[key] = object[key]);
                        return enumeration.pushInstance(instance), enumeration;
                    }, ChordChartSettings;
                }();
                samples.ChordChartSettings = ChordChartSettings;
                var ChordChartColumns = function() {
                    function ChordChartColumns() {
                        this.Category = null, this.Series = null, this.Y = null;
                    }
                    return ChordChartColumns.getColumnSources = function(dataView) {
                        return this.getColumnSourcesT(dataView);
                    }, ChordChartColumns.getTableValues = function(dataView) {
                        var table = dataView && dataView.table, columns = this.getColumnSourcesT(dataView);
                        return columns && table && _.mapValues(columns, function(n, i) {
                            return n && table.rows.map(function(row) {
                                return row[n.index];
                            });
                        });
                    }, ChordChartColumns.getTableRows = function(dataView) {
                        var table = dataView && dataView.table, columns = this.getColumnSourcesT(dataView);
                        return columns && table && table.rows.map(function(row) {
                            return _.mapValues(columns, function(n, i) {
                                return n && row[n.index];
                            });
                        });
                    }, ChordChartColumns.getCategoricalValues = function(dataView) {
                        var categorical = dataView && dataView.categorical, categories = categorical && categorical.categories || [], values = categorical && categorical.values || [], series = categorical && values.source && this.getSeriesValues(dataView);
                        return categorical && _.mapValues(new this(), function(n, i) {
                            return _.toArray(categories).concat(_.toArray(values)).filter(function(x) {
                                return x.source.roles && x.source.roles[i];
                            }).map(function(x) {
                                return x.values;
                            })[0] || values.source && values.source.roles && values.source.roles[i] && series;
                        });
                    }, ChordChartColumns.getSeriesValues = function(dataView) {
                        return dataView && dataView.categorical && dataView.categorical.values && dataView.categorical.values.map(function(x) {
                            return converterHelper.getSeriesName(x.source);
                        });
                    }, ChordChartColumns.getCategoricalColumns = function(dataView) {
                        var categorical = dataView && dataView.categorical, categories = categorical && categorical.categories || [], values = categorical && categorical.values || [];
                        return categorical && _.mapValues(new this(), function(n, i) {
                            return categories.filter(function(x) {
                                return x.source.roles && x.source.roles[i];
                            })[0] || values.source && values.source.roles && values.source.roles[i] || values.filter(function(x) {
                                return x.source.roles && x.source.roles[i];
                            });
                        });
                    }, ChordChartColumns.getColumnSourcesT = function(dataView) {
                        var columns = dataView && dataView.metadata && dataView.metadata.columns;
                        return columns && _.mapValues(new this(), function(n, i) {
                            return columns.filter(function(x) {
                                return x.roles && x.roles[i];
                            })[0];
                        });
                    }, ChordChartColumns.Roles = Object.freeze(_.mapValues(new ChordChartColumns(), function(x, i) {
                        return i;
                    })), ChordChartColumns;
                }();
                samples.ChordChartColumns = ChordChartColumns;
                var ChordChart = function() {
                    function ChordChart() {}
                    return Object.defineProperty(ChordChart.prototype, "settings", {
                        get: function() {
                            return this.data && this.data.settings;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(ChordChart.prototype, "innerRadius", {
                        get: function() {
                            return this.radius * ChordChart.InnerArcRadiusRatio;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(ChordChart.prototype, "outerRadius", {
                        get: function() {
                            return this.radius * ChordChart.OuterArcRadiusRatio;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), ChordChart.converter = function(dataView, colors, prevAxisVisible) {
                        var properties = ChordChartSettings.getProperties(ChordChart.capabilities), settings = ChordChart.parseSettings(dataView), columns = ChordChartColumns.getCategoricalColumns(dataView), sources = ChordChartColumns.getColumnSources(dataView), catValues = ChordChartColumns.getCategoricalValues(dataView);
                        if (!catValues || _.isEmpty(catValues.Category) || _.isEmpty(catValues.Y)) return null;
                        catValues.Series = catValues.Series || ChordChartColumns.getSeriesValues(dataView);
                        var dataMatrix = [], legendData = {
                            dataPoints: [],
                            title: sources.Y.displayName || ""
                        }, toolTipData = [], sliceTooltipData = [], max = 1e3, seriesIndex = _.mapValues(_.invert(catValues.Series), parseFloat), catIndex = _.mapValues(_.invert(catValues.Category), parseFloat), isDiffFromTo = !1, labelData = [], colorHelper = new ColorHelper(colors, properties.dataPoint.fill, settings.dataPoint.defaultColor), totalFields = this.union_arrays(catValues.Category, catValues.Series).reverse();
                        ChordChart.getValidArrayLength(totalFields) === ChordChart.getValidArrayLength(catValues.Category) + ChordChart.getValidArrayLength(catValues.Series) && (isDiffFromTo = !0);
                        for (var categoryColumnFormatter = valueFormatter.create({
                            format: valueFormatter.getFormatString(sources.Category, properties.general.formatString, !0) || sources.Category.format
                        }), valueColumnFormatter = valueFormatter.create({
                            format: valueFormatter.getFormatString(sources.Y, properties.general.formatString, !0) || sources.Y.format
                        }), i = 0, iLen = totalFields.length; i < iLen; i++) {
                            var id = null, color = "", isCategory = !1;
                            if (void 0 !== catIndex[totalFields[i]]) {
                                var index = catIndex[totalFields[i]];
                                id = SelectionIdBuilder.builder().withCategory(columns.Category, catIndex[totalFields[i]]).createSelectionId(), 
                                isCategory = !0;
                                var thisCategoryObjects = columns.Category.objects ? columns.Category.objects[index] : void 0;
                                color = colorHelper.getColorForSeriesValue(thisCategoryObjects, void 0, catValues.Category[index]);
                            } else if (void 0 !== seriesIndex[totalFields[i]]) {
                                var index = seriesIndex[totalFields[i]], seriesData = columns.Y[index], seriesObjects = seriesData && seriesData.objects && seriesData.objects[0], seriesNameStr = converterHelper.getSeriesName(seriesData.source);
                                id = SelectionId.createWithId(seriesData.identity), isCategory = !1, color = colorHelper.getColorForSeriesValue(seriesObjects, void 0, seriesNameStr);
                            }
                            labelData.push({
                                label: totalFields[i],
                                labelColor: settings.labels.color,
                                barColor: color,
                                isCategory: isCategory,
                                identity: id,
                                selected: !1,
                                labelFontSize: PixelConverter.fromPointToPixel(settings.labels.fontSize)
                            }), dataMatrix.push([]), toolTipData.push([]);
                            for (var j = 0, jLen = totalFields.length; j < jLen; j++) {
                                var elementValue = 0, tooltipInfo = [];
                                if (void 0 !== catIndex[totalFields[i]] && void 0 !== seriesIndex[totalFields[j]]) {
                                    var row = catIndex[totalFields[i]], col = seriesIndex[totalFields[j]];
                                    null !== columns.Y[col].values[row] && (elementValue = columns.Y[col].values[row], 
                                    elementValue > max && (max = elementValue), tooltipInfo = TooltipBuilder.createTooltipInfo(properties.general.formatString, dataView.categorical, categoryColumnFormatter.format(catValues.Category[i]), valueColumnFormatter.format(elementValue), null, null, col, row));
                                } else if (isDiffFromTo && void 0 !== catIndex[totalFields[j]] && void 0 !== seriesIndex[totalFields[i]]) {
                                    var row = catIndex[totalFields[j]], col = seriesIndex[totalFields[i]];
                                    null !== columns.Y[col].values[row] && (elementValue = columns.Y[col].values[row]);
                                }
                                dataMatrix[i].push(elementValue || 0), toolTipData[i].push({
                                    tooltipInfo: tooltipInfo
                                });
                            }
                            var totalSum = d3.sum(dataMatrix[i]);
                            sliceTooltipData.push({
                                tooltipInfo: [ {
                                    displayName: totalFields[i],
                                    value: valueColumnFormatter.format(totalSum)
                                } ]
                            });
                        }
                        var labelDataPoints, chordLayout = d3.layout.chord().padding(ChordChart.ChordLayoutPadding).matrix(dataMatrix), chordLayoutGroups = chordLayout.groups(), groups = ChordChart.copyArcDescriptorsWithoutNaNValues(chordLayoutGroups), chords = chordLayout.chords(), unitLength = Math.round(max / 5).toString().length - 1;
                        return labelDataPoints = ChordChart.getChordArcDescriptors(ChordChart.copyArcDescriptorsWithoutNaNValues(chordLayoutGroups), labelData), 
                        {
                            dataMatrix: dataMatrix,
                            dataView: dataView,
                            settings: settings,
                            labelDataPoints: labelDataPoints,
                            legendData: legendData,
                            tooltipData: toolTipData,
                            sliceTooltipData: sliceTooltipData,
                            tickUnit: Math.pow(10, unitLength),
                            differentFromTo: isDiffFromTo,
                            prevAxisVisible: void 0 === prevAxisVisible ? settings.axis.show : prevAxisVisible,
                            groups: groups,
                            chords: chords
                        };
                    }, ChordChart.parseSettings = function(dataView) {
                        return ChordChartSettings.parse(dataView, ChordChart.capabilities);
                    }, ChordChart.getValidArrayLength = function(array) {
                        for (var len = 0, i = 0, iLen = array.length; i < iLen; i++) void 0 !== array[i] && len++;
                        return len;
                    }, ChordChart.getChordArcDescriptors = function(groups, datum) {
                        return groups.forEach(function(x, index) {
                            x.data = datum[index];
                        }), groups;
                    }, ChordChart.prototype.init = function(options) {
                        var element = options.element;
                        this.selectionManager = new SelectionManager({
                            hostServices: options.host
                        }), this.layout = new VisualLayout(options.viewport, ChordChart.DefaultMargin), 
                        this.layout.minViewport = {
                            width: 150,
                            height: 150
                        }, this.svg = d3.select(element.get(0)).append("svg").style("position", "absolute").classed(ChordChart.VisualClassName, !0), 
                        this.mainGraphicsContext = this.svg.append("g"), this.mainGraphicsContext.append("g").classed("chords", !0), 
                        this.slices = this.mainGraphicsContext.append("g").classed("slices", !0), this.mainGraphicsContext.append("g").classed("ticks", !0), 
                        this.labels = this.mainGraphicsContext.append("g").classed(ChordChart.labelGraphicsContextClass.class, !0), 
                        this.lines = this.mainGraphicsContext.append("g").classed(ChordChart.linesGraphicsContextClass.class, !0), 
                        this.colors = options.style.colorPalette.dataColors;
                    }, ChordChart.prototype.update = function(options) {
                        if (options.dataViews && options.dataViews[0]) {
                            if (this.layout.viewport = options.viewport, this.duration = options.suppressAnimations ? 0 : AnimatorCommon.MinervaAnimationDuration, 
                            this.data = ChordChart.converter(options.dataViews[0], this.colors, this.settings && this.settings.axis.show), 
                            !this.data) return void this.clear();
                            this.layout.resetMargin(), this.layout.margin.top = this.layout.margin.bottom = PixelConverter.fromPointToPixel(this.settings.labels.fontSize) / 2, 
                            this.render();
                        }
                    }, ChordChart.prototype.enumerateObjectInstances = function(options) {
                        var instances = ChordChartSettings.enumerateObjectInstances(this.settings, options, ChordChart.capabilities);
                        if (this.settings && "dataPoint" === options.objectName && !_.isEmpty(this.data.labelDataPoints) && this.settings.dataPoint.showAllDataPoints) for (var i = 0, length = this.data.labelDataPoints.length; i < length; i++) {
                            var labelDataPoint = this.data.labelDataPoints[i].data;
                            if (labelDataPoint.isCategory) {
                                var colorInstance = {
                                    objectName: "dataPoint",
                                    displayName: labelDataPoint.label,
                                    selector: ColorHelper.normalizeSelector(labelDataPoint.identity.getSelector()),
                                    properties: {
                                        fill: {
                                            solid: {
                                                color: labelDataPoint.barColor
                                            }
                                        }
                                    }
                                };
                                instances.pushInstance(colorInstance);
                            }
                        }
                        return instances.complete();
                    }, ChordChart.prototype.calculateRadius = function() {
                        if (this.settings.labels.show) {
                            var hw = this.layout.viewportIn.height / this.layout.viewportIn.width, denom = 2 + 1 / (1 + Math.exp(-5 * (hw - 1)));
                            return Math.min(this.layout.viewportIn.height, this.layout.viewportIn.width) / denom;
                        }
                        return Math.min(this.layout.viewportIn.height, this.layout.viewportIn.width) / 2;
                    }, ChordChart.prototype.drawCategoryLabels = function() {
                        var arc = d3.svg.arc().innerRadius(0).outerRadius(this.innerRadius), outerArc = d3.svg.arc().innerRadius(this.outerRadius).outerRadius(this.outerRadius);
                        if (this.settings.labels.show) {
                            var labelLayout = this.getChordChartLabelLayout(outerArc), filteredData = this.getDataLabelManager().hideCollidedLabels(this.layout.viewportIn, this.data.labelDataPoints, labelLayout, !0);
                            this.renderLabels(filteredData, labelLayout, !0), this.renderLines(filteredData, arc, outerArc);
                        } else dataLabelUtils.cleanDataLabels(this.labels), dataLabelUtils.cleanDataLabels(this.lines, !0);
                    }, ChordChart.prototype.getDataLabelManager = function() {
                        function hasCollisions(arrangeGrid, info, position, size) {
                            if (arrangeGrid.hasConflict(position)) return !0;
                            var intersection = {
                                left: 0,
                                top: position.height / 2,
                                width: size.width,
                                height: size.height
                            };
                            return intersection = shapes.Rect.inflate(intersection, {
                                left: DataLabelManager.InflateAmount,
                                top: 0,
                                right: DataLabelManager.InflateAmount,
                                bottom: 0
                            }), intersection = shapes.Rect.intersect(intersection, position), !!shapes.Rect.isEmpty(intersection) || lessWithPrecision(intersection.height, position.height / 2);
                        }
                        var dataLabelManager = new DataLabelManager();
                        return dataLabelManager.hasCollisions = hasCollisions.bind(dataLabelManager), dataLabelManager;
                    }, ChordChart.prototype.render = function() {
                        var _this = this;
                        this.radius = this.calculateRadius();
                        var arc = d3.svg.arc().innerRadius(this.radius).outerRadius(this.innerRadius);
                        this.svg.attr({
                            width: this.layout.viewport.width,
                            height: this.layout.viewport.height
                        }), this.mainGraphicsContext.attr("transform", SVGUtil.translate(this.layout.viewport.width / 2, this.layout.viewport.height / 2));
                        var sliceShapes = this.slices.selectAll("path" + ChordChart.sliceClass.selector).data(this.getChordTicksArcDescriptors());
                        sliceShapes.enter().insert("path").classed(ChordChart.sliceClass.class, !0), sliceShapes.style("fill", function(d, i) {
                            return _this.data.labelDataPoints[i].data.barColor;
                        }).style("stroke", function(d, i) {
                            return _this.data.labelDataPoints[i].data.barColor;
                        }).on("click", ChordChartHelpers.addContext(this, function(context, d, i) {
                            _this.selectionManager.select(_this.data.labelDataPoints[i].data.identity).then(function(ids) {
                                ids.length > 0 ? (_this.mainGraphicsContext.selectAll(".chords path.chord").style("opacity", 1), 
                                _this.slices.selectAll("path.slice").style("opacity", .3), _this.mainGraphicsContext.selectAll(".chords path.chord").filter(function(d) {
                                    return d.source.index !== i && d.target.index !== i;
                                }).style("opacity", .3), d3.select(context).style("opacity", 1)) : (sliceShapes.style("opacity", 1), 
                                _this.mainGraphicsContext.selectAll(".chords path.chord").filter(function(d) {
                                    return d.source.index !== i && d.target.index !== i;
                                }).style("opacity", 1));
                            }), d3.event.stopPropagation();
                        })).transition().duration(this.duration).attrTween("d", ChordChartHelpers.interpolateArc(arc)), 
                        sliceShapes.exit().remove(), TooltipManager.addTooltip(sliceShapes, function(tooltipEvent) {
                            return _this.data.sliceTooltipData[tooltipEvent.data.index].tooltipInfo;
                        });
                        var chordShapes = this.svg.select(".chords").selectAll("path" + ChordChart.chordClass.selector).data(this.data.chords);
                        chordShapes.enter().insert("path").classed(ChordChart.chordClass.class, !0), chordShapes.style({
                            fill: function(d) {
                                return _this.data.labelDataPoints[d.target.index].data.barColor;
                            },
                            opacity: 1
                        }).transition().duration(this.duration).attr("d", d3.svg.chord().radius(this.radius)), 
                        chordShapes.exit().remove(), this.svg.on("click", function() {
                            return _this.selectionManager.clear().then(function() {
                                sliceShapes.style("opacity", 1), chordShapes.style("opacity", 1);
                            });
                        }), this.drawTicks(), this.drawCategoryLabels(), TooltipManager.addTooltip(chordShapes, function(tooltipEvent) {
                            var tooltipInfo = [];
                            return _this.data.differentFromTo ? tooltipInfo = _this.data.tooltipData[tooltipEvent.data.source.index][tooltipEvent.data.source.subindex].tooltipInfo : (tooltipInfo.push({
                                displayName: _this.data.labelDataPoints[tooltipEvent.data.source.index].data.label + "->" + _this.data.labelDataPoints[tooltipEvent.data.source.subindex].data.label,
                                value: _this.data.dataMatrix[tooltipEvent.data.source.index][tooltipEvent.data.source.subindex].toString()
                            }), tooltipInfo.push({
                                displayName: _this.data.labelDataPoints[tooltipEvent.data.target.index].data.label + "->" + _this.data.labelDataPoints[tooltipEvent.data.target.subindex].data.label,
                                value: _this.data.dataMatrix[tooltipEvent.data.target.index][tooltipEvent.data.target.subindex].toString()
                            })), tooltipInfo;
                        });
                    }, ChordChart.prototype.clear = function() {
                        this.mainGraphicsContext.selectAll(ChordChart.sliceClass.selector).remove(), this.mainGraphicsContext.selectAll(ChordChart.sliceTicksClass.selector).remove(), 
                        this.mainGraphicsContext.selectAll(ChordChart.chordClass.selector).remove(), this.mainGraphicsContext.selectAll(ChordChart.labelsClass.selector).remove(), 
                        this.mainGraphicsContext.selectAll(ChordChart.lineClass.selector).remove();
                    }, ChordChart.prototype.clearTicks = function() {
                        var empty = [], tickLines = this.mainGraphicsContext.selectAll(ChordChart.tickLineClass.selector).data(empty);
                        tickLines.exit().remove();
                        var tickTexts = this.mainGraphicsContext.selectAll(ChordChart.tickTextClass.selector).data(empty);
                        tickTexts.exit().remove(), this.mainGraphicsContext.selectAll(ChordChart.tickPairClass.selector).remove(), 
                        this.mainGraphicsContext.selectAll(ChordChart.sliceTicksClass.selector).remove();
                    }, ChordChart.prototype.getChordTicksArcDescriptors = function() {
                        var groups = this.data.groups, maxValue = !_.isEmpty(groups) && _.max(groups, function(x) {
                            return x.value;
                        }).value || 0, minValue = !_.isEmpty(groups) && _.min(groups, function(x) {
                            return x.value;
                        }).value || 0, radiusCoeff = this.radius / Math.abs(maxValue - minValue) * 1.25, formatter = valueFormatter.create({
                            format: "0.##",
                            value: maxValue
                        });
                        return groups.forEach(function(x) {
                            var k = (x.endAngle - x.startAngle) / x.value, absValue = Math.abs(x.value), range = d3.range(0, absValue, absValue - 1 < .15 ? .15 : absValue - 1);
                            x.value < 0 && (range = range.map(function(x) {
                                return x * -1;
                            }).reverse());
                            for (var i = 1; i < range.length; i++) {
                                var gapSize = Math.abs(range[i] - range[i - 1]) * radiusCoeff;
                                gapSize < ChordChart.TicksFontSize && (range.length > 2 && i === range.length - 1 ? range.splice(--i, 1) : range.splice(i--, 1));
                            }
                            x.angleLabels = range.map(function(v, i) {
                                return {
                                    angle: v * k + x.startAngle,
                                    label: formatter.format(v)
                                };
                            });
                        }), groups;
                    }, ChordChart.copyArcDescriptorsWithoutNaNValues = function(arcDescriptors) {
                        return _.isEmpty(arcDescriptors) ? arcDescriptors : arcDescriptors.map(function(sourceArcDescriptor) {
                            var targetArcDescriptor = {};
                            for (var propertyName in sourceArcDescriptor) !sourceArcDescriptor[propertyName] && isNaN(sourceArcDescriptor[propertyName]) ? targetArcDescriptor[propertyName] = 0 : targetArcDescriptor[propertyName] = sourceArcDescriptor[propertyName];
                            return targetArcDescriptor;
                        });
                    }, ChordChart.prototype.drawTicks = function() {
                        var _this = this;
                        if (this.settings.axis.show) {
                            var tickShapes = this.mainGraphicsContext.select(".ticks").selectAll("g" + ChordChart.sliceTicksClass.selector).data(this.data.groups), animDuration = this.data.prevAxisVisible === this.settings.axis.show ? this.duration : 0;
                            tickShapes.enter().insert("g").classed(ChordChart.sliceTicksClass.class, !0);
                            var tickPairs = tickShapes.selectAll("g" + ChordChart.tickPairClass.selector).data(function(d) {
                                return d.angleLabels;
                            });
                            tickPairs.enter().insert("g").classed(ChordChart.tickPairClass.class, !0), tickPairs.transition().duration(animDuration).attr("transform", function(d) {
                                return "rotate(" + (180 * d.angle / Math.PI - 90) + ")translate(" + _this.innerRadius + ",0)";
                            }), tickPairs.selectAll("line" + ChordChart.tickLineClass.selector).data(function(d) {
                                return [ d ];
                            }).enter().insert("line").classed(ChordChart.tickLineClass.class, !0).style("stroke", "#000").attr("x1", 1).attr("y1", 0).attr("x2", 5).attr("y2", 0), 
                            tickPairs.selectAll("text" + ChordChart.tickTextClass.selector).data(function(d) {
                                return [ d ];
                            }).enter().insert("text").classed(ChordChart.tickTextClass.class, !0).style("pointer-events", "none").attr("x", 8).attr("dy", ".35em"), 
                            tickPairs.selectAll("text" + ChordChart.tickTextClass.selector).text(function(d) {
                                return d.label;
                            }).style("text-anchor", function(d) {
                                return d.angle > Math.PI ? "end" : null;
                            }).attr("transform", function(d) {
                                return d.angle > Math.PI ? "rotate(180)translate(-16)" : null;
                            }), tickPairs.exit().remove(), tickShapes.exit().remove();
                        } else this.clearTicks();
                    }, ChordChart.prototype.renderLabels = function(filteredData, layout, isDonut, forAnimation) {
                        if (void 0 === isDonut && (isDonut = !1), void 0 === forAnimation && (forAnimation = !1), 
                        0 === filteredData.length) return dataLabelUtils.cleanDataLabels(this.labels, !0), 
                        null;
                        var hasKey = null !== filteredData[0].key, hasDataPointIdentity = null !== filteredData[0].identity, getIdentifier = hasKey ? function(d) {
                            return d.key;
                        } : hasDataPointIdentity ? function(d) {
                            return d.identity.getKey();
                        } : void 0, dataLabels = isDonut ? this.labels.selectAll(ChordChart.labelsClass.selector).data(filteredData, function(d) {
                            return d.data.identity.getKey();
                        }) : null !== getIdentifier ? this.labels.selectAll(ChordChart.labelsClass.selector).data(filteredData, getIdentifier) : this.labels.selectAll(ChordChart.labelsClass.selector).data(filteredData), newLabels = dataLabels.enter().append("text").classed(ChordChart.labelsClass.class, !0);
                        forAnimation && newLabels.style("opacity", 0), dataLabels.attr({
                            x: function(d) {
                                return d.labelX;
                            },
                            y: function(d) {
                                return d.labelY;
                            },
                            dy: ".35em"
                        }).text(function(d) {
                            return d.labeltext;
                        }).style(layout.style), dataLabels.exit().remove();
                    }, ChordChart.prototype.renderLines = function(filteredData, arc, outerArc) {
                        var _this = this, lines = this.lines.selectAll("polyline").data(filteredData, function(d) {
                            return d.data.identity.getKey();
                        }), midAngle = function(d) {
                            return d.startAngle + (d.endAngle - d.startAngle) / 2;
                        };
                        lines.enter().append("polyline").classed(ChordChart.lineClass.class, !0), lines.attr("points", function(d) {
                            var textPoint = outerArc.centroid(d);
                            textPoint[0] = (_this.radius + ChordChart.LabelMargin / 2) * (midAngle(d) < Math.PI ? 1 : -1);
                            var midPoint = outerArc.centroid(d), chartPoint = arc.centroid(d);
                            return chartPoint[0] *= ChordChart.InnerLinePointMultiplier, chartPoint[1] *= ChordChart.InnerLinePointMultiplier, 
                            [ chartPoint, midPoint, textPoint ];
                        }).style({
                            opacity: function(d) {
                                return ChordChart.PolylineOpacity;
                            },
                            stroke: function(d) {
                                return d.data.labelColor;
                            },
                            "pointer-events": "none"
                        }), lines.exit().remove();
                    }, ChordChart.prototype.getChordChartLabelLayout = function(outerArc) {
                        var _this = this, midAngle = function(d) {
                            return d.startAngle + (d.endAngle - d.startAngle) / 2;
                        }, maxLabelWidth = (this.layout.viewportIn.width - 2 * this.radius - 2 * ChordChart.LabelMargin) / 1.6;
                        return {
                            labelText: function(d) {
                                return dataLabelUtils.getLabelFormattedText({
                                    label: d.data.label,
                                    maxWidth: maxLabelWidth,
                                    fontSize: PixelConverter.fromPointToPixel(_this.settings.labels.fontSize)
                                });
                            },
                            labelLayout: {
                                x: function(d) {
                                    return (_this.radius + ChordChart.LabelMargin) * (midAngle(d) < Math.PI ? 1 : -1);
                                },
                                y: function(d) {
                                    var pos = outerArc.centroid(d);
                                    return pos[1];
                                }
                            },
                            filter: function(d) {
                                return null !== d && null !== d.data && null !== d.data.label;
                            },
                            style: {
                                fill: function(d) {
                                    return d.data.labelColor;
                                },
                                "text-anchor": function(d) {
                                    return midAngle(d) < Math.PI ? "start" : "end";
                                },
                                "font-size": function(d) {
                                    return PixelConverter.fromPoint(_this.settings.labels.fontSize);
                                }
                            }
                        };
                    }, ChordChart.union_arrays = function(x, y) {
                        for (var obj = {}, i = 0; i < x.length; i++) obj[x[i]] = x[i];
                        for (var i = 0; i < y.length; i++) obj[y[i]] = y[i];
                        var res = [];
                        for (var k in obj) obj.hasOwnProperty(k) && res.push(obj[k]);
                        return res;
                    }, ChordChart.capabilities = {
                        dataRoles: [ {
                            name: ChordChartColumns.Roles.Category,
                            kind: VisualDataRoleKind.Grouping,
                            displayName: "From"
                        }, {
                            name: ChordChartColumns.Roles.Series,
                            kind: VisualDataRoleKind.Grouping,
                            displayName: "To"
                        }, {
                            name: ChordChartColumns.Roles.Y,
                            kind: VisualDataRoleKind.Measure,
                            displayName: "Values"
                        } ],
                        dataViewMappings: [ {
                            conditions: [ {
                                Category: {
                                    max: 1
                                },
                                Series: {
                                    max: 0
                                }
                            }, {
                                Category: {
                                    max: 1
                                },
                                Series: {
                                    min: 1,
                                    max: 1
                                },
                                Y: {
                                    max: 1
                                }
                            }, {
                                Category: {
                                    max: 1
                                },
                                Series: {
                                    max: 0
                                },
                                Y: {
                                    min: 0,
                                    max: 1
                                }
                            } ],
                            categorical: {
                                categories: {
                                    for: {
                                        in: "Category"
                                    },
                                    dataReductionAlgorithm: {
                                        top: {}
                                    }
                                },
                                values: {
                                    group: {
                                        by: "Series",
                                        select: [ {
                                            bind: {
                                                to: "Y"
                                            }
                                        } ],
                                        dataReductionAlgorithm: {
                                            top: {}
                                        }
                                    }
                                },
                                rowCount: {
                                    preferred: {
                                        min: 2
                                    },
                                    supported: {
                                        min: 1
                                    }
                                }
                            }
                        } ],
                        objects: {
                            dataPoint: {
                                displayName: createDisplayNameGetter("Visual_DataPoint"),
                                properties: {
                                    defaultColor: {
                                        displayName: createDisplayNameGetter("Visual_DefaultColor"),
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    showAllDataPoints: {
                                        displayName: createDisplayNameGetter("Visual_DataPoint_Show_All"),
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    fill: {
                                        displayName: createDisplayNameGetter("Visual_Fill"),
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    }
                                }
                            },
                            axis: {
                                displayName: "Axis",
                                properties: {
                                    show: {
                                        type: {
                                            bool: !0
                                        }
                                    }
                                }
                            },
                            labels: {
                                displayName: "Labels",
                                properties: {
                                    show: {
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    color: {
                                        displayName: createDisplayNameGetter("Visual_Reference_Line_Data_Label_Color"),
                                        description: createDisplayNameGetter("Visual_Reference_Line_Data_Label_Color_Description"),
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    fontSize: {
                                        displayName: createDisplayNameGetter("Visual_TextSize"),
                                        type: {
                                            formatting: {
                                                fontSize: !0
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }, ChordChart.PolylineOpacity = .5, ChordChart.OuterArcRadiusRatio = .9, ChordChart.InnerArcRadiusRatio = .8, 
                    ChordChart.LabelMargin = 10, ChordChart.DefaultMargin = {
                        left: 10,
                        right: 10,
                        top: 10,
                        bottom: 10
                    }, ChordChart.VisualClassName = "chordChart", ChordChart.TicksFontSize = 12, ChordChart.InnerLinePointMultiplier = 2.05, 
                    ChordChart.ChordLayoutPadding = .1, ChordChart.sliceClass = {
                        class: "slice",
                        selector: ".slice"
                    }, ChordChart.chordClass = {
                        class: "chord",
                        selector: ".chord"
                    }, ChordChart.sliceTicksClass = {
                        class: "slice-ticks",
                        selector: ".slice-ticks"
                    }, ChordChart.tickPairClass = {
                        class: "tick-pair",
                        selector: ".tick-pair"
                    }, ChordChart.tickLineClass = {
                        class: "tick-line",
                        selector: ".tick-line"
                    }, ChordChart.tickTextClass = {
                        class: "tick-text",
                        selector: ".tick-text"
                    }, ChordChart.labelGraphicsContextClass = {
                        class: "labels",
                        selector: ".labels"
                    }, ChordChart.labelsClass = {
                        class: "data-labels",
                        selector: ".data-labels"
                    }, ChordChart.linesGraphicsContextClass = {
                        class: "lines",
                        selector: ".lines"
                    }, ChordChart.lineClass = {
                        class: "line-label",
                        selector: ".line-label"
                    }, ChordChart;
                }();
                samples.ChordChart = ChordChart;
            }(samples = visuals.samples || (visuals.samples = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, jsCommon = window.jsCommon, powerbi = window.powerbi;
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var samples;
            !function(samples) {
                var PixelConverter = jsCommon.PixelConverter, createClassAndSelector = jsCommon.CssConstants.createClassAndSelector, getCategoryIndexOfRole = powerbi.data.DataRoleHelper.getCategoryIndexOfRole, getMeasureIndexOfRole = powerbi.data.DataRoleHelper.getMeasureIndexOfRole, registerStandardInteractivityHandlers = powerbi.visuals.InteractivityUtils.registerStandardInteractivityHandlers, Lazy = jsCommon.Lazy, measureSvgTextWidth = powerbi.TextMeasurementService.measureSvgTextWidth, measureSvgTextHeight = powerbi.TextMeasurementService.measureSvgTextHeight, estimateSvgTextHeight = powerbi.TextMeasurementService.estimateSvgTextHeight, svgEllipsis = powerbi.TextMeasurementService.svgEllipsis, addTooltip = powerbi.visuals.TooltipManager.addTooltip, fromPoint = jsCommon.PixelConverter.fromPoint, LabelTextProperties = powerbi.visuals.dataLabelUtils.LabelTextProperties, getLabelFormattedText = powerbi.visuals.dataLabelUtils.getLabelFormattedText, equalWithPrecision = powerbi.Double.equalWithPrecision, GetAnimationDuration = powerbi.visuals.AnimatorCommon.GetAnimationDuration, getTailoredTextOrDefault = powerbi.TextMeasurementService.getTailoredTextOrDefault, LegendData = powerbi.visuals.LegendData, SelectionId = powerbi.visuals.SelectionId, DataViewObject = powerbi.DataViewObject, VisualDataRoleKind = powerbi.VisualDataRoleKind, legendPosition = powerbi.visuals.legendPosition, BaseAnimator = powerbi.visuals.BaseAnimator, yAxisPosition = powerbi.visuals.yAxisPosition, appendClearCatcher = powerbi.visuals.appendClearCatcher, createInteractivityService = powerbi.visuals.createInteractivityService, createLegend = powerbi.visuals.createLegend, AxisHelper = powerbi.visuals.AxisHelper, DataViewObjects = powerbi.DataViewObjects, valueFormatter = powerbi.visuals.valueFormatter, dataLabelUtils = powerbi.visuals.dataLabelUtils, ColorHelper = powerbi.visuals.ColorHelper, LegendIcon = powerbi.visuals.LegendIcon, SelectionIdBuilder = powerbi.visuals.SelectionIdBuilder, TooltipBuilder = powerbi.visuals.TooltipBuilder, getInvalidValueWarnings = powerbi.visuals.getInvalidValueWarnings, legendProps = powerbi.visuals.legendProps, LegendPosition = powerbi.visuals.LegendPosition, Legend = powerbi.visuals.Legend, SVGUtil = powerbi.visuals.SVGUtil, ObjectEnumerationBuilder = powerbi.visuals.ObjectEnumerationBuilder, GradientUtils = powerbi.visuals.GradientUtils, axisType = powerbi.visuals.axisType, axisScale = powerbi.visuals.axisScale, axisStyle = powerbi.visuals.axisStyle, EnhancedScatterChart = function() {
                    function EnhancedScatterChart() {
                        this.ScrollBarWidth = 10;
                    }
                    return Object.defineProperty(EnhancedScatterChart.prototype, "margin", {
                        get: function() {
                            return this._margin || {
                                left: 0,
                                right: 0,
                                top: 0,
                                bottom: 0
                            };
                        },
                        set: function(value) {
                            this._margin = $.extend({}, value), this._viewportIn = EnhancedScatterChart.substractMargin(this.viewport, this.margin);
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(EnhancedScatterChart.prototype, "viewport", {
                        get: function() {
                            return this._viewport || {
                                width: 0,
                                height: 0
                            };
                        },
                        set: function(value) {
                            this._viewport = $.extend({}, value), this._viewportIn = EnhancedScatterChart.substractMargin(this.viewport, this.margin);
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(EnhancedScatterChart.prototype, "viewportIn", {
                        get: function() {
                            return this._viewportIn || this.viewport;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(EnhancedScatterChart.prototype, "legendViewport", {
                        get: function() {
                            return this.legend.getMargins();
                        },
                        enumerable: !0,
                        configurable: !0
                    }), EnhancedScatterChart.getPropertiesByCapabilities = function(capabilities) {
                        var propertiesByCapabilities = {};
                        if (!capabilities) return propertiesByCapabilities;
                        for (var objectName in capabilities.objects) {
                            var objectDescriptor = capabilities.objects[objectName];
                            if (propertiesByCapabilities[objectName] = {}, objectDescriptor) for (var propertyName in objectDescriptor.properties) propertiesByCapabilities[objectName][propertyName] = {
                                objectName: objectName,
                                propertyName: propertyName
                            };
                        }
                        return propertiesByCapabilities;
                    }, EnhancedScatterChart.substractMargin = function(viewport, margin) {
                        return {
                            width: Math.max(viewport.width - (margin.left + margin.right), 0),
                            height: Math.max(viewport.height - (margin.top + margin.bottom), 0)
                        };
                    }, EnhancedScatterChart.getCustomSymbolType = function(shape) {
                        var customSymbolTypes = d3.map({
                            circle: function(size) {
                                var r = Math.sqrt(size / Math.PI);
                                return "M0," + r + "A" + r + "," + r + " 0 1,1 0," + -r + "A" + r + "," + r + " 0 1,1 0," + r + "Z";
                            },
                            cross: function(size) {
                                var r = Math.sqrt(size / 5) / 2;
                                return "M" + -3 * r + "," + -r + "H" + -r + "V" + -3 * r + "H" + r + "V" + -r + "H" + 3 * r + "V" + r + "H" + r + "V" + 3 * r + "H" + -r + "V" + r + "H" + -3 * r + "Z";
                            },
                            diamond: function(size) {
                                var ry = Math.sqrt(size / (2 * Math.tan(Math.PI / 6))), rx = ry * Math.tan(Math.PI / 6);
                                return "M0," + -ry + "L" + rx + ",0 0," + ry + " " + -rx + ",0Z";
                            },
                            square: function(size) {
                                var r = Math.sqrt(size) / 2;
                                return "M" + -r + "," + -r + "L" + r + "," + -r + " " + r + "," + r + " " + -r + "," + r + "Z";
                            },
                            "triangle-up": function(size) {
                                var rx = Math.sqrt(size / Math.sqrt(3)), ry = rx * Math.sqrt(3) / 2;
                                return "M0," + -ry + "L" + rx + "," + ry + " " + -rx + "," + ry + "Z";
                            },
                            "triangle-down": function(size) {
                                var rx = Math.sqrt(size / Math.sqrt(3)), ry = rx * Math.sqrt(3) / 2;
                                return "M0," + ry + "L" + rx + "," + -ry + " " + -rx + "," + -ry + "Z";
                            },
                            star: function(size) {
                                for (var outerRadius = Math.sqrt(size / 2), innerRadius = Math.sqrt(size / 10), results = "", angle = Math.PI / 5, i = 0; i < 10; i++) {
                                    var r = 0 === (1 & i) ? outerRadius : innerRadius, currX = Math.cos(i * angle) * r, currY = Math.sin(i * angle) * r;
                                    0 === i ? results = "M" + currX + "," + currY + "L" : results += " " + currX + "," + currY;
                                }
                                return results + "Z";
                            },
                            hexagon: function(size) {
                                var r = Math.sqrt(size / (6 * Math.sqrt(3))), r2 = Math.sqrt(size / (2 * Math.sqrt(3)));
                                return "M0," + 2 * r + "L" + -r2 + "," + r + " " + -r2 + "," + -r + " 0," + -2 * r + " " + r2 + "," + -r + " " + r2 + "," + r + "Z";
                            },
                            x: function(size) {
                                var r = Math.sqrt(size / 10);
                                return "M0," + r + "L" + -r + "," + 2 * r + " " + -2 * r + "," + r + " " + -r + ",0 " + -2 * r + "," + -r + " " + -r + "," + -2 * r + " 0," + -r + " " + r + "," + -2 * r + " " + 2 * r + "," + -r + " " + r + ",0 " + 2 * r + "," + r + " " + r + "," + 2 * r + "Z";
                            },
                            uparrow: function(size) {
                                var r = Math.sqrt(size / 12);
                                return "M" + r + "," + 3 * r + "L" + -r + "," + 3 * r + " " + -r + "," + -r + " " + -2 * r + "," + -r + " 0," + -3 * r + " " + 2 * r + "," + -r + " " + r + "," + -r + "Z";
                            },
                            downarrow: function(size) {
                                var r = Math.sqrt(size / 12);
                                return "M0," + 3 * r + "L" + -2 * r + "," + r + " " + -r + "," + r + " " + -r + "," + -3 * r + " " + r + "," + -3 * r + " " + r + "," + r + " " + 2 * r + "," + r + "Z";
                            }
                        }), defaultValue = customSymbolTypes.entries()[0].value;
                        if (shape) {
                            if (isNaN(shape)) return customSymbolTypes[shape && shape.toString().toLowerCase()] || defaultValue;
                            var result = customSymbolTypes.entries()[Math.floor(shape)];
                            return result ? result.value : defaultValue;
                        }
                        return defaultValue;
                    }, EnhancedScatterChart.prototype.init = function(options) {
                        this.options = options, this.animator = new BaseAnimator(), this.behavior = new CustomVisualBehavior([ new EnhancedScatterChartWebBehavior(EnhancedScatterChart.DimmedBubbleOpacity, EnhancedScatterChart.DefaultBubbleOpacity) ]);
                        var element = this.element = options.element;
                        this.viewport = _.clone(options.viewport), this.style = options.style, this.hostServices = options.host, 
                        this.colors = this.style.colorPalette.dataColors, this.interactivity = options.interactivity, 
                        this.margin = {
                            top: 1,
                            right: 1,
                            bottom: 1,
                            left: 1
                        }, this.yAxisOrientation = yAxisPosition.left, this.adjustMargins();
                        var showLinesOnX = this.scrollY = !0, showLinesOnY = this.scrollX = !0, svg = this.svg = d3.select(element.get(0)).append("svg").style("position", "absolute").classed(EnhancedScatterChart.ClassName, !0), axisGraphicsContext = this.axisGraphicsContext = svg.append("g").classed(EnhancedScatterChart.AxisGraphicsContextClassName, !0);
                        this.svgScrollable = svg.append("svg").classed("svgScrollable", !0).style("overflow", "hidden");
                        var axisGraphicsContextScrollable = this.axisGraphicsContextScrollable = this.svgScrollable.append("g").classed(EnhancedScatterChart.AxisGraphicsContextClassName, !0);
                        this.clearCatcher = appendClearCatcher(this.axisGraphicsContextScrollable);
                        var axisGroup = showLinesOnX ? axisGraphicsContextScrollable : axisGraphicsContext;
                        this.backgroundGraphicsContext = axisGraphicsContext.append("svg:image"), this.xAxisGraphicsContext = showLinesOnX ? axisGraphicsContext.append("g").attr("class", "x axis") : axisGraphicsContextScrollable.append("g").attr("class", "x axis"), 
                        this.y1AxisGraphicsContext = axisGroup.append("g").attr("class", "y axis"), this.xAxisGraphicsContext.classed("showLinesOnAxis", showLinesOnX), 
                        this.y1AxisGraphicsContext.classed("showLinesOnAxis", showLinesOnY), this.xAxisGraphicsContext.classed("hideLinesOnAxis", !showLinesOnX), 
                        this.y1AxisGraphicsContext.classed("hideLinesOnAxis", !showLinesOnY), this.interactivityService = createInteractivityService(this.hostServices), 
                        this.legend = createLegend(element, this.interactivity && this.interactivity.isInteractiveLegend, this.interactivityService, !0), 
                        this.mainGraphicsG = this.axisGraphicsContextScrollable.append("g").classed(EnhancedScatterChart.MainGraphicsContextClassName, !0), 
                        this.mainGraphicsSVGSelection = this.mainGraphicsG.append("svg"), this.mainGraphicsContext = this.mainGraphicsSVGSelection.append("g"), 
                        this.svgDefaultImage = "", this.keyArray = [];
                    }, EnhancedScatterChart.prototype.adjustMargins = function() {
                        var xAxis = this.element.find(".x.axis");
                        0 === AxisHelper.getRecommendedNumberOfTicksForXAxis(this.viewportIn.width) && 0 === AxisHelper.getRecommendedNumberOfTicksForYAxis(this.viewportIn.height) ? (this.margin = {
                            top: 0,
                            right: 0,
                            bottom: 0,
                            left: 0
                        }, xAxis.hide()) : xAxis.show();
                    }, EnhancedScatterChart.prototype.getValueAxisProperties = function(dataViewMetadata, axisTitleOnByDefault) {
                        var toReturn = {};
                        if (!dataViewMetadata) return toReturn;
                        var objects = dataViewMetadata.objects;
                        if (objects) {
                            var valueAxisObject = objects.valueAxis;
                            valueAxisObject && (toReturn = {
                                show: valueAxisObject.show,
                                position: valueAxisObject.position,
                                axisScale: valueAxisObject.axisScale,
                                start: valueAxisObject.start,
                                end: valueAxisObject.end,
                                showAxisTitle: null == valueAxisObject.showAxisTitle ? axisTitleOnByDefault : valueAxisObject.showAxisTitle,
                                axisStyle: valueAxisObject.axisStyle,
                                axisColor: valueAxisObject.axisColor,
                                secShow: valueAxisObject.secShow,
                                secPosition: valueAxisObject.secPosition,
                                secAxisScale: valueAxisObject.secAxisScale,
                                secStart: valueAxisObject.secStart,
                                secEnd: valueAxisObject.secEnd,
                                secShowAxisTitle: valueAxisObject.secShowAxisTitle,
                                secAxisStyle: valueAxisObject.secAxisStyle,
                                labelDisplayUnits: valueAxisObject.labelDisplayUnits
                            });
                        }
                        return toReturn;
                    }, EnhancedScatterChart.prototype.getCategoryAxisProperties = function(dataViewMetadata, axisTitleOnByDefault) {
                        var toReturn = {};
                        if (!dataViewMetadata) return toReturn;
                        var objects = dataViewMetadata.objects;
                        if (objects) {
                            var categoryAxisObject = objects.categoryAxis;
                            categoryAxisObject && (toReturn = {
                                show: categoryAxisObject.show,
                                axisType: categoryAxisObject.axisType,
                                axisScale: categoryAxisObject.axisScale,
                                axisColor: categoryAxisObject.axisColor,
                                start: categoryAxisObject.start,
                                end: categoryAxisObject.end,
                                showAxisTitle: null == categoryAxisObject.showAxisTitle ? axisTitleOnByDefault : categoryAxisObject.showAxisTitle,
                                axisStyle: categoryAxisObject.axisStyle,
                                labelDisplayUnits: categoryAxisObject.labelDisplayUnits
                            });
                        }
                        return toReturn;
                    }, EnhancedScatterChart.converter = function(dataView, colorPalette, interactivityService, categoryAxisProperties, valueAxisProperties) {
                        if (!dataView) return EnhancedScatterChart.getDefaultData();
                        var categoryValues, categoryFormatter, categoryObjects, categoryIdentities, categoryQueryName, dataViewCategorical = dataView.categorical, dataViewMetadata = dataView.metadata, categories = dataViewCategorical.categories || [], dataValues = dataViewCategorical.values, hasDynamicSeries = !!dataValues.source, grouped = dataValues.grouped(), dvSource = dataValues.source, scatterMetadata = EnhancedScatterChart.getMetadata(categories, grouped, dvSource), categoryIndex = scatterMetadata.idx.category, useShape = scatterMetadata.idx.image >= 0, useCustomColor = scatterMetadata.idx.colorFill >= 0;
                        if (dataViewCategorical.categories && dataViewCategorical.categories.length > 0 && dataViewCategorical.categories[categoryIndex]) {
                            var mainCategory = dataViewCategorical.categories[categoryIndex];
                            categoryValues = mainCategory.values, categoryFormatter = valueFormatter.create({
                                format: valueFormatter.getFormatString(mainCategory.source, EnhancedScatterChart.Properties.general.formatString),
                                value: categoryValues[0],
                                value2: categoryValues[categoryValues.length - 1]
                            }), categoryIdentities = mainCategory.identity, categoryObjects = mainCategory.objects, 
                            categoryQueryName = mainCategory.source ? mainCategory.source.queryName : null;
                        } else categoryValues = [ null ], categoryFormatter = valueFormatter.createDefaultFormatter(null);
                        var dataLabelsSettings = dataLabelUtils.getDefaultPointLabelSettings(), fillPoint = !1, backdrop = {
                            show: !1,
                            url: ""
                        }, crosshair = !1, outline = !1, defaultDataPointColor = "", showAllDataPoints = !0;
                        if (dataViewMetadata && dataViewMetadata.objects) {
                            var objects = dataViewMetadata.objects;
                            defaultDataPointColor = DataViewObjects.getFillColor(objects, EnhancedScatterChart.Properties.dataPoint.defaultColor), 
                            showAllDataPoints = DataViewObjects.getValue(objects, EnhancedScatterChart.Properties.dataPoint.showAllDataPoints);
                            var labelsObj = objects.categoryLabels;
                            labelsObj && (dataLabelsSettings.show = void 0 !== labelsObj.show ? labelsObj.show : dataLabelsSettings.show, 
                            dataLabelsSettings.fontSize = void 0 !== labelsObj.fontSize ? labelsObj.fontSize : dataLabelsSettings.fontSize, 
                            void 0 !== labelsObj.color && (dataLabelsSettings.labelColor = labelsObj.color.solid.color)), 
                            fillPoint = DataViewObjects.getValue(objects, EnhancedScatterChart.Properties.fillPoint.show, fillPoint);
                            var backdropObject = objects.backdrop;
                            void 0 !== backdropObject && (backdrop.show = backdropObject.show, backdrop.show && (backdrop.url = backdropObject.url));
                            var crosshairObject = objects.crosshair;
                            void 0 !== crosshairObject && (crosshair = crosshairObject.show);
                            var outlineObject = objects.outline;
                            void 0 !== outlineObject && (outline = outlineObject.show);
                        }
                        var dataPoints = EnhancedScatterChart.createDataPoints(dataValues, scatterMetadata, categories, categoryValues, categoryFormatter, categoryIdentities, categoryObjects, colorPalette, hasDynamicSeries, dataLabelsSettings, defaultDataPointColor, categoryQueryName);
                        interactivityService && interactivityService.applySelectionStateToData(dataPoints);
                        var legendItems = [];
                        if (hasDynamicSeries) {
                            var formatString = valueFormatter.getFormatString(dvSource, EnhancedScatterChart.Properties.general.formatString);
                            legendItems = EnhancedScatterChart.createSeriesLegend(dataValues, colorPalette, dataValues, formatString, defaultDataPointColor);
                        }
                        var legendTitle = dataValues && dvSource ? dvSource.displayName : "";
                        legendTitle || (legendTitle = categories && categories[categoryIndex] && categories[categoryIndex].source && categories[categoryIndex].source.displayName ? categories[categoryIndex].source.displayName : "");
                        var legendData = {
                            title: legendTitle,
                            dataPoints: legendItems
                        }, sizeRange = EnhancedScatterChart.getSizeRangeForGroups(grouped, scatterMetadata.idx.size);
                        if (categoryAxisProperties && null !== categoryAxisProperties.showAxisTitle && categoryAxisProperties.showAxisTitle === !1 && (scatterMetadata.axesLabels.x = null), 
                        valueAxisProperties && null !== valueAxisProperties.showAxisTitle && valueAxisProperties.showAxisTitle === !1 && (scatterMetadata.axesLabels.y = null), 
                        dataPoints && dataPoints[0]) {
                            var point = dataPoints[0];
                            null != point.backdrop && (backdrop.show = !0, backdrop.url = point.backdrop), null != point.xStart && (categoryAxisProperties.start = point.xStart), 
                            null != point.xEnd && (categoryAxisProperties.end = point.xEnd), null != point.yStart && (valueAxisProperties.start = point.yStart), 
                            null != point.yEnd && (valueAxisProperties.end = point.yEnd);
                        }
                        return {
                            xCol: scatterMetadata.cols.x,
                            yCol: scatterMetadata.cols.y,
                            dataPoints: dataPoints,
                            legendData: legendData,
                            axesLabels: scatterMetadata.axesLabels,
                            selectedIds: [],
                            size: scatterMetadata.cols.size,
                            sizeRange: sizeRange,
                            dataLabelsSettings: dataLabelsSettings,
                            defaultDataPointColor: defaultDataPointColor,
                            hasDynamicSeries: hasDynamicSeries,
                            showAllDataPoints: showAllDataPoints,
                            fillPoint: fillPoint,
                            useShape: useShape,
                            useCustomColor: useCustomColor,
                            backdrop: backdrop,
                            crosshair: crosshair,
                            outline: outline
                        };
                    }, EnhancedScatterChart.createSeriesLegend = function(dataValues, colorPalette, categorical, formatString, defaultDataPointColor) {
                        for (var legendItems = [], grouped = dataValues.grouped(), colorHelper = new ColorHelper(colorPalette, EnhancedScatterChart.Properties.dataPoint.fill, defaultDataPointColor), i = 0, len = grouped.length; i < len; i++) {
                            var selectionId, color, grouping = grouped[i];
                            color = colorHelper.getColorForSeriesValue(grouping.objects, dataValues.identityFields, grouping.name), 
                            selectionId = grouping.identity ? SelectionId.createWithId(grouping.identity) : SelectionId.createNull(), 
                            legendItems.push({
                                color: color,
                                icon: LegendIcon.Circle,
                                label: valueFormatter.format(grouping.name, formatString),
                                identity: selectionId,
                                selected: !1
                            });
                        }
                        return legendItems;
                    }, EnhancedScatterChart.getSizeRangeForGroups = function(dataViewValueGroups, sizeColumnIndex) {
                        var result = {};
                        return dataViewValueGroups && dataViewValueGroups.forEach(function(group) {
                            var sizeColumn = EnhancedScatterChart.getMeasureValue(sizeColumnIndex, group.values), currentRange = AxisHelper.getRangeForColumn(sizeColumn);
                            (null == result.min || result.min > currentRange.min) && (result.min = currentRange.min), 
                            (null == result.max || result.max < currentRange.max) && (result.max = currentRange.max);
                        }), result;
                    }, EnhancedScatterChart.getMetadata = function(categories, grouped, source) {
                        var xCol, yCol, sizeCol, categoryIndex = getCategoryIndexOfRole(categories, EnhancedScatterChart.ColumnCategory), colorFillIndex = getCategoryIndexOfRole(categories, EnhancedScatterChart.ColumnColorFill), imageIndex = getCategoryIndexOfRole(categories, EnhancedScatterChart.ColumnImage), backdropIndex = getCategoryIndexOfRole(categories, EnhancedScatterChart.ColumnBackdrop), xIndex = getMeasureIndexOfRole(grouped, EnhancedScatterChart.ColumnX), yIndex = getMeasureIndexOfRole(grouped, EnhancedScatterChart.ColumnY), sizeIndex = getMeasureIndexOfRole(grouped, EnhancedScatterChart.ColumnSize), shapeIndex = getMeasureIndexOfRole(grouped, EnhancedScatterChart.ColumnShape), rotationIndex = getMeasureIndexOfRole(grouped, EnhancedScatterChart.ColumnRotation), xStartIndex = getMeasureIndexOfRole(grouped, EnhancedScatterChart.ColumnXStart), xEndIndex = getMeasureIndexOfRole(grouped, EnhancedScatterChart.ColumnXEnd), yStartIndex = getMeasureIndexOfRole(grouped, EnhancedScatterChart.ColumnYStart), yEndIndex = getMeasureIndexOfRole(grouped, EnhancedScatterChart.ColumnYEnd), xAxisLabel = "", yAxisLabel = "";
                        if (grouped && grouped.length) {
                            var firstGroup = grouped[0];
                            xIndex >= 0 && (xCol = firstGroup.values[xIndex].source, xAxisLabel = firstGroup.values[xIndex].source.displayName), 
                            yIndex >= 0 && (yCol = firstGroup.values[yIndex].source, yAxisLabel = firstGroup.values[yIndex].source.displayName), 
                            sizeIndex >= 0 && (sizeCol = firstGroup.values[sizeIndex].source);
                        }
                        return {
                            idx: {
                                category: categoryIndex,
                                x: xIndex,
                                y: yIndex,
                                size: sizeIndex,
                                colorFill: colorFillIndex,
                                shape: shapeIndex,
                                image: imageIndex,
                                rotation: rotationIndex,
                                backdrop: backdropIndex,
                                xStart: xStartIndex,
                                xEnd: xEndIndex,
                                yStart: yStartIndex,
                                yEnd: yEndIndex
                            },
                            cols: {
                                x: xCol,
                                y: yCol,
                                size: sizeCol
                            },
                            axesLabels: {
                                x: xAxisLabel,
                                y: yAxisLabel
                            }
                        };
                    }, EnhancedScatterChart.createLazyFormattedCategory = function(formatter, value) {
                        return new Lazy(function() {
                            return formatter.format(value);
                        });
                    }, EnhancedScatterChart.createDataPoints = function(dataValues, metadata, categories, categoryValues, categoryFormatter, categoryIdentities, categoryObjects, colorPalette, hasDynamicSeries, labelSettings, defaultDataPointColor, categoryQueryName) {
                        var colorHelper, formatStringProp, dataPoints = [], indicies = metadata.idx, dataValueSource = dataValues.source, grouped = dataValues.grouped(), fontSizeInPx = PixelConverter.fromPoint(labelSettings.fontSize);
                        formatStringProp = EnhancedScatterChart.Properties.general.formatString, colorHelper = new ColorHelper(colorPalette, EnhancedScatterChart.Properties.dataPoint.fill, defaultDataPointColor);
                        for (var categoryIdx = 0, ilen = categoryValues.length; categoryIdx < ilen; categoryIdx++) for (var categoryValue = categoryValues[categoryIdx], seriesIdx = 0, len = grouped.length; seriesIdx < len; seriesIdx++) {
                            var measureColorFill = categories[indicies.colorFill], measureImage = categories[indicies.image], measureBackdrop = categories[indicies.backdrop], grouping = grouped[seriesIdx], seriesValues = grouping.values, measureX = EnhancedScatterChart.getMeasureValue(indicies.x, seriesValues), measureY = EnhancedScatterChart.getMeasureValue(indicies.y, seriesValues), measureSize = EnhancedScatterChart.getMeasureValue(indicies.size, seriesValues), measureShape = EnhancedScatterChart.getMeasureValue(indicies.shape, seriesValues), measureRotation = EnhancedScatterChart.getMeasureValue(indicies.rotation, seriesValues), measureXStart = EnhancedScatterChart.getMeasureValue(indicies.xStart, seriesValues), measureXEnd = EnhancedScatterChart.getMeasureValue(indicies.xEnd, seriesValues), measureYStart = EnhancedScatterChart.getMeasureValue(indicies.yStart, seriesValues), measureYEnd = EnhancedScatterChart.getMeasureValue(indicies.yEnd, seriesValues), xVal = measureX && measureX.values && !isNaN(measureX.values[categoryIdx]) ? measureX.values[categoryIdx] : null, yVal = measureY && measureY.values && !isNaN(measureY.values[categoryIdx]) ? measureY.values[categoryIdx] : 0, hasNullValue = null == xVal || null == yVal;
                            if (!hasNullValue) {
                                var size, colorFill, shapeSymbolType, image, rotation, backdrop, xStart, xEnd, yStart, yEnd, color;
                                if (size = EnhancedScatterChart.getValueFromDataViewValueColumnById(measureSize, categoryIdx), 
                                colorFill = EnhancedScatterChart.getValueFromDataViewValueColumnById(measureColorFill, categoryIdx), 
                                shapeSymbolType = EnhancedScatterChart.getCustomSymbolType(EnhancedScatterChart.getValueFromDataViewValueColumnById(measureShape, categoryIdx)), 
                                image = EnhancedScatterChart.getValueFromDataViewValueColumnById(measureImage, categoryIdx), 
                                rotation = EnhancedScatterChart.getNumberFromDataViewValueColumnById(measureRotation, categoryIdx), 
                                backdrop = EnhancedScatterChart.getValueFromDataViewValueColumnById(measureBackdrop, categoryIdx), 
                                xStart = EnhancedScatterChart.getValueFromDataViewValueColumnById(measureXStart, categoryIdx), 
                                xEnd = EnhancedScatterChart.getValueFromDataViewValueColumnById(measureXEnd, categoryIdx), 
                                yStart = EnhancedScatterChart.getValueFromDataViewValueColumnById(measureYStart, categoryIdx), 
                                yEnd = EnhancedScatterChart.getValueFromDataViewValueColumnById(measureYEnd, categoryIdx), 
                                hasDynamicSeries) color = colorHelper.getColorForSeriesValue(grouping.objects, dataValues.identityFields, grouping.name); else {
                                    var measureSource = null != measureSize ? measureSize.source.queryName : "";
                                    color = colorHelper.getColorForMeasure(categoryObjects && categoryObjects[categoryIdx], measureSource);
                                }
                                var category = categories && categories.length > 0 ? categories[indicies.category] : null, identity = SelectionIdBuilder.builder().withCategory(category, categoryIdx).withSeries(dataValues, grouping).createSelectionId(), seriesData = [];
                                dataValueSource && seriesData.push({
                                    value: grouping.name,
                                    metadata: {
                                        source: dataValueSource,
                                        values: []
                                    }
                                }), measureX && seriesData.push({
                                    value: xVal,
                                    metadata: measureX
                                }), measureY && seriesData.push({
                                    value: yVal,
                                    metadata: measureY
                                }), measureSize && measureSize.values && measureSize.values.length > 0 && seriesData.push({
                                    value: measureSize.values[categoryIdx],
                                    metadata: measureSize
                                }), measureColorFill && measureColorFill.values && measureColorFill.values.length > 0 && seriesData.push({
                                    value: measureColorFill.values[categoryIdx],
                                    metadata: measureColorFill
                                }), measureShape && measureShape.values && measureShape.values.length > 0 && seriesData.push({
                                    value: measureShape.values[categoryIdx],
                                    metadata: measureShape
                                }), measureImage && measureImage.values && measureImage.values.length > 0 && seriesData.push({
                                    value: measureImage.values[categoryIdx],
                                    metadata: measureImage
                                }), measureRotation && measureRotation.values && measureRotation.values.length > 0 && seriesData.push({
                                    value: measureRotation.values[categoryIdx],
                                    metadata: measureRotation
                                }), measureBackdrop && measureBackdrop.values && measureBackdrop.values.length > 0 && seriesData.push({
                                    value: measureBackdrop.values[categoryIdx],
                                    metadata: measureBackdrop
                                }), measureXStart && measureXStart.values && measureXStart.values.length > 0 && seriesData.push({
                                    value: measureXStart.values[categoryIdx],
                                    metadata: measureXStart
                                }), measureXEnd && measureXEnd.values && measureXEnd.values.length > 0 && seriesData.push({
                                    value: measureXEnd.values[categoryIdx],
                                    metadata: measureXEnd
                                }), measureYStart && measureYStart.values && measureYStart.values.length > 0 && seriesData.push({
                                    value: measureYStart.values[categoryIdx],
                                    metadata: measureYStart
                                }), measureYEnd && measureYEnd.values && measureYEnd.values.length > 0 && seriesData.push({
                                    value: measureYEnd.values[categoryIdx],
                                    metadata: measureYEnd
                                });
                                var tooltipInfo = TooltipBuilder.createTooltipInfo(formatStringProp, void 0, categoryValue, null, category ? [ category ] : void 0, seriesData, void 0), dataPoint = {
                                    x: xVal,
                                    y: yVal,
                                    size: size,
                                    radius: {
                                        sizeMeasure: measureSize,
                                        index: categoryIdx
                                    },
                                    fill: color,
                                    formattedCategory: this.createLazyFormattedCategory(categoryFormatter, categoryValue),
                                    selected: !1,
                                    identity: identity,
                                    tooltipInfo: tooltipInfo,
                                    labelFill: labelSettings.labelColor,
                                    labelFontSize: fontSizeInPx,
                                    contentPosition: 8,
                                    colorFill: colorFill,
                                    shapeSymbolType: shapeSymbolType,
                                    svgurl: image,
                                    rotation: rotation,
                                    backdrop: backdrop,
                                    xStart: xStart,
                                    xEnd: xEnd,
                                    yStart: yStart,
                                    yEnd: yEnd
                                };
                                dataPoints.push(dataPoint);
                            }
                        }
                        return dataPoints;
                    }, EnhancedScatterChart.getMeasureValue = function(measureIndex, seriesValues) {
                        return seriesValues && measureIndex >= 0 ? seriesValues[measureIndex] : null;
                    }, EnhancedScatterChart.getNumberFromDataViewValueColumnById = function(dataViewValueColumn, index) {
                        var value = EnhancedScatterChart.getValueFromDataViewValueColumnById(dataViewValueColumn, index);
                        return value && !isNaN(value) ? value : 0;
                    }, EnhancedScatterChart.getValueFromDataViewValueColumnById = function(dataViewValueColumn, index) {
                        return dataViewValueColumn && dataViewValueColumn.values ? dataViewValueColumn.values[index] : null;
                    }, EnhancedScatterChart.getDefaultData = function() {
                        return {
                            xCol: void 0,
                            yCol: void 0,
                            dataPoints: [],
                            legendData: {
                                dataPoints: []
                            },
                            axesLabels: {
                                x: "",
                                y: ""
                            },
                            selectedIds: [],
                            sizeRange: [],
                            dataLabelsSettings: dataLabelUtils.getDefaultPointLabelSettings(),
                            defaultDataPointColor: null,
                            hasDynamicSeries: !1,
                            useShape: !1,
                            useCustomColor: !1
                        };
                    }, EnhancedScatterChart.prototype.setData = function(dataViews) {
                        if (this.data = EnhancedScatterChart.getDefaultData(), dataViews && dataViews.length > 0) {
                            var dataView = dataViews[0];
                            dataView && (this.categoryAxisProperties = this.getCategoryAxisProperties(dataView.metadata, !0), 
                            this.valueAxisProperties = this.getValueAxisProperties(dataView.metadata, !0), this.dataView = dataView, 
                            dataView.categorical && dataView.categorical.values && (this.data = EnhancedScatterChart.converter(dataView, this.colors, this.interactivityService, this.categoryAxisProperties, this.valueAxisProperties)));
                        }
                    }, EnhancedScatterChart.prototype.update = function(options) {
                        var dataViews = this.dataViews = options.dataViews;
                        if (this.viewport = _.clone(options.viewport), dataViews) {
                            if (dataViews && dataViews.length > 0) {
                                var warnings = getInvalidValueWarnings(dataViews, !1, !1, !1);
                                warnings && warnings.length > 0 && this.hostServices.setWarnings(warnings), this.populateObjectProperties(dataViews);
                            }
                            this.setData(dataViews), this.options.interactivity && this.options.interactivity.isInteractiveLegend || this.renderLegend(), 
                            this.render(options.suppressAnimations);
                        }
                    }, EnhancedScatterChart.prototype.populateObjectProperties = function(dataViews) {
                        if (dataViews && dataViews.length > 0) {
                            var dataViewMetadata = dataViews[0].metadata;
                            dataViewMetadata ? this.legendObjectProperties = DataViewObjects.getObject(dataViewMetadata.objects, "legend", {}) : this.legendObjectProperties = {}, 
                            this.categoryAxisProperties = this.getCategoryAxisProperties(dataViewMetadata), 
                            this.valueAxisProperties = this.getValueAxisProperties(dataViewMetadata);
                            var axisPosition = this.valueAxisProperties.position;
                            this.yAxisOrientation = axisPosition ? axisPosition.toString() : yAxisPosition.left;
                        }
                    }, EnhancedScatterChart.prototype.renderLegend = function() {
                        var legendData = {
                            title: "",
                            dataPoints: []
                        }, legend = this.legend;
                        this.layerLegendData = this.data.legendData, this.layerLegendData && (legendData.title = this.layerLegendData.title || "", 
                        legendData.dataPoints = legendData.dataPoints.concat(this.layerLegendData.dataPoints || []), 
                        legendData.fontSize = this.legendLabelFontSize ? this.legendLabelFontSize : EnhancedScatterChart.LegendLabelFontSizeDefault, 
                        this.layerLegendData.grouped && (legendData.grouped = !0));
                        var legendProperties = this.legendObjectProperties;
                        if (legendProperties) {
                            LegendData.update(legendData, legendProperties);
                            var position = legendProperties[legendProps.position];
                            position && legend.changeOrientation(LegendPosition[position]);
                        } else legend.changeOrientation(LegendPosition.Top);
                        1 !== legendData.dataPoints.length || legendData.grouped || (legendData.dataPoints = []);
                        var viewport = this.viewport;
                        legend.drawLegend(legendData, {
                            height: viewport.height,
                            width: viewport.width
                        }), Legend.positionChartArea(this.svg, legend);
                    }, EnhancedScatterChart.prototype.shouldRenderAxis = function(axisProperties, propertyName) {
                        return void 0 === propertyName && (propertyName = "show"), !!axisProperties && (!axisProperties.isCategoryAxis || this.categoryAxisProperties && null != this.categoryAxisProperties[propertyName] && !this.categoryAxisProperties[propertyName] ? !(axisProperties.isCategoryAxis || this.valueAxisProperties && null != this.valueAxisProperties[propertyName] && !this.valueAxisProperties[propertyName]) && (axisProperties.values && axisProperties.values.length > 0) : axisProperties.values && axisProperties.values.length > 0);
                    }, EnhancedScatterChart.prototype.getMaxMarginFactor = function() {
                        return this.options.style.maxMarginFactor || .25;
                    }, EnhancedScatterChart.prototype.adjustViewportbyBackdrop = function() {
                        var img = new Image(), that = this;
                        if (img.src = this.data.backdrop.url, img.onload = function() {
                            that.oldBackdrop !== this.src && (that.render(!0), that.oldBackdrop = this.src);
                        }, img.width > 0 && img.height > 0) if (img.width * this.viewportIn.height < this.viewportIn.width * img.height) {
                            var deltaWidth = this.viewportIn.width - this.viewportIn.height * img.width / img.height;
                            this.viewport = {
                                width: this.viewport.width - deltaWidth,
                                height: this.viewport.height
                            };
                        } else {
                            var deltaHeight = this.viewportIn.height - this.viewportIn.width * img.height / img.width;
                            this.viewport = {
                                width: this.viewport.width,
                                height: this.viewport.height - deltaHeight
                            };
                        }
                    }, EnhancedScatterChart.prototype.render = function(suppressAnimations) {
                        if (this.viewport.height -= this.legendViewport.height, this.viewport.width -= this.legendViewport.width, 
                        0 !== this.viewportIn.width && 0 !== this.viewportIn.height) {
                            var maxMarginFactor = this.getMaxMarginFactor();
                            this.leftRightMarginLimit = this.viewport.width * maxMarginFactor;
                            var bottomMarginLimit = this.bottomMarginLimit = Math.max(25, Math.ceil(this.viewport.height * maxMarginFactor));
                            this.margin.top = 8, this.margin.bottom = bottomMarginLimit, this.margin.right = 0, 
                            this.calculateAxes(this.categoryAxisProperties, this.valueAxisProperties, EnhancedScatterChart.TextProperties, !0), 
                            this.yAxisIsCategorical = this.yAxisProperties.isCategoryAxis, this.hasCategoryAxis = this.yAxisIsCategorical ? this.yAxisProperties && this.yAxisProperties.values.length > 0 : this.xAxisProperties && this.xAxisProperties.values.length > 0;
                            var mainAxisScale, renderXAxis = this.shouldRenderAxis(this.xAxisProperties), renderY1Axis = this.shouldRenderAxis(this.yAxisProperties);
                            this.isXScrollBarVisible = !1, this.isYScrollBarVisible = !1;
                            var tickLabelMargins, axisLabels, chartHasAxisLabels, yAxisOrientation = this.yAxisOrientation, showY1OnRight = yAxisOrientation === yAxisPosition.right;
                            this.calculateAxes(this.categoryAxisProperties, this.valueAxisProperties, EnhancedScatterChart.TextProperties, !0);
                            for (var doneWithMargins = !1, maxIterations = 2, numIterations = 0; !doneWithMargins && numIterations < maxIterations; ) {
                                numIterations++, tickLabelMargins = AxisHelper.getTickLabelMargins({
                                    width: this.viewportIn.width,
                                    height: this.viewport.height
                                }, this.leftRightMarginLimit, measureSvgTextWidth, measureSvgTextHeight, {
                                    x: this.xAxisProperties,
                                    y1: this.yAxisProperties
                                }, this.bottomMarginLimit, EnhancedScatterChart.TextProperties, this.isXScrollBarVisible || this.isYScrollBarVisible, showY1OnRight, renderXAxis, renderY1Axis, !1);
                                var maxMainYaxisSide = showY1OnRight ? tickLabelMargins.yRight : tickLabelMargins.yLeft, maxSecondYaxisSide = showY1OnRight ? tickLabelMargins.yLeft : tickLabelMargins.yRight, xMax = tickLabelMargins.xMax;
                                maxMainYaxisSide += 10, maxSecondYaxisSide += 10, xMax += 12, showY1OnRight && renderY1Axis && (maxSecondYaxisSide += 20), 
                                !showY1OnRight && renderY1Axis && (maxMainYaxisSide += 20), this.addUnitTypeToAxisLabel(this.xAxisProperties, this.yAxisProperties), 
                                axisLabels = {
                                    x: this.xAxisProperties.axisLabel,
                                    y: this.yAxisProperties.axisLabel,
                                    y2: null
                                }, chartHasAxisLabels = null != axisLabels.x || null != axisLabels.y || null != axisLabels.y2, 
                                null != axisLabels.x && (xMax += 18), null != axisLabels.y && (maxMainYaxisSide += 20), 
                                null != axisLabels.y2 && (maxSecondYaxisSide += 20), this.margin.left = showY1OnRight ? maxSecondYaxisSide : maxMainYaxisSide, 
                                this.margin.right = showY1OnRight ? maxMainYaxisSide : maxSecondYaxisSide, this.margin.bottom = xMax;
                                var previousTickCountY1 = this.yAxisProperties.values.length;
                                this.calculateAxes(this.categoryAxisProperties, this.valueAxisProperties, EnhancedScatterChart.TextProperties, !0), 
                                this.yAxisProperties.values.length === previousTickCountY1 && (doneWithMargins = !0);
                            }
                            if (this.data.backdrop && this.data.backdrop.show && void 0 !== this.data.backdrop.url) for (this.adjustViewportbyBackdrop(), 
                            doneWithMargins = !1, maxIterations = 2, numIterations = 0; !doneWithMargins && numIterations < maxIterations; ) {
                                numIterations++, tickLabelMargins = AxisHelper.getTickLabelMargins({
                                    width: this.viewportIn.width,
                                    height: this.viewport.height
                                }, this.leftRightMarginLimit, measureSvgTextWidth, measureSvgTextHeight, {
                                    x: this.xAxisProperties,
                                    y1: this.yAxisProperties
                                }, this.bottomMarginLimit, EnhancedScatterChart.TextProperties, this.isXScrollBarVisible || this.isYScrollBarVisible, showY1OnRight, renderXAxis, renderY1Axis, !1);
                                var maxMainYaxisSide = showY1OnRight ? tickLabelMargins.yRight : tickLabelMargins.yLeft, maxSecondYaxisSide = showY1OnRight ? tickLabelMargins.yLeft : tickLabelMargins.yRight, xMax = tickLabelMargins.xMax;
                                maxMainYaxisSide += 10, showY1OnRight && renderY1Axis && (maxSecondYaxisSide += 15), 
                                xMax += 12, this.addUnitTypeToAxisLabel(this.xAxisProperties, this.yAxisProperties), 
                                axisLabels = {
                                    x: this.xAxisProperties.axisLabel,
                                    y: this.yAxisProperties.axisLabel,
                                    y2: null
                                }, chartHasAxisLabels = null != axisLabels.x || null != axisLabels.y || null != axisLabels.y2, 
                                null != axisLabels.x && (xMax += 18), null != axisLabels.y && (maxMainYaxisSide += 20), 
                                null != axisLabels.y2 && (maxSecondYaxisSide += 20), this.margin.left = showY1OnRight ? maxSecondYaxisSide : maxMainYaxisSide, 
                                this.margin.right = showY1OnRight ? maxMainYaxisSide : maxSecondYaxisSide, this.margin.bottom = xMax;
                                var previousTickCountY1 = this.yAxisProperties.values.length;
                                this.calculateAxes(this.categoryAxisProperties, this.valueAxisProperties, EnhancedScatterChart.TextProperties, !0), 
                                this.yAxisProperties.values.length === previousTickCountY1 && (doneWithMargins = !0);
                            }
                            if (this.renderChart(mainAxisScale, this.xAxisProperties, this.yAxisProperties, tickLabelMargins, chartHasAxisLabels, axisLabels, suppressAnimations), 
                            this.updateAxis(), this.data) {
                                var data = this.data, dataPoints = this.data.dataPoints, hasSelection = this.interactivityService && this.interactivityService.hasSelection();
                                this.mainGraphicsSVGSelection.attr("width", this.viewportIn.width).attr("height", this.viewportIn.height);
                                var sortedData = dataPoints.sort(function(a, b) {
                                    return b.radius.sizeMeasure ? b.radius.sizeMeasure.values[b.radius.index] - a.radius.sizeMeasure.values[a.radius.index] : 0;
                                }), duration = GetAnimationDuration(this.animator, suppressAnimations), scatterMarkers = this.drawScatterMarkers(sortedData, hasSelection, data.sizeRange, duration), dataLabelsSettings = this.data.dataLabelsSettings;
                                if (dataLabelsSettings.show) {
                                    var layout, clonedDataPoints, labels;
                                    layout = this.getEnhanchedScatterChartLabelLayout(dataLabelsSettings, this.viewportIn, data.sizeRange), 
                                    clonedDataPoints = this.cloneDataPoints(dataPoints), labels = dataLabelUtils.drawDefaultLabelsForDataPointChart(clonedDataPoints, this.mainGraphicsG, layout, this.viewportIn), 
                                    labels && labels.attr("transform", function(d) {
                                        var dx, dy, size = d.size;
                                        return dx = size.width / EnhancedScatterChart.DataLabelXOffset, dy = size.height / EnhancedScatterChart.DataLabelYOffset, 
                                        SVGUtil.translate(dx, dy);
                                    });
                                } else dataLabelUtils.cleanDataLabels(this.mainGraphicsG);
                                this.renderCrosshair(data);
                                var behaviorOptions;
                                if (this.interactivityService && (behaviorOptions = {
                                    dataPointsSelection: scatterMarkers,
                                    data: this.data,
                                    plotContext: this.mainGraphicsSVGSelection
                                }), addTooltip(scatterMarkers, function(tooltipEvent) {
                                    return tooltipEvent.data.tooltipInfo;
                                }), SVGUtil.flushAllD3TransitionsIfNeeded(this.options), this.behavior) {
                                    var layerBehaviorOptions = [ behaviorOptions ];
                                    if (this.interactivityService) {
                                        var cbehaviorOptions = {
                                            layerOptions: layerBehaviorOptions,
                                            clearCatcher: this.clearCatcher
                                        };
                                        this.interactivityService.bind(dataPoints, this.behavior, cbehaviorOptions);
                                    }
                                }
                            }
                        }
                    }, EnhancedScatterChart.prototype.cloneDataPoints = function(dataPoints) {
                        return dataPoints.map(function(dataPoint) {
                            return _.clone(dataPoint);
                        });
                    }, EnhancedScatterChart.prototype.darkenZeroLine = function(g) {
                        var zeroTick = g.selectAll("g.tick").filter(function(data) {
                            return 0 === data;
                        }).node();
                        zeroTick && d3.select(zeroTick).select("line").classed("zero-line", !0);
                    }, EnhancedScatterChart.prototype.getCategoryAxisFill = function() {
                        if (this.dataView && this.dataView.metadata.objects) {
                            var label = this.dataView.metadata.objects.categoryAxis;
                            if (label) return label.axisColor;
                        }
                        return {
                            solid: {
                                color: "#333"
                            }
                        };
                    }, EnhancedScatterChart.prototype.getEnhanchedScatterChartLabelLayout = function(labelSettings, viewport, sizeRange) {
                        var xScale = this.xAxisProperties.scale, yScale = this.yAxisProperties.scale, fontSizeInPx = fromPoint(labelSettings.fontSize), fontFamily = LabelTextProperties.fontFamily;
                        return {
                            labelText: function(d) {
                                return getLabelFormattedText({
                                    label: d.formattedCategory.getValue(),
                                    fontSize: labelSettings.fontSize,
                                    maxWidth: viewport.width
                                });
                            },
                            labelLayout: {
                                x: function(d) {
                                    return xScale(d.x);
                                },
                                y: function(d) {
                                    var margin = EnhancedScatterChart.getBubbleRadius(d.radius, sizeRange, viewport) + dataLabelUtils.labelMargin;
                                    return 0 === labelSettings.position ? yScale(d.y) - margin : yScale(d.y) + margin;
                                }
                            },
                            filter: function(d) {
                                return null != d && null != d.formattedCategory.getValue();
                            },
                            style: {
                                fill: function(d) {
                                    return d.labelFill;
                                },
                                "font-size": fontSizeInPx,
                                "font-family": fontFamily
                            }
                        };
                    }, EnhancedScatterChart.getBubbleRadius = function(radiusData, sizeRange, viewport) {
                        var actualSizeDataRange = null, bubblePixelAreaSizeRange = null, measureSize = radiusData.sizeMeasure;
                        if (!measureSize) return EnhancedScatterChart.BubbleRadius;
                        var minSize = sizeRange.min ? sizeRange.min : 0, maxSize = sizeRange.max ? sizeRange.max : 0, min = Math.min(minSize, 0), max = Math.max(maxSize, 0);
                        if (actualSizeDataRange = {
                            minRange: min,
                            maxRange: max,
                            delta: max - min
                        }, bubblePixelAreaSizeRange = EnhancedScatterChart.getBubblePixelAreaSizeRange(viewport, EnhancedScatterChart.MinSizeRange, EnhancedScatterChart.MaxSizeRange), 
                        measureSize.values) {
                            var sizeValue = measureSize.values[radiusData.index];
                            if (null != sizeValue) return EnhancedScatterChart.projectSizeToPixels(sizeValue, actualSizeDataRange, bubblePixelAreaSizeRange) / 2;
                        }
                        return EnhancedScatterChart.BubbleRadius;
                    }, EnhancedScatterChart.getBubblePixelAreaSizeRange = function(viewPort, minSizeRange, maxSizeRange) {
                        var ratio = 1;
                        if (viewPort.height > 0 && viewPort.width > 0) {
                            var minSize = Math.min(viewPort.height, viewPort.width);
                            ratio = minSize * minSize / EnhancedScatterChart.AreaOf300By300Chart;
                        }
                        var minRange = Math.round(minSizeRange * ratio), maxRange = Math.round(maxSizeRange * ratio);
                        return {
                            minRange: minRange,
                            maxRange: maxRange,
                            delta: maxRange - minRange
                        };
                    }, EnhancedScatterChart.projectSizeToPixels = function(size, actualSizeDataRange, bubblePixelAreaSizeRange) {
                        var projectedSize = 0;
                        if (actualSizeDataRange) {
                            if (projectedSize = bubblePixelAreaSizeRange.maxRange, 0 !== actualSizeDataRange.delta) {
                                var value = Math.min(Math.max(size, actualSizeDataRange.minRange), actualSizeDataRange.maxRange);
                                projectedSize = EnhancedScatterChart.project(value, actualSizeDataRange, bubblePixelAreaSizeRange);
                            }
                            projectedSize = 2 * Math.sqrt(projectedSize / Math.PI);
                        }
                        return Math.round(projectedSize);
                    }, EnhancedScatterChart.project = function(value, actualSizeDataRange, bubblePixelAreaSizeRange) {
                        if (0 === actualSizeDataRange.delta || 0 === bubblePixelAreaSizeRange.delta) return EnhancedScatterChart.rangeContains(actualSizeDataRange, value) ? bubblePixelAreaSizeRange.minRange : null;
                        var relativeX = (value - actualSizeDataRange.minRange) / actualSizeDataRange.delta;
                        return bubblePixelAreaSizeRange.minRange + relativeX * bubblePixelAreaSizeRange.delta;
                    }, EnhancedScatterChart.rangeContains = function(range, value) {
                        return range.minRange <= value && value <= range.maxRange;
                    }, EnhancedScatterChart.prototype.getValueAxisFill = function() {
                        if (this.dataView && this.dataView.metadata.objects) {
                            var label = this.dataView.metadata.objects.valueAxis;
                            if (label) return label.axisColor;
                        }
                        return {
                            solid: {
                                color: "#333"
                            }
                        };
                    }, EnhancedScatterChart.prototype.renderCrosshair = function(data) {
                        if (this.mainGraphicsSVGSelection) return this.crosshairCanvasSelection = this.addCrosshairCanvasToDOM(this.mainGraphicsSVGSelection), 
                        data && data.crosshair ? (this.crosshairVerticalLineSelection = this.addCrosshairLineToDOM(this.crosshairCanvasSelection, EnhancedScatterChart.CrosshairVerticalLineSelector), 
                        this.crosshairHorizontalLineSelection = this.addCrosshairLineToDOM(this.crosshairCanvasSelection, EnhancedScatterChart.CrosshairHorizontalLineSelector), 
                        this.crosshairTextSelection = this.addCrosshairTextToDOM(this.crosshairCanvasSelection), 
                        this.bindCrosshairEvents()) : this.clearCrosshair(), this.crosshairCanvasSelection;
                    }, EnhancedScatterChart.prototype.clearCrosshair = function() {
                        this.crosshairCanvasSelection && this.crosshairCanvasSelection.selectAll("*").remove();
                    }, EnhancedScatterChart.prototype.addCrosshairCanvasToDOM = function(rootElement) {
                        var crosshairCanvasSelector = EnhancedScatterChart.CrosshairCanvasSelector;
                        return this.addElementToDOM(rootElement, {
                            name: "g",
                            selector: crosshairCanvasSelector.selector,
                            className: crosshairCanvasSelector.class,
                            styles: {
                                display: "none"
                            }
                        });
                    }, EnhancedScatterChart.prototype.addCrosshairLineToDOM = function(rootElement, elementSelector) {
                        var crosshairLineSelector = EnhancedScatterChart.CrosshairLineSelector;
                        return this.addElementToDOM(rootElement, {
                            name: "line",
                            selector: elementSelector.selector,
                            className: crosshairLineSelector.class + " " + elementSelector.class,
                            attributes: {
                                x1: 0,
                                y1: 0,
                                x2: 0,
                                y2: 0
                            }
                        });
                    }, EnhancedScatterChart.prototype.addCrosshairTextToDOM = function(rootElement) {
                        var crosshairTextSelector = EnhancedScatterChart.CrosshairTextSelector;
                        return this.addElementToDOM(rootElement, {
                            name: "text",
                            selector: crosshairTextSelector.selector,
                            className: crosshairTextSelector.class
                        });
                    }, EnhancedScatterChart.prototype.bindCrosshairEvents = function() {
                        var _this = this;
                        this.axisGraphicsContextScrollable && this.axisGraphicsContextScrollable.on("mousemove", function() {
                            var currentTarget = d3.event.currentTarget, coordinates = d3.mouse(currentTarget), svgNode = currentTarget.viewportElement, scaledRect = svgNode.getBoundingClientRect(), domRect = svgNode.getBBox(), ratioX = scaledRect.width / domRect.width, ratioY = scaledRect.height / domRect.height, x = coordinates[0], y = coordinates[1];
                            domRect.width > 0 && !equalWithPrecision(ratioX, 1, 1e-5) && (x /= ratioX), domRect.height > 0 && !equalWithPrecision(ratioY, 1, 1e-5) && (y /= ratioY), 
                            _this.updateCrosshair(x, y);
                        }).on("mouseover", function() {
                            _this.crosshairCanvasSelection.style("display", "block");
                        }).on("mouseout", function() {
                            _this.crosshairCanvasSelection.style("display", "none");
                        });
                    }, EnhancedScatterChart.prototype.updateCrosshair = function(x, y) {
                        if (this.viewportIn && this.crosshairHorizontalLineSelection && this.crosshairVerticalLineSelection && this.crosshairTextSelection && this.xAxisProperties) {
                            var xFormated, yFormated, crosshairTextMargin = EnhancedScatterChart.CrosshairTextMargin, xScale = this.xAxisProperties.scale, yScale = this.yAxisProperties.scale;
                            this.crosshairHorizontalLineSelection.attr({
                                x1: 0,
                                y1: y,
                                x2: this.viewportIn.width,
                                y2: y
                            }), this.crosshairVerticalLineSelection.attr({
                                x1: x,
                                y1: 0,
                                x2: x,
                                y2: this.viewportIn.height
                            }), xFormated = Math.round(100 * xScale.invert(x)) / 100, yFormated = Math.round(100 * yScale.invert(y)) / 100, 
                            this.crosshairTextSelection.attr({
                                x: x + crosshairTextMargin,
                                y: y - crosshairTextMargin
                            }).text("(" + xFormated + ", " + yFormated + ")");
                        }
                    }, EnhancedScatterChart.prototype.addElementToDOM = function(rootElement, properties) {
                        if (!rootElement || !properties) return null;
                        var elementSelection, elementUpdateSelection;
                        return elementSelection = rootElement.selectAll(properties.selector), elementUpdateSelection = elementSelection.data(properties.data || [ [] ]), 
                        elementUpdateSelection.enter().append(properties.name).attr(properties.attributes).style(properties.styles).classed(properties.className, !0), 
                        elementUpdateSelection.exit().remove(), elementUpdateSelection;
                    }, EnhancedScatterChart.prototype.renderBackground = function() {
                        this.data.backdrop && this.data.backdrop.show && void 0 !== this.data.backdrop.url ? this.backgroundGraphicsContext.attr("xlink:href", this.data.backdrop.url).attr("x", 0).attr("y", 0).attr("width", this.viewportIn.width).attr("height", this.viewportIn.height) : this.backgroundGraphicsContext.attr("width", 0).attr("height", 0);
                    }, EnhancedScatterChart.prototype.renderChart = function(mainAxisScale, xAxis, yAxis, tickLabelMargins, chartHasAxisLabels, axisLabels, suppressAnimations, scrollScale, extent) {
                        var bottomMarginLimit = this.bottomMarginLimit, leftRightMarginLimit = this.leftRightMarginLimit, duration = GetAnimationDuration(this.animator, suppressAnimations);
                        if (this.renderBackground(), this.shouldRenderAxis(xAxis)) {
                            xAxis.axis.orient("bottom"), xAxis.willLabelsFit || xAxis.axis.tickPadding(5);
                            var xAxisGraphicsElement = this.xAxisGraphicsContext;
                            duration ? xAxisGraphicsElement.transition().duration(duration).call(xAxis.axis).call(this.darkenZeroLine) : xAxisGraphicsElement.call(xAxis.axis).call(this.darkenZeroLine);
                            var xZeroTick = xAxisGraphicsElement.selectAll("g.tick").filter(function(data) {
                                return 0 === data;
                            });
                            if (xZeroTick) {
                                var xZeroColor = this.getValueAxisFill();
                                xZeroColor && xZeroTick.selectAll("line").style({
                                    stroke: xZeroColor.solid.color
                                });
                            }
                            var xAxisTextNodes = xAxisGraphicsElement.selectAll("text");
                            xAxis.willLabelsWordBreak ? xAxisTextNodes.call(AxisHelper.LabelLayoutStrategy.wordBreak, xAxis, bottomMarginLimit) : xAxisTextNodes.call(AxisHelper.LabelLayoutStrategy.rotate, bottomMarginLimit, getTailoredTextOrDefault, EnhancedScatterChart.TextProperties, !xAxis.willLabelsFit, bottomMarginLimit === tickLabelMargins.xMax, xAxis, this.margin, this.isXScrollBarVisible || this.isYScrollBarVisible);
                        } else this.xAxisGraphicsContext.selectAll("*").remove();
                        if (this.shouldRenderAxis(yAxis)) {
                            var yAxisOrientation = this.yAxisOrientation;
                            yAxis.axis.tickSize(-this.viewportIn.width).tickPadding(10).orient(yAxisOrientation.toLowerCase());
                            var y1AxisGraphicsElement = this.y1AxisGraphicsContext;
                            duration ? y1AxisGraphicsElement.transition().duration(duration).call(yAxis.axis).call(this.darkenZeroLine) : y1AxisGraphicsElement.call(yAxis.axis).call(this.darkenZeroLine);
                            var yZeroTick = y1AxisGraphicsElement.selectAll("g.tick").filter(function(data) {
                                return 0 === data;
                            });
                            if (yZeroTick) {
                                var yZeroColor = this.getCategoryAxisFill();
                                yZeroColor && yZeroTick.selectAll("line").style({
                                    stroke: yZeroColor.solid.color
                                });
                            }
                            tickLabelMargins.yLeft >= leftRightMarginLimit && y1AxisGraphicsElement.selectAll("text").call(AxisHelper.LabelLayoutStrategy.clip, leftRightMarginLimit - 10, svgEllipsis);
                        } else this.y1AxisGraphicsContext.selectAll("*").remove();
                        if (chartHasAxisLabels) {
                            var hideXAxisTitle = !this.shouldRenderAxis(xAxis, "showAxisTitle"), hideYAxisTitle = !this.shouldRenderAxis(yAxis, "showAxisTitle"), hideY2AxisTitle = this.valueAxisProperties && null != this.valueAxisProperties.secShowAxisTitle && this.valueAxisProperties.secShowAxisTitle === !1;
                            this.renderAxesLabels(axisLabels, this.legendViewport.height, hideXAxisTitle, hideYAxisTitle, hideY2AxisTitle);
                        } else this.axisGraphicsContext.selectAll(".xAxisLabel").remove(), this.axisGraphicsContext.selectAll(".yAxisLabel").remove();
                    }, EnhancedScatterChart.prototype.renderAxesLabels = function(axisLabels, legendMargin, hideXAxisTitle, hideYAxisTitle, hideY2AxisTitle) {
                        this.axisGraphicsContext.selectAll(".xAxisLabel").remove(), this.axisGraphicsContext.selectAll(".yAxisLabel").remove();
                        var margin = this.margin, width = this.viewportIn.width, height = this.viewport.height, fontSize = EnhancedScatterChart.AxisFontSize, yAxisOrientation = this.yAxisOrientation, showY1OnRight = yAxisOrientation === yAxisPosition.right;
                        if (!hideXAxisTitle) {
                            var xAxisLabel = this.axisGraphicsContext.append("text").style("text-anchor", "middle").text(axisLabels.x).call(function(text) {
                                text.each(function() {
                                    var text = d3.select(this);
                                    text.attr({
                                        class: "xAxisLabel",
                                        transform: SVGUtil.translate(width / 2, height - fontSize - 2)
                                    });
                                });
                            });
                            xAxisLabel.call(AxisHelper.LabelLayoutStrategy.clip, width, svgEllipsis);
                        }
                        if (!hideYAxisTitle) {
                            var yAxisLabel = this.axisGraphicsContext.append("text").style("text-anchor", "middle").text(axisLabels.y).call(function(text) {
                                text.each(function() {
                                    var text = d3.select(this);
                                    text.attr({
                                        class: "yAxisLabel",
                                        transform: "rotate(-90)",
                                        y: showY1OnRight ? width + margin.right - fontSize : -margin.left,
                                        x: -((height - margin.top - legendMargin) / 2),
                                        dy: "1em"
                                    });
                                });
                            });
                            yAxisLabel.call(AxisHelper.LabelLayoutStrategy.clip, height - (margin.bottom + margin.top), svgEllipsis);
                        }
                        if (!hideY2AxisTitle && axisLabels.y2) {
                            var y2AxisLabel = this.axisGraphicsContext.append("text").style("text-anchor", "middle").text(axisLabels.y2).call(function(text) {
                                text.each(function() {
                                    var text = d3.select(this);
                                    text.attr({
                                        class: "yAxisLabel",
                                        transform: "rotate(-90)",
                                        y: showY1OnRight ? -margin.left : width + margin.right - fontSize,
                                        x: -((height - margin.top - legendMargin) / 2),
                                        dy: "1em"
                                    });
                                });
                            });
                            y2AxisLabel.call(AxisHelper.LabelLayoutStrategy.clip, height - (margin.bottom + margin.top), svgEllipsis);
                        }
                    }, EnhancedScatterChart.prototype.updateAxis = function() {
                        this.adjustMargins();
                        var yAxisOrientation = this.yAxisOrientation, showY1OnRight = yAxisOrientation === yAxisPosition.right;
                        this.xAxisGraphicsContext.attr("transform", SVGUtil.translate(0, this.viewportIn.height)), 
                        this.y1AxisGraphicsContext.attr("transform", SVGUtil.translate(showY1OnRight ? this.viewportIn.width : 0, 0)), 
                        this.svg.attr({
                            width: this.viewport.width,
                            height: this.viewport.height
                        }), this.svgScrollable.attr({
                            width: this.viewport.width,
                            height: this.viewport.height
                        }), this.svgScrollable.attr({
                            x: 0
                        });
                        var left = this.margin.left, top = this.margin.top;
                        this.axisGraphicsContext.attr("transform", SVGUtil.translate(left, top)), this.axisGraphicsContextScrollable.attr("transform", SVGUtil.translate(left, top)), 
                        this.clearCatcher.attr("transform", SVGUtil.translate(-left, -top)), this.isXScrollBarVisible ? (this.svgScrollable.attr({
                            x: left
                        }), this.axisGraphicsContextScrollable.attr("transform", SVGUtil.translate(0, top)), 
                        this.svgScrollable.attr("width", this.viewportIn.width), this.svg.attr("width", this.viewport.width).attr("height", this.viewport.height + this.ScrollBarWidth)) : this.isYScrollBarVisible && (this.svgScrollable.attr("height", this.viewportIn.height + top), 
                        this.svg.attr("width", this.viewport.width + this.ScrollBarWidth).attr("height", this.viewport.height));
                    }, EnhancedScatterChart.prototype.getUnitType = function(xAxis) {
                        return xAxis.formatter && xAxis.formatter.displayUnit && xAxis.formatter.displayUnit.value > 1 ? xAxis.formatter.displayUnit.title : null;
                    }, EnhancedScatterChart.prototype.addUnitTypeToAxisLabel = function(xAxis, yAxis) {
                        var unitType = this.getUnitType(xAxis);
                        xAxis.isCategoryAxis ? this.categoryAxisHasUnitType = null !== unitType : this.valueAxisHasUnitType = null !== unitType, 
                        xAxis.axisLabel && unitType && (xAxis.isCategoryAxis ? xAxis.axisLabel = AxisHelper.createAxisLabel(this.categoryAxisProperties, xAxis.axisLabel, unitType) : xAxis.axisLabel = AxisHelper.createAxisLabel(this.valueAxisProperties, xAxis.axisLabel, unitType)), 
                        unitType = this.getUnitType(yAxis), yAxis.isCategoryAxis ? this.categoryAxisHasUnitType = null !== unitType : this.valueAxisHasUnitType = null !== unitType, 
                        yAxis.axisLabel && unitType && (yAxis.isCategoryAxis ? yAxis.axisLabel = AxisHelper.createAxisLabel(this.categoryAxisProperties, yAxis.axisLabel, unitType) : yAxis.axisLabel = AxisHelper.createAxisLabel(this.valueAxisProperties, yAxis.axisLabel, unitType));
                    }, EnhancedScatterChart.prototype.drawScatterMarkers = function(scatterData, hasSelection, sizeRange, duration) {
                        var markers, _this = this, xScale = this.xAxisProperties.scale, yScale = this.yAxisProperties.scale, shouldEnableFill = (!sizeRange || !sizeRange.min) && this.data.fillPoint, useCustomColor = this.data.useCustomColor;
                        this.data.useShape ? (this.mainGraphicsContext.selectAll(EnhancedScatterChart.DotClasses.selector).remove(), 
                        markers = this.mainGraphicsContext.classed("ScatterMarkers", !0).selectAll(EnhancedScatterChart.ImageClasses.selector).data(scatterData, function(d) {
                            return d.identity.getKey();
                        }), markers.enter().append("svg:image").classed(EnhancedScatterChart.ImageClasses.class, !0).attr("id", "markerimage"), 
                        markers.attr("xlink:href", function(d) {
                            return void 0 !== d.svgurl && null != d.svgurl && "" !== d.svgurl ? d.svgurl : _this.svgDefaultImage;
                        }).attr("width", function(d) {
                            return 2 * EnhancedScatterChart.getBubbleRadius(d.radius, sizeRange, _this.viewport);
                        }).attr("height", function(d) {
                            return 2 * EnhancedScatterChart.getBubbleRadius(d.radius, sizeRange, _this.viewport);
                        }).transition().duration(function(d) {
                            return _this.keyArray.indexOf(d.identity.getKey()) >= 0 ? duration : 0;
                        }).attr("transform", function(d) {
                            var radius = EnhancedScatterChart.getBubbleRadius(d.radius, sizeRange, _this.viewport);
                            return "translate(" + (xScale(d.x) - radius) + "," + (yScale(d.y) - radius) + ") rotate(" + d.rotation + "," + radius + "," + radius + ")";
                        })) : (this.mainGraphicsContext.selectAll(EnhancedScatterChart.ImageClasses.selector).remove(), 
                        markers = this.mainGraphicsContext.classed("ScatterMarkers", !0).selectAll(EnhancedScatterChart.DotClasses.selector).data(scatterData, function(d) {
                            return d.identity.getKey();
                        }), markers.enter().append("path").classed(EnhancedScatterChart.DotClasses.class, !0).attr("id", "markershape"), 
                        markers.style({
                            "stroke-opacity": function(d) {
                                return EnhancedScatterChart.getBubbleOpacity(d, hasSelection);
                            },
                            "stroke-width": "1px",
                            stroke: function(d) {
                                var color = useCustomColor ? d.colorFill : d.fill;
                                return _this.data.outline ? d3.rgb(color).darker() : d3.rgb(color);
                            },
                            fill: function(d) {
                                return d3.rgb(useCustomColor ? d.colorFill : d.fill);
                            },
                            "fill-opacity": function(d) {
                                return null != d.size || shouldEnableFill ? EnhancedScatterChart.getBubbleOpacity(d, hasSelection) : 0;
                            }
                        }).attr("d", function(d) {
                            var r = EnhancedScatterChart.getBubbleRadius(d.radius, sizeRange, _this.viewport), area = 4 * r * r;
                            return d.shapeSymbolType(area);
                        }).transition().duration(function(d) {
                            return _this.keyArray.indexOf(d.identity.getKey()) >= 0 ? duration : 0;
                        }).attr("transform", function(d) {
                            return "translate(" + xScale(d.x) + "," + yScale(d.y) + ") rotate(" + d.rotation + ")";
                        })), markers.exit().remove(), this.keyArray = [];
                        for (var i = 0; i < scatterData.length; i++) this.keyArray.push(scatterData[i].identity.getKey());
                        return markers;
                    }, EnhancedScatterChart.getBubbleOpacity = function(d, hasSelection) {
                        return hasSelection && !d.selected ? EnhancedScatterChart.DimmedBubbleOpacity : EnhancedScatterChart.DefaultBubbleOpacity;
                    }, EnhancedScatterChart.prototype.calculateAxes = function(categoryAxisProperties, valueAxisProperties, textProperties, scrollbarVisible) {
                        var visualOptions = {
                            viewport: this.viewport,
                            margin: this.margin,
                            forcedXDomain: [ categoryAxisProperties ? categoryAxisProperties.start : null, categoryAxisProperties ? categoryAxisProperties.end : null ],
                            forceMerge: valueAxisProperties && valueAxisProperties.secShow === !1,
                            showCategoryAxisLabel: !1,
                            showValueAxisLabel: !1,
                            categoryAxisScaleType: categoryAxisProperties && null != categoryAxisProperties.axisScale ? categoryAxisProperties.axisScale : null,
                            valueAxisScaleType: valueAxisProperties && null != valueAxisProperties.axisScale ? valueAxisProperties.axisScale : null,
                            valueAxisDisplayUnits: valueAxisProperties && null != valueAxisProperties.labelDisplayUnits ? valueAxisProperties.labelDisplayUnits : EnhancedScatterChart.LabelDisplayUnitsDefault,
                            categoryAxisDisplayUnits: categoryAxisProperties && null != categoryAxisProperties.labelDisplayUnits ? categoryAxisProperties.labelDisplayUnits : EnhancedScatterChart.LabelDisplayUnitsDefault,
                            trimOrdinalDataOnOverflow: !1
                        };
                        valueAxisProperties && (visualOptions.forcedYDomain = AxisHelper.applyCustomizedDomain([ valueAxisProperties.start, valueAxisProperties.end ], visualOptions.forcedYDomain)), 
                        visualOptions.showCategoryAxisLabel = !!categoryAxisProperties && !!categoryAxisProperties.showAxisTitle, 
                        visualOptions.showValueAxisLabel = !0;
                        var width = this.viewport.width - (this.margin.left + this.margin.right), axes = this.calculateAxesProperties(visualOptions);
                        return axes[0].willLabelsFit = AxisHelper.LabelLayoutStrategy.willLabelsFit(axes[0], width, measureSvgTextWidth, textProperties), 
                        axes[0].willLabelsWordBreak = !axes[0].willLabelsFit && !scrollbarVisible && AxisHelper.LabelLayoutStrategy.willLabelsWordBreak(axes[0], this.margin, width, measureSvgTextWidth, estimateSvgTextHeight, getTailoredTextOrDefault, textProperties), 
                        axes;
                    }, EnhancedScatterChart.prototype.calculateAxesProperties = function(options) {
                        var data = this.data, dataPoints = data.dataPoints;
                        this.margin = options.margin, this.viewport = options.viewport;
                        var minY = 0, maxY = 10, minX = 0, maxX = 10;
                        dataPoints.length > 0 && (minY = d3.min(dataPoints, function(d) {
                            return d.y;
                        }), maxY = d3.max(dataPoints, function(d) {
                            return d.y;
                        }), minX = d3.min(dataPoints, function(d) {
                            return d.x;
                        }), maxX = d3.max(dataPoints, function(d) {
                            return d.x;
                        }));
                        var combinedXDomain, combinedYDomain, xAxisFormatString, yAxisFormatString, xDomain = [ minX, maxX ];
                        return combinedXDomain = AxisHelper.combineDomain(this.optimizeTranslateValues(options.forcedXDomain), xDomain), 
                        xAxisFormatString = valueFormatter.getFormatString(data.xCol, EnhancedScatterChart.Properties.general.formatString), 
                        this.xAxisProperties = AxisHelper.createAxis({
                            pixelSpan: this.viewportIn.width,
                            dataDomain: combinedXDomain,
                            metaDataColumn: data.xCol,
                            formatString: xAxisFormatString,
                            outerPadding: 0,
                            isScalar: !0,
                            isVertical: !1,
                            forcedTickCount: options.forcedTickCount,
                            useTickIntervalForDisplayUnits: !0,
                            isCategoryAxis: !0,
                            scaleType: options.categoryAxisScaleType,
                            axisDisplayUnits: options.categoryAxisDisplayUnits
                        }), this.xAxisProperties.axis.tickSize(-this.viewportIn.height, 0), this.xAxisProperties.axisLabel = this.data.axesLabels.x, 
                        combinedYDomain = AxisHelper.combineDomain(this.optimizeTranslateValues(options.forcedYDomain), [ minY, maxY ]), 
                        yAxisFormatString = valueFormatter.getFormatString(data.yCol, EnhancedScatterChart.Properties.general.formatString), 
                        this.yAxisProperties = AxisHelper.createAxis({
                            pixelSpan: this.viewportIn.height,
                            dataDomain: combinedYDomain,
                            metaDataColumn: data.yCol,
                            formatString: yAxisFormatString,
                            outerPadding: 0,
                            isScalar: !0,
                            isVertical: !0,
                            forcedTickCount: options.forcedTickCount,
                            useTickIntervalForDisplayUnits: !0,
                            isCategoryAxis: !1,
                            scaleType: options.valueAxisScaleType,
                            axisDisplayUnits: options.valueAxisDisplayUnits
                        }), this.yAxisProperties.axisLabel = this.data.axesLabels.y, [ this.xAxisProperties, this.yAxisProperties ];
                    }, EnhancedScatterChart.prototype.optimizeTranslateValues = function(values) {
                        var _this = this;
                        return values && values.map ? values.map(function(value) {
                            return _this.optimizeTranslateValue(value);
                        }) : values;
                    }, EnhancedScatterChart.prototype.optimizeTranslateValue = function(value) {
                        if (value) {
                            var numberSign = value >= 0 ? 1 : -1, absoluteValue = Math.abs(value);
                            if (absoluteValue > EnhancedScatterChart.MaxTranslateValue) return EnhancedScatterChart.MaxTranslateValue * numberSign;
                            if (absoluteValue < EnhancedScatterChart.MinTranslateValue) return EnhancedScatterChart.MinTranslateValue * numberSign;
                        }
                        return value;
                    }, EnhancedScatterChart.prototype.enumerateDataPoints = function(enumeration) {
                        var data = this.data;
                        if (data) {
                            var seriesCount = data.dataPoints.length;
                            if (data.hasDynamicSeries) for (var legendDataPointLength = data.legendData.dataPoints.length, i = 0; i < legendDataPointLength; i++) {
                                var series = data.legendData.dataPoints[i];
                                enumeration.pushInstance({
                                    objectName: "dataPoint",
                                    displayName: series.label,
                                    selector: ColorHelper.normalizeSelector(series.identity.getSelector()),
                                    properties: {
                                        fill: {
                                            solid: {
                                                color: series.color
                                            }
                                        }
                                    }
                                });
                            } else {
                                var showAllDataPoints = data.showAllDataPoints;
                                if (enumeration.pushInstance({
                                    objectName: "dataPoint",
                                    selector: null,
                                    properties: {
                                        defaultColor: {
                                            solid: {
                                                color: data.defaultDataPointColor || this.colors.getColorByIndex(0).value
                                            }
                                        }
                                    }
                                }).pushInstance({
                                    objectName: "dataPoint",
                                    selector: null,
                                    properties: {
                                        showAllDataPoints: showAllDataPoints
                                    }
                                }), showAllDataPoints) for (var i = 0; i < seriesCount; i++) {
                                    var seriesDataPoints = data.dataPoints[i];
                                    enumeration.pushInstance({
                                        objectName: "dataPoint",
                                        displayName: seriesDataPoints.formattedCategory.getValue(),
                                        selector: ColorHelper.normalizeSelector(seriesDataPoints.identity.getSelector(), !0),
                                        properties: {
                                            fill: {
                                                solid: {
                                                    color: seriesDataPoints.fill
                                                }
                                            }
                                        }
                                    });
                                }
                            }
                        }
                    }, EnhancedScatterChart.prototype.enumerateObjectInstances = function(options) {
                        var enumeration = new ObjectEnumerationBuilder();
                        switch (options.objectName) {
                          case "dataPoint":
                            var categoricalDataView = this.dataView && this.dataView.categorical ? this.dataView.categorical : null;
                            GradientUtils.hasGradientRole(categoricalDataView) || this.enumerateDataPoints(enumeration);
                            break;

                          case "categoryAxis":
                            this.getCategoryAxisValues(enumeration);
                            break;

                          case "valueAxis":
                            this.getValueAxisValues(enumeration);
                            break;

                          case "categoryLabels":
                            this.data ? dataLabelUtils.enumerateCategoryLabels(enumeration, this.data.dataLabelsSettings, !0) : dataLabelUtils.enumerateCategoryLabels(enumeration, null, !0);
                            break;

                          case "fillPoint":
                            var sizeRange = this.data.sizeRange;
                            if (sizeRange && sizeRange.min) break;
                            enumeration.pushInstance({
                                objectName: "fillPoint",
                                selector: null,
                                properties: {
                                    show: this.data.fillPoint
                                }
                            });
                            break;

                          case "backdrop":
                            enumeration.pushInstance({
                                objectName: "backdrop",
                                displayName: "Backdrop",
                                selector: null,
                                properties: {
                                    show: !!this.data.backdrop && this.data.backdrop.show,
                                    url: this.data.backdrop ? this.data.backdrop.url : null
                                }
                            });
                            break;

                          case "crosshair":
                            enumeration.pushInstance({
                                objectName: "crosshair",
                                selector: null,
                                properties: {
                                    show: this.data.crosshair
                                }
                            });
                            break;

                          case "outline":
                            enumeration.pushInstance({
                                objectName: "outline",
                                selector: null,
                                properties: {
                                    show: this.data.outline
                                }
                            });
                            break;

                          case "legend":
                            this.enumerateLegend(enumeration);
                        }
                        return enumeration.complete() || [];
                    }, EnhancedScatterChart.prototype.hasLegend = function() {
                        return this.data && this.data.hasDynamicSeries;
                    }, EnhancedScatterChart.prototype.enumerateLegend = function(enumeration) {
                        if (this.hasLegend()) {
                            var show = DataViewObject.getValue(this.legendObjectProperties, legendProps.show, this.legend.isVisible()), showTitle = DataViewObject.getValue(this.legendObjectProperties, legendProps.showTitle, !0), titleText = DataViewObject.getValue(this.legendObjectProperties, legendProps.titleText, this.layerLegendData ? this.layerLegendData.title : ""), legendLabelColor = DataViewObject.getValue(this.legendObjectProperties, legendProps.labelColor, LegendData.DefaultLegendLabelFillColor);
                            this.legendLabelFontSize = DataViewObject.getValue(this.legendObjectProperties, legendProps.fontSize, EnhancedScatterChart.LegendLabelFontSizeDefault);
                            var position = DataViewObject.getValue(this.legendObjectProperties, legendProps.position, legendPosition.top);
                            enumeration.pushInstance({
                                selector: null,
                                properties: {
                                    show: show,
                                    position: position,
                                    showTitle: showTitle,
                                    titleText: titleText,
                                    labelColor: legendLabelColor,
                                    fontSize: this.legendLabelFontSize
                                },
                                objectName: "legend"
                            });
                        }
                    }, EnhancedScatterChart.prototype.getCategoryAxisValues = function(enumeration) {
                        var supportedType = axisType.both, isScalar = !0, logPossible = !1, scaleOptions = [ axisScale.log, axisScale.linear ];
                        isScalar || this.categoryAxisProperties && (this.categoryAxisProperties.start = null, 
                        this.categoryAxisProperties.end = null);
                        var instance = {
                            selector: null,
                            properties: {},
                            objectName: "categoryAxis",
                            validValues: {
                                axisScale: scaleOptions
                            }
                        };
                        instance.properties.show = !this.categoryAxisProperties || null == this.categoryAxisProperties.show || this.categoryAxisProperties.show, 
                        this.yAxisIsCategorical && (instance.properties.position = this.valueAxisProperties && null != this.valueAxisProperties.position ? this.valueAxisProperties.position : yAxisPosition.left), 
                        supportedType === axisType.both && (instance.properties.axisType = isScalar ? axisType.scalar : axisType.categorical), 
                        isScalar && (instance.properties.axisScale = this.categoryAxisProperties && null != this.categoryAxisProperties.axisScale && logPossible ? this.categoryAxisProperties.axisScale : axisScale.linear, 
                        instance.properties.start = this.categoryAxisProperties ? this.categoryAxisProperties.start : null, 
                        instance.properties.end = this.categoryAxisProperties ? this.categoryAxisProperties.end : null, 
                        instance.properties.labelDisplayUnits = this.categoryAxisProperties && null != this.categoryAxisProperties.labelDisplayUnits ? this.categoryAxisProperties.labelDisplayUnits : EnhancedScatterChart.LabelDisplayUnitsDefault), 
                        instance.properties.showAxisTitle = !this.categoryAxisProperties || null == this.categoryAxisProperties.showAxisTitle || this.categoryAxisProperties.showAxisTitle, 
                        enumeration.pushInstance(instance).pushInstance({
                            selector: null,
                            properties: {
                                axisStyle: this.categoryAxisProperties && this.categoryAxisProperties.axisStyle ? this.categoryAxisProperties.axisStyle : axisStyle.showTitleOnly,
                                labelColor: this.categoryAxisProperties ? this.categoryAxisProperties.labelColor : null
                            },
                            objectName: "categoryAxis",
                            validValues: {
                                axisStyle: this.categoryAxisHasUnitType ? [ axisStyle.showTitleOnly, axisStyle.showUnitOnly, axisStyle.showBoth ] : [ axisStyle.showTitleOnly ]
                            }
                        });
                    }, EnhancedScatterChart.prototype.getValueAxisValues = function(enumeration) {
                        var scaleOptions = [ axisScale.log, axisScale.linear ], logPossible = !1, instance = {
                            selector: null,
                            properties: {},
                            objectName: "valueAxis",
                            validValues: {
                                axisScale: scaleOptions,
                                secAxisScale: scaleOptions
                            }
                        };
                        instance.properties.show = !this.valueAxisProperties || null == this.valueAxisProperties.show || this.valueAxisProperties.show, 
                        this.yAxisIsCategorical || (instance.properties.position = this.valueAxisProperties && null != this.valueAxisProperties.position ? this.valueAxisProperties.position : yAxisPosition.left), 
                        instance.properties.axisScale = this.valueAxisProperties && null != this.valueAxisProperties.axisScale && logPossible ? this.valueAxisProperties.axisScale : axisScale.linear, 
                        instance.properties.start = this.valueAxisProperties ? this.valueAxisProperties.start : null, 
                        instance.properties.end = this.valueAxisProperties ? this.valueAxisProperties.end : null, 
                        instance.properties.showAxisTitle = !this.valueAxisProperties || null == this.valueAxisProperties.showAxisTitle || this.valueAxisProperties.showAxisTitle, 
                        instance.properties.labelDisplayUnits = this.valueAxisProperties && null != this.valueAxisProperties.labelDisplayUnits ? this.valueAxisProperties.labelDisplayUnits : EnhancedScatterChart.LabelDisplayUnitsDefault, 
                        enumeration.pushInstance(instance).pushInstance({
                            selector: null,
                            properties: {
                                axisStyle: this.valueAxisProperties && null != this.valueAxisProperties.axisStyle ? this.valueAxisProperties.axisStyle : axisStyle.showTitleOnly,
                                labelColor: this.valueAxisProperties ? this.valueAxisProperties.labelColor : null
                            },
                            objectName: "valueAxis",
                            validValues: {
                                axisStyle: this.valueAxisHasUnitType ? [ axisStyle.showTitleOnly, axisStyle.showUnitOnly, axisStyle.showBoth ] : [ axisStyle.showTitleOnly ]
                            }
                        });
                    }, EnhancedScatterChart.prototype.onClearSelection = function() {
                        this.interactivityService && this.interactivityService.clearSelection();
                    }, EnhancedScatterChart.AxisGraphicsContextClassName = "axisGraphicsContext", EnhancedScatterChart.ClassName = "enhancedScatterChart", 
                    EnhancedScatterChart.MainGraphicsContextClassName = "mainGraphicsContext", EnhancedScatterChart.LegendLabelFontSizeDefault = 9, 
                    EnhancedScatterChart.LabelDisplayUnitsDefault = 0, EnhancedScatterChart.AxisFontSize = 11, 
                    EnhancedScatterChart.CrosshairTextMargin = 5, EnhancedScatterChart.BubbleRadius = 6, 
                    EnhancedScatterChart.MinSizeRange = 200, EnhancedScatterChart.MaxSizeRange = 3e3, 
                    EnhancedScatterChart.AreaOf300By300Chart = 9e4, EnhancedScatterChart.DataLabelXOffset = 2, 
                    EnhancedScatterChart.DataLabelYOffset = 1.8, EnhancedScatterChart.DotClasses = createClassAndSelector("dot"), 
                    EnhancedScatterChart.ImageClasses = createClassAndSelector("img"), EnhancedScatterChart.TextProperties = {
                        fontFamily: "'Segoe UI', wf_segoe-ui_normal, helvetica, arial, sans-serif",
                        fontSize: PixelConverter.toString(EnhancedScatterChart.AxisFontSize)
                    }, EnhancedScatterChart.CrosshairCanvasSelector = createClassAndSelector("crosshairCanvas"), 
                    EnhancedScatterChart.CrosshairLineSelector = createClassAndSelector("crosshairLine"), 
                    EnhancedScatterChart.CrosshairVerticalLineSelector = createClassAndSelector("crosshairVerticalLine"), 
                    EnhancedScatterChart.CrosshairHorizontalLineSelector = createClassAndSelector("crosshairHorizontalLine"), 
                    EnhancedScatterChart.CrosshairTextSelector = createClassAndSelector("crosshairText"), 
                    EnhancedScatterChart.MaxTranslateValue = 1e25, EnhancedScatterChart.MinTranslateValue = 1e-25, 
                    EnhancedScatterChart.DefaultBubbleOpacity = .85, EnhancedScatterChart.DimmedBubbleOpacity = .4, 
                    EnhancedScatterChart.ColumnCategory = "Category", EnhancedScatterChart.ColumnSeries = "Series", 
                    EnhancedScatterChart.ColumnX = "X", EnhancedScatterChart.ColumnY = "Y", EnhancedScatterChart.ColumnSize = "Size", 
                    EnhancedScatterChart.ColumnGradient = "Gradient", EnhancedScatterChart.ColumnColorFill = "ColorFill", 
                    EnhancedScatterChart.ColumnShape = "Shape", EnhancedScatterChart.ColumnImage = "Image", 
                    EnhancedScatterChart.ColumnRotation = "Rotation", EnhancedScatterChart.ColumnBackdrop = "Backdrop", 
                    EnhancedScatterChart.ColumnXStart = "X Start", EnhancedScatterChart.ColumnXEnd = "X End", 
                    EnhancedScatterChart.ColumnYStart = "Y Start", EnhancedScatterChart.ColumnYEnd = "Y End", 
                    EnhancedScatterChart.capabilities = {
                        dataRoles: [ {
                            name: EnhancedScatterChart.ColumnCategory,
                            kind: VisualDataRoleKind.Grouping,
                            displayName: "Details"
                        }, {
                            name: EnhancedScatterChart.ColumnSeries,
                            kind: VisualDataRoleKind.Grouping,
                            displayName: "Legend"
                        }, {
                            name: EnhancedScatterChart.ColumnX,
                            kind: VisualDataRoleKind.Measure,
                            displayName: "X Axis"
                        }, {
                            name: EnhancedScatterChart.ColumnY,
                            kind: VisualDataRoleKind.Measure,
                            displayName: "Y Axis"
                        }, {
                            name: EnhancedScatterChart.ColumnSize,
                            kind: VisualDataRoleKind.Measure,
                            displayName: "Size"
                        }, {
                            name: EnhancedScatterChart.ColumnGradient,
                            kind: VisualDataRoleKind.Measure,
                            displayName: "Color saturation"
                        }, {
                            name: EnhancedScatterChart.ColumnColorFill,
                            kind: VisualDataRoleKind.Grouping,
                            displayName: "Customized Color"
                        }, {
                            name: EnhancedScatterChart.ColumnShape,
                            kind: VisualDataRoleKind.Measure,
                            displayName: "Shape"
                        }, {
                            name: EnhancedScatterChart.ColumnImage,
                            kind: VisualDataRoleKind.Grouping,
                            displayName: "Image"
                        }, {
                            name: EnhancedScatterChart.ColumnRotation,
                            kind: VisualDataRoleKind.Measure,
                            displayName: "Rotation"
                        }, {
                            name: EnhancedScatterChart.ColumnBackdrop,
                            kind: VisualDataRoleKind.Grouping,
                            displayName: "Backdrop"
                        }, {
                            name: EnhancedScatterChart.ColumnXStart,
                            kind: VisualDataRoleKind.Measure,
                            displayName: "X Start"
                        }, {
                            name: EnhancedScatterChart.ColumnXEnd,
                            kind: VisualDataRoleKind.Measure,
                            displayName: "X End"
                        }, {
                            name: EnhancedScatterChart.ColumnYStart,
                            kind: VisualDataRoleKind.Measure,
                            displayName: "Y Start"
                        }, {
                            name: EnhancedScatterChart.ColumnYEnd,
                            kind: VisualDataRoleKind.Measure,
                            displayName: "Y End"
                        } ],
                        dataViewMappings: [ {
                            conditions: [ {
                                Category: {
                                    max: 1
                                },
                                Series: {
                                    max: 0
                                },
                                X: {
                                    max: 1
                                },
                                Y: {
                                    max: 1
                                },
                                Size: {
                                    max: 1
                                },
                                Gradient: {
                                    max: 1
                                },
                                ColorFill: {
                                    max: 0
                                },
                                Shape: {
                                    max: 1
                                },
                                Image: {
                                    max: 0
                                },
                                Rotation: {
                                    max: 1
                                },
                                Backdrop: {
                                    max: 1
                                },
                                "X Start": {
                                    max: 1
                                },
                                "X End": {
                                    max: 1
                                },
                                "Y Start": {
                                    max: 1
                                },
                                "Y End": {
                                    max: 1
                                }
                            }, {
                                Category: {
                                    max: 1
                                },
                                Series: {
                                    max: 0
                                },
                                X: {
                                    max: 1
                                },
                                Y: {
                                    max: 1
                                },
                                Size: {
                                    max: 1
                                },
                                Gradient: {
                                    max: 0
                                },
                                ColorFill: {
                                    max: 1
                                },
                                Shape: {
                                    max: 1
                                },
                                Image: {
                                    max: 0
                                },
                                Rotation: {
                                    max: 1
                                },
                                Backdrop: {
                                    max: 1
                                },
                                "X Start": {
                                    max: 1
                                },
                                "X End": {
                                    max: 1
                                },
                                "Y Start": {
                                    max: 1
                                },
                                "Y End": {
                                    max: 1
                                }
                            }, {
                                Category: {
                                    max: 1
                                },
                                Series: {
                                    max: 0
                                },
                                X: {
                                    max: 1
                                },
                                Y: {
                                    max: 1
                                },
                                Size: {
                                    max: 1
                                },
                                Gradient: {
                                    max: 0
                                },
                                ColorFill: {
                                    max: 0
                                },
                                Shape: {
                                    max: 0
                                },
                                Image: {
                                    max: 1
                                },
                                Rotation: {
                                    max: 1
                                },
                                Backdrop: {
                                    max: 1
                                },
                                "X Start": {
                                    max: 1
                                },
                                "X End": {
                                    max: 1
                                },
                                "Y Start": {
                                    max: 1
                                },
                                "Y End": {
                                    max: 1
                                }
                            }, {
                                Category: {
                                    max: 1
                                },
                                Series: {
                                    max: 1
                                },
                                X: {
                                    max: 1
                                },
                                Y: {
                                    max: 1
                                },
                                Size: {
                                    max: 1
                                },
                                Gradient: {
                                    max: 0
                                },
                                ColorFill: {
                                    max: 1
                                },
                                Shape: {
                                    max: 1
                                },
                                Image: {
                                    max: 0
                                },
                                Rotation: {
                                    max: 1
                                },
                                Backdrop: {
                                    max: 1
                                },
                                "X Start": {
                                    max: 1
                                },
                                "X End": {
                                    max: 1
                                },
                                "Y Start": {
                                    max: 1
                                },
                                "Y End": {
                                    max: 1
                                }
                            }, {
                                Category: {
                                    max: 1
                                },
                                Series: {
                                    max: 1
                                },
                                X: {
                                    max: 1
                                },
                                Y: {
                                    max: 1
                                },
                                Size: {
                                    max: 1
                                },
                                Gradient: {
                                    max: 0
                                },
                                ColorFill: {
                                    max: 0
                                },
                                Shape: {
                                    max: 0
                                },
                                Image: {
                                    max: 1
                                },
                                Rotation: {
                                    max: 1
                                },
                                Backdrop: {
                                    max: 1
                                },
                                "X Start": {
                                    max: 1
                                },
                                "X End": {
                                    max: 1
                                },
                                "Y Start": {
                                    max: 1
                                },
                                "Y End": {
                                    max: 1
                                }
                            } ],
                            categorical: {
                                categories: {
                                    select: [ {
                                        bind: {
                                            to: EnhancedScatterChart.ColumnCategory
                                        }
                                    }, {
                                        bind: {
                                            to: EnhancedScatterChart.ColumnColorFill
                                        }
                                    }, {
                                        bind: {
                                            to: EnhancedScatterChart.ColumnImage
                                        }
                                    }, {
                                        bind: {
                                            to: EnhancedScatterChart.ColumnBackdrop
                                        }
                                    } ],
                                    dataReductionAlgorithm: {
                                        sample: {}
                                    }
                                },
                                values: {
                                    group: {
                                        by: EnhancedScatterChart.ColumnSeries,
                                        select: [ {
                                            bind: {
                                                to: EnhancedScatterChart.ColumnX
                                            }
                                        }, {
                                            bind: {
                                                to: EnhancedScatterChart.ColumnY
                                            }
                                        }, {
                                            bind: {
                                                to: EnhancedScatterChart.ColumnSize
                                            }
                                        }, {
                                            bind: {
                                                to: EnhancedScatterChart.ColumnGradient
                                            }
                                        }, {
                                            bind: {
                                                to: EnhancedScatterChart.ColumnShape
                                            }
                                        }, {
                                            bind: {
                                                to: EnhancedScatterChart.ColumnRotation
                                            }
                                        }, {
                                            bind: {
                                                to: EnhancedScatterChart.ColumnXStart
                                            }
                                        }, {
                                            bind: {
                                                to: EnhancedScatterChart.ColumnXEnd
                                            }
                                        }, {
                                            bind: {
                                                to: EnhancedScatterChart.ColumnYStart
                                            }
                                        }, {
                                            bind: {
                                                to: EnhancedScatterChart.ColumnYEnd
                                            }
                                        } ],
                                        dataReductionAlgorithm: {
                                            top: {}
                                        }
                                    }
                                },
                                rowCount: {
                                    preferred: {
                                        min: 2
                                    }
                                }
                            }
                        } ],
                        objects: {
                            dataPoint: {
                                displayName: "Data colors",
                                properties: {
                                    defaultColor: {
                                        displayName: "Default color",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    showAllDataPoints: {
                                        displayName: "Show all",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    fill: {
                                        displayName: "Fill",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    fillRule: {
                                        displayName: "Color saturation",
                                        type: {
                                            fillRule: {}
                                        },
                                        rule: {
                                            inputRole: EnhancedScatterChart.ColumnGradient,
                                            output: {
                                                property: "fill",
                                                selector: [ EnhancedScatterChart.ColumnCategory ]
                                            }
                                        }
                                    }
                                }
                            },
                            general: {
                                displayName: "General",
                                properties: {
                                    formatString: {
                                        type: {
                                            formatting: {
                                                formatString: !0
                                            }
                                        }
                                    }
                                }
                            },
                            categoryAxis: {
                                displayName: "X-Axis",
                                properties: {
                                    show: {
                                        displayName: "Show",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    axisScale: {
                                        displayName: "Scale type",
                                        type: {
                                            formatting: {
                                                axisScale: !0
                                            }
                                        }
                                    },
                                    start: {
                                        displayName: "Start",
                                        type: {
                                            numeric: !0
                                        }
                                    },
                                    end: {
                                        displayName: "End",
                                        type: {
                                            numeric: !0
                                        }
                                    },
                                    showAxisTitle: {
                                        displayName: "Title",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    axisStyle: {
                                        displayName: "Style",
                                        type: {
                                            formatting: {
                                                axisStyle: !0
                                            }
                                        }
                                    },
                                    axisColor: {
                                        displayName: "Color",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    labelDisplayUnits: {
                                        displayName: "Display Units",
                                        type: {
                                            formatting: {
                                                labelDisplayUnits: !0
                                            }
                                        }
                                    }
                                }
                            },
                            valueAxis: {
                                displayName: "Y-Axis",
                                properties: {
                                    show: {
                                        displayName: "Show",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    position: {
                                        displayName: "Position",
                                        type: {
                                            formatting: {
                                                yAxisPosition: !0
                                            }
                                        }
                                    },
                                    axisScale: {
                                        displayName: "Scale type",
                                        type: {
                                            formatting: {
                                                axisScale: !0
                                            }
                                        }
                                    },
                                    start: {
                                        displayName: "Start",
                                        type: {
                                            numeric: !0
                                        }
                                    },
                                    end: {
                                        displayName: "End",
                                        type: {
                                            numeric: !0
                                        }
                                    },
                                    showAxisTitle: {
                                        displayName: "Title",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    axisStyle: {
                                        displayName: "Style",
                                        type: {
                                            formatting: {
                                                axisStyle: !0
                                            }
                                        }
                                    },
                                    axisColor: {
                                        displayName: "Color",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    labelDisplayUnits: {
                                        displayName: "Display Units",
                                        type: {
                                            formatting: {
                                                labelDisplayUnits: !0
                                            }
                                        }
                                    }
                                }
                            },
                            legend: {
                                displayName: "Legend",
                                properties: {
                                    show: {
                                        displayName: "Show",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    position: {
                                        displayName: "Position",
                                        description: "Select the location for the legend",
                                        type: {
                                            enumeration: legendPosition.type
                                        }
                                    },
                                    showTitle: {
                                        displayName: "Title",
                                        description: "Display a title for legend symbols",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    titleText: {
                                        displayName: "Legend Name",
                                        description: "Title text",
                                        type: {
                                            text: !0
                                        }
                                    },
                                    labelColor: {
                                        displayName: "Color",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    fontSize: {
                                        displayName: "Text Size",
                                        type: {
                                            formatting: {
                                                fontSize: !0
                                            }
                                        }
                                    }
                                }
                            },
                            categoryLabels: {
                                displayName: "Category labels",
                                properties: {
                                    show: {
                                        displayName: "Show",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    color: {
                                        displayName: "Color",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    fontSize: {
                                        displayName: "Text Size",
                                        type: {
                                            formatting: {
                                                fontSize: !0
                                            }
                                        }
                                    }
                                }
                            },
                            fillPoint: {
                                displayName: "Fill point",
                                properties: {
                                    show: {
                                        displayName: "Fill",
                                        type: {
                                            bool: !0
                                        }
                                    }
                                }
                            },
                            backdrop: {
                                displayName: "Backdrop",
                                properties: {
                                    show: {
                                        displayName: "Show",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    url: {
                                        displayName: "Image URL",
                                        type: {
                                            text: !0
                                        }
                                    }
                                }
                            },
                            crosshair: {
                                displayName: "Crosshair",
                                properties: {
                                    show: {
                                        displayName: "Crosshair",
                                        type: {
                                            bool: !0
                                        }
                                    }
                                }
                            },
                            outline: {
                                displayName: "Outline",
                                properties: {
                                    show: {
                                        displayName: "Outline",
                                        type: {
                                            bool: !0
                                        }
                                    }
                                }
                            }
                        }
                    }, EnhancedScatterChart.Properties = EnhancedScatterChart.getPropertiesByCapabilities(EnhancedScatterChart.capabilities), 
                    EnhancedScatterChart;
                }();
                samples.EnhancedScatterChart = EnhancedScatterChart;
                var CustomVisualBehavior = function() {
                    function CustomVisualBehavior(behaviors) {
                        this.behaviors = behaviors || [];
                    }
                    return CustomVisualBehavior.prototype.bindEvents = function(options, selectionHandler) {
                        for (var behaviors = this.behaviors, i = 0, ilen = behaviors.length; i < ilen; i++) behaviors[i].bindEvents(options.layerOptions[i], selectionHandler);
                        options.clearCatcher.on("click", function() {
                            selectionHandler.handleClearSelection();
                        });
                    }, CustomVisualBehavior.prototype.renderSelection = function(hasSelection) {
                        for (var _i = 0, _a = this.behaviors; _i < _a.length; _i++) {
                            var behavior = _a[_i];
                            behavior.renderSelection(hasSelection);
                        }
                    }, CustomVisualBehavior;
                }();
                samples.CustomVisualBehavior = CustomVisualBehavior;
                var EnhancedScatterChartWebBehavior = function() {
                    function EnhancedScatterChartWebBehavior(dimmedBubbleOpacity, defaultBubbleOpacity) {
                        this.dimmedBubbleOpacity = dimmedBubbleOpacity, this.defaultBubbleOpacity = defaultBubbleOpacity;
                    }
                    return EnhancedScatterChartWebBehavior.prototype.bindEvents = function(options, selectionHandler) {
                        var bubbles = this.bubbles = options.dataPointsSelection, data = options.data;
                        this.shouldEnableFill = (!data.sizeRange || !data.sizeRange.min) && data.fillPoint, 
                        this.colorBorder = data.colorBorder, registerStandardInteractivityHandlers(bubbles, selectionHandler);
                    }, EnhancedScatterChartWebBehavior.prototype.renderSelection = function(hasSelection) {
                        var _this = this, shouldEnableFill = this.shouldEnableFill, colorBorder = this.colorBorder;
                        this.bubbles.style("fill-opacity", function(d) {
                            return _this.getMarkerFillOpacity(null != d.size, shouldEnableFill, hasSelection, d.selected);
                        }), this.bubbles.style("stroke-opacity", function(d) {
                            return _this.getMarkerStrokeOpacity(null != d.size, colorBorder, hasSelection, d.selected);
                        });
                    }, EnhancedScatterChartWebBehavior.prototype.getMarkerFillOpacity = function(hasSize, shouldEnableFill, hasSelection, isSelected) {
                        return hasSize || shouldEnableFill ? hasSelection && !isSelected ? this.dimmedBubbleOpacity : this.defaultBubbleOpacity : 0;
                    }, EnhancedScatterChartWebBehavior.prototype.getMarkerStrokeOpacity = function(hasSize, colorBorder, hasSelection, isSelected) {
                        return hasSize && colorBorder ? 1 : hasSelection && !isSelected ? this.dimmedBubbleOpacity : this.defaultBubbleOpacity;
                    }, EnhancedScatterChartWebBehavior;
                }();
                samples.EnhancedScatterChartWebBehavior = EnhancedScatterChartWebBehavior;
            }(samples = visuals.samples || (visuals.samples = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var THREE, WebGLHeatmap, GlobeMapCanvasLayers, powerbi, powerbi = (window.jsCommon, 
    window.powerbi);
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var samples;
            !function(samples) {
                var VisualLayout = function() {
                    function VisualLayout(defaultViewport, defaultMargin) {
                        this.defaultViewport = defaultViewport || {
                            width: 0,
                            height: 0
                        }, this.defaultMargin = defaultMargin || {
                            top: 0,
                            bottom: 0,
                            right: 0,
                            left: 0
                        };
                    }
                    return Object.defineProperty(VisualLayout.prototype, "viewport", {
                        get: function() {
                            return this.viewportValue || (this.viewportValue = this.defaultViewport);
                        },
                        set: function(value) {
                            var _this = this;
                            this.previousOriginalViewportValue = _.clone(this.originalViewportValue), this.originalViewportValue = _.clone(value), 
                            this.setUpdateObject(value, function(v) {
                                return _this.viewportValue = v;
                            }, function(o) {
                                return VisualLayout.restrictToMinMax(o, _this.minViewport);
                            });
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(VisualLayout.prototype, "viewportCopy", {
                        get: function() {
                            return _.clone(this.viewport);
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(VisualLayout.prototype, "viewportIn", {
                        get: function() {
                            return this.viewportInValue || this.viewport;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(VisualLayout.prototype, "minViewport", {
                        get: function() {
                            return this.minViewportValue || {
                                width: 0,
                                height: 0
                            };
                        },
                        set: function(value) {
                            var _this = this;
                            this.setUpdateObject(value, function(v) {
                                return _this.minViewportValue = v;
                            }, VisualLayout.restrictToMinMax);
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(VisualLayout.prototype, "margin", {
                        get: function() {
                            return this.marginValue || (this.marginValue = this.defaultMargin);
                        },
                        set: function(value) {
                            var _this = this;
                            this.setUpdateObject(value, function(v) {
                                return _this.marginValue = v;
                            }, VisualLayout.restrictToMinMax);
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(VisualLayout.prototype, "viewportChanged", {
                        get: function() {
                            return !(!this.originalViewportValue || this.previousOriginalViewportValue && this.previousOriginalViewportValue.height === this.originalViewportValue.height && this.previousOriginalViewportValue.width === this.originalViewportValue.width);
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(VisualLayout.prototype, "viewportInIsZero", {
                        get: function() {
                            return 0 === this.viewportIn.width || 0 === this.viewportIn.height;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), VisualLayout.prototype.resetMargin = function() {
                        this.margin = this.defaultMargin;
                    }, VisualLayout.prototype.update = function() {
                        this.viewportInValue = VisualLayout.restrictToMinMax({
                            width: this.viewport.width - (this.margin.left + this.margin.right),
                            height: this.viewport.height - (this.margin.top + this.margin.bottom)
                        }, this.minViewportValue);
                    }, VisualLayout.prototype.setUpdateObject = function(object, setObjectFn, beforeUpdateFn) {
                        var _this = this;
                        object = _.clone(object), setObjectFn(VisualLayout.createNotifyChangedObject(object, function(o) {
                            beforeUpdateFn && beforeUpdateFn(object), _this.update();
                        })), beforeUpdateFn && beforeUpdateFn(object), this.update();
                    }, VisualLayout.createNotifyChangedObject = function(object, objectChanged) {
                        var result = {};
                        return _.keys(object).forEach(function(key) {
                            return Object.defineProperty(result, key, {
                                get: function() {
                                    return object[key];
                                },
                                set: function(value) {
                                    object[key] = value, objectChanged(object, key);
                                },
                                enumerable: !0,
                                configurable: !0
                            });
                        }), result;
                    }, VisualLayout.restrictToMinMax = function(value, minValue) {
                        return _.keys(value).forEach(function(x) {
                            return value[x] = Math.max(minValue && minValue[x] || 0, value[x]);
                        }), value;
                    }, VisualLayout;
                }(), GlobeMapSettings = function() {
                    function GlobeMapSettings() {
                        this.dataPoint = {};
                    }
                    return Object.defineProperty(GlobeMapSettings, "Default", {
                        get: function() {
                            return new this();
                        },
                        enumerable: !0,
                        configurable: !0
                    }), GlobeMapSettings.parse = function(dataView, capabilities) {
                        var settings = new this();
                        if (!dataView || !dataView.metadata || !dataView.metadata.objects) return settings;
                        var properties = this.getProperties(capabilities);
                        for (var objectKey in capabilities.objects) for (var propKey in capabilities.objects[objectKey].properties) if (settings[objectKey] && _.has(settings[objectKey], propKey)) {
                            var type = capabilities.objects[objectKey].properties[propKey].type, getValueFn = this.getValueFnByType(type);
                            settings[objectKey][propKey] = getValueFn(dataView.metadata.objects, properties[objectKey][propKey], settings[objectKey][propKey]);
                        }
                        return settings;
                    }, GlobeMapSettings.getProperties = function(capabilities) {
                        var objects = _.merge({
                            general: {
                                properties: {
                                    formatString: {}
                                }
                            }
                        }, capabilities.objects), properties = {};
                        for (var objectKey in objects) {
                            properties[objectKey] = {};
                            for (var propKey in objects[objectKey].properties) properties[objectKey][propKey] = {
                                objectName: objectKey,
                                propertyName: propKey
                            };
                        }
                        return properties;
                    }, GlobeMapSettings.createEnumTypeFromEnum = function(type) {
                        var even = !1;
                        return powerbi.createEnumType(Object.keys(type).filter(function(key, i) {
                            return !!(i % 2) === even && type[key] === key && !void (even = !even) || !!(i % 2) !== even;
                        }).map(function(x) {
                            return {
                                value: x,
                                displayName: x
                            };
                        }));
                    }, GlobeMapSettings.getValueFnByType = function(type) {
                        switch (_.keys(type)[0]) {
                          case "fill":
                            return powerbi.DataViewObjects.getFillColor;

                          default:
                            return powerbi.DataViewObjects.getValue;
                        }
                    }, GlobeMapSettings.enumerateObjectInstances = function(settings, options, capabilities) {
                        void 0 === settings && (settings = new this());
                        var enumeration = new visuals.ObjectEnumerationBuilder(), object = settings && settings[options.objectName];
                        if (!object) return enumeration;
                        var instance = {
                            objectName: options.objectName,
                            selector: null,
                            properties: {}
                        };
                        for (var key in object) _.has(object, key) && (instance.properties[key] = object[key]);
                        return enumeration.pushInstance(instance), enumeration;
                    }, GlobeMapSettings.prototype.createOriginalSettings = function() {
                        this.originalSettings = _.cloneDeep(this);
                    }, GlobeMapSettings;
                }();
                samples.GlobeMapSettings = GlobeMapSettings;
                var GlobeMapColumns = function() {
                    function GlobeMapColumns() {
                        this.Category = null, this.Series = null, this.X = null, this.Y = null, this.Height = null, 
                        this.Heat = null;
                    }
                    return GlobeMapColumns.getColumnSources = function(dataView) {
                        return this.getColumnSourcesT(dataView);
                    }, GlobeMapColumns.getTableValues = function(dataView) {
                        var table = dataView && dataView.table, columns = this.getColumnSourcesT(dataView);
                        return columns && table && _.mapValues(columns, function(n, i) {
                            return n && table.rows.map(function(row) {
                                return row[n.index];
                            });
                        });
                    }, GlobeMapColumns.getTableRows = function(dataView) {
                        var table = dataView && dataView.table, columns = this.getColumnSourcesT(dataView);
                        return columns && table && table.rows.map(function(row) {
                            return _.mapValues(columns, function(n, i) {
                                return n && row[n.index];
                            });
                        });
                    }, GlobeMapColumns.getCategoricalValues = function(dataView) {
                        var categorical = dataView && dataView.categorical, categories = categorical && categorical.categories || [], values = categorical && categorical.values || [], series = categorical && values.source && this.getSeriesValues(dataView);
                        return categorical && _.mapValues(new this(), function(n, i) {
                            return _.toArray(categories).concat(_.toArray(values)).filter(function(x) {
                                return x.source.roles && x.source.roles[i];
                            }).map(function(x) {
                                return x.values;
                            })[0] || values.source && values.source.roles && values.source.roles[i] && series;
                        });
                    }, GlobeMapColumns.getSeriesValues = function(dataView) {
                        return dataView && dataView.categorical && dataView.categorical.values && dataView.categorical.values.map(function(x) {
                            return visuals.converterHelper.getSeriesName(x.source);
                        });
                    }, GlobeMapColumns.getCategoricalColumns = function(dataView) {
                        var categorical = dataView && dataView.categorical, categories = categorical && categorical.categories || [], values = categorical && categorical.values || [];
                        return categorical && _.mapValues(new this(), function(n, i) {
                            return categories.filter(function(x) {
                                return x.source.roles && x.source.roles[i];
                            })[0] || values.source && values.source.roles && values.source.roles[i] && values || values.filter(function(x) {
                                return x.source.roles && x.source.roles[i];
                            });
                        });
                    }, GlobeMapColumns.getGroupedValueColumns = function(dataView) {
                        var _this = this, categorical = dataView && dataView.categorical, values = categorical && categorical.values, grouped = values && values.grouped();
                        return grouped && grouped.map(function(g) {
                            return _.mapValues(new _this(), function(n, i) {
                                return g.values.filter(function(v) {
                                    return v.source.roles[i];
                                })[0];
                            });
                        });
                    }, GlobeMapColumns.getColumnSourcesT = function(dataView) {
                        var columns = dataView && dataView.metadata && dataView.metadata.columns;
                        return columns && _.mapValues(new this(), function(n, i) {
                            return columns.filter(function(x) {
                                return x.roles && x.roles[i];
                            })[0];
                        });
                    }, GlobeMapColumns.Roles = Object.freeze(_.mapValues(new GlobeMapColumns(), function(x, i) {
                        return i;
                    })), GlobeMapColumns;
                }();
                samples.GlobeMapColumns = GlobeMapColumns;
                var GlobeMap = function() {
                    function GlobeMap() {
                        this.locationsToLoad = 0, this.locationsLoaded = 0, this.renderLoopEnabled = !0, 
                        this.needsRender = !1;
                    }
                    return Object.defineProperty(GlobeMap.prototype, "settings", {
                        get: function() {
                            return this.data && this.data.settings;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), GlobeMap.converter = function(dataView, colors) {
                        var categorical = GlobeMapColumns.getCategoricalColumns(dataView);
                        if (!categorical || !categorical.Category || _.isEmpty(categorical.Category.values) || _.isEmpty(categorical.Height) && _.isEmpty(categorical.Heat)) return null;
                        var locationType, heights, heightsBySeries, toolTipDataBySeries, heats, properties = GlobeMapSettings.getProperties(GlobeMap.capabilities), settings = GlobeMap.parseSettings(dataView), groupedColumns = GlobeMapColumns.getGroupedValueColumns(dataView), dataPoints = [], seriesDataPoints = [], locations = [], colorHelper = new visuals.ColorHelper(colors, properties.dataPoint.fill);
                        if (categorical.Category && categorical.Category.values) {
                            locations = categorical.Category.values;
                            var type = categorical.Category.source.type;
                            locationType = type.category ? type.category.toLowerCase() : "";
                        } else locations = [];
                        if (_.isEmpty(categorical.Height)) heightsBySeries = new Array(locations.length), 
                        heights = new Array(locations.length); else if (groupedColumns.length > 1) {
                            heights = new Array(locations.length), heightsBySeries = new Array(locations.length), 
                            toolTipDataBySeries = new Array(locations.length), seriesDataPoints = new Array(groupedColumns.length);
                            for (var i = 0; i < groupedColumns.length; i++) {
                                var values = groupedColumns[i].Height.values;
                                seriesDataPoints[i] = GlobeMap.createDataPointForEnumeration(dataView, groupedColumns[i].Height.source, i, null, colorHelper, colors);
                                for (var j = 0; j < values.length; j++) heights[j] || (heights[j] = 0), heights[j] += values[j] ? values[j] : 0, 
                                heightsBySeries[j] || (heightsBySeries[j] = []), heightsBySeries[j][i] = values[j], 
                                toolTipDataBySeries[j] || (toolTipDataBySeries[j] = []), toolTipDataBySeries[j][i] = {
                                    displayName: categorical.Series && categorical.Series.source.displayName,
                                    value: dataView.categorical.values.grouped()[i].name,
                                    dataPointValue: values[j]
                                };
                            }
                            for (var i = 0; i < groupedColumns.length; i++) for (var values = groupedColumns[i].Height.values, j = 0; j < values.length; j++) heightsBySeries[j][i] = values[j] / heights[j];
                        } else heights = categorical.Height[0].values, heightsBySeries = new Array(groupedColumns.length), 
                        seriesDataPoints[0] = GlobeMap.createDataPointForEnumeration(dataView, groupedColumns[0].Height.source, 0, dataView.metadata, colorHelper, colors);
                        if (_.isEmpty(categorical.Heat)) heats = new Array(locations.length); else if (groupedColumns.length > 1) {
                            heats = new Array(locations.length);
                            for (var i = 0; i < groupedColumns.length; i++) for (var values = groupedColumns[i].Heat.values, j = 0; j < values.length; j++) heats[j] || (heats[j] = 0), 
                            heats[j] += values[j] ? values[j] : 0;
                        } else heats = categorical.Heat[0].values;
                        for (var maxHeight = Math.max.apply(null, heights) || 1, maxHeat = Math.max.apply(null, heats) || 1, heatFormatter = visuals.valueFormatter.create({
                            format: !_.isEmpty(categorical.Heat) && categorical.Heat[0].source.format,
                            value: heats[0],
                            value2: heats[1]
                        }), heightFormatter = visuals.valueFormatter.create({
                            format: !_.isEmpty(categorical.Height) && categorical.Height[0].source.format,
                            value: heights[0],
                            value2: heights[1]
                        }), i = 0, len = locations.length; i < len; ++i) if ("string" == typeof locations[i]) {
                            var place = locations[i].toLowerCase(), placeKey = place + "/" + locationType, location = _.isEmpty(categorical.X) || _.isEmpty(categorical.Y) ? void 0 : {
                                longitude: categorical.X[0].values[i] || 0,
                                latitude: categorical.Y[0].values[i] || 0
                            }, height = heights[i] / maxHeight, heat = heats[i] / maxHeat, renderDatum = {
                                location: location,
                                placeKey: placeKey,
                                place: place,
                                locationType: locationType,
                                height: height ? height || .01 : void 0,
                                heightBySeries: heightsBySeries[i],
                                seriesToolTipData: toolTipDataBySeries ? toolTipDataBySeries[i] : void 0,
                                heat: heat || 0,
                                toolTipData: {
                                    location: {
                                        displayName: categorical.Category && categorical.Category.source.displayName,
                                        value: locations[i]
                                    },
                                    height: {
                                        displayName: !_.isEmpty(categorical.Height) && categorical.Height[0].source.displayName,
                                        value: heightFormatter.format(heights[i])
                                    },
                                    heat: {
                                        displayName: !_.isEmpty(categorical.Heat) && categorical.Heat[0].source.displayName,
                                        value: heatFormatter.format(heats[i])
                                    }
                                }
                            };
                            dataPoints.push(renderDatum);
                        }
                        return {
                            dataView: dataView,
                            dataPoints: dataPoints,
                            seriesDataPoints: seriesDataPoints,
                            settings: settings
                        };
                    }, GlobeMap.parseSettings = function(dataView) {
                        var settings = GlobeMapSettings.parse(dataView, GlobeMap.capabilities);
                        return settings.createOriginalSettings(), settings;
                    }, GlobeMap.createDataPointForEnumeration = function(dataView, source, seriesIndex, metaData, colorHelper, colors) {
                        var columns = dataView.categorical.values.grouped()[seriesIndex], label = visuals.converterHelper.getFormattedLegendLabel(source, columns.values, null), identity = visuals.SelectionId.createWithId(columns.identity), category = visuals.converterHelper.getSeriesName(source), objects = columns.objects, color = objects && objects.dataPoint ? objects.dataPoint.fill.solid.color : metaData && metaData.objects ? colorHelper.getColorForMeasure(metaData.objects, "") : colors.getColorByIndex(seriesIndex).value;
                        return {
                            label: label,
                            identity: identity,
                            category: category,
                            color: color,
                            selected: null
                        };
                    }, GlobeMap.prototype.enumerateObjectInstances = function(options) {
                        var instances = GlobeMapSettings.enumerateObjectInstances(this.settings && this.settings.originalSettings, options, GlobeMap.capabilities);
                        switch (options.objectName) {
                          case "dataPoint":
                            if (this.data && this.data.seriesDataPoints) for (var i = 0; i < this.data.seriesDataPoints.length; i++) {
                                var dataPoint = this.data.seriesDataPoints[i];
                                instances.pushInstance({
                                    objectName: "dataPoint",
                                    displayName: dataPoint.label,
                                    selector: visuals.ColorHelper.normalizeSelector(dataPoint.identity.getSelector()),
                                    properties: {
                                        fill: {
                                            solid: {
                                                color: dataPoint.color
                                            }
                                        }
                                    }
                                });
                            }
                        }
                        return instances.complete();
                    }, GlobeMap.prototype.init = function(options) {
                        this.root = $("<div>").appendTo(options.element).attr("drag-resize-disabled", "true").css({
                            position: "absolute"
                        }), this.layout = new VisualLayout(options.viewport), this.readyToRender = !1, this.globeMapLocationCache || (this.globeMapLocationCache = {}), 
                        this.style = options.style, this.colors = this.style.colorPalette.dataColors, window.THREE && this.setup();
                    }, GlobeMap.prototype.setup = function() {
                        this.initTextures(), this.initMercartorSphere(), this.initZoomControl(), this.initScene(), 
                        this.initHeatmap(), this.readyToRender = !0, this.initRayCaster();
                    }, GlobeMap.prototype.initScene = function() {
                        var _this = this;
                        this.renderer = new THREE.WebGLRenderer({
                            antialias: !0,
                            preserveDrawingBuffer: !0
                        }), this.rendererContainer = $("<div>").appendTo(this.root).css({
                            width: "100%",
                            height: "100%",
                            position: "relative"
                        }), this.rendererContainer.append(this.renderer.domElement), this.rendererCanvas = this.renderer.domElement, 
                        this.camera = new THREE.PerspectiveCamera(35, this.layout.viewportIn.width / this.layout.viewportIn.height, .1, 1e4), 
                        this.orbitControls = new THREE.OrbitControls(this.camera, this.rendererCanvas), 
                        this.orbitControls.enablePan = !1, this.scene = new THREE.Scene(), this.renderer.setSize(this.layout.viewportIn.width, this.layout.viewportIn.height), 
                        this.renderer.setClearColor(12240082, 1), this.camera.position.z = GlobeMap.GlobeSettings.cameraRadius, 
                        this.orbitControls.maxDistance = GlobeMap.GlobeSettings.cameraRadius, this.orbitControls.minDistance = GlobeMap.GlobeSettings.earthRadius + 1, 
                        this.orbitControls.rotateSpeed = GlobeMap.GlobeSettings.rotateSpeed, this.orbitControls.zoomSpeed = GlobeMap.GlobeSettings.zoomSpeed, 
                        this.orbitControls.autoRotate = GlobeMap.GlobeSettings.autoRotate;
                        var ambientLight = new THREE.AmbientLight(0), light1 = new THREE.DirectionalLight(16777215, .4), light2 = new THREE.DirectionalLight(16777215, .4), earth = this.earth = this.createEarth();
                        this.scene.add(ambientLight), this.scene.add(light1), this.scene.add(light2), this.scene.add(earth), 
                        light1.position.set(20, 20, 20), light2.position.set(0, 0, -20);
                        var render = function() {
                            try {
                                if (_this.renderLoopEnabled && (_this.animationFrameId = requestAnimationFrame(render)), 
                                !_this.shouldRender()) return;
                                _this.orbitControls.update(), _this.setEarthTexture(), _this.heatmap && _this.heatmap.display && _this.heatmap.display(), 
                                _this.renderer.render(_this.scene, _this.camera), _this.intersectBars(), _this.needsRender = !1;
                            } catch (e) {}
                        };
                        this.animationFrameId = requestAnimationFrame(render);
                    }, GlobeMap.prototype.shouldRender = function() {
                        return this.readyToRender && this.needsRender;
                    }, GlobeMap.prototype.createEarth = function() {
                        var geometry = new GlobeMap.MercartorSphere(GlobeMap.GlobeSettings.earthRadius, GlobeMap.GlobeSettings.earthSegments, GlobeMap.GlobeSettings.earthSegments), material = new THREE.MeshPhongMaterial({
                            map: this.mapTextures[0],
                            side: THREE.DoubleSide,
                            shading: THREE.SmoothShading,
                            shininess: 1
                        }), mesh = new THREE.Mesh(geometry, material);
                        return mesh.add(new THREE.AmbientLight(11184810, 1)), mesh;
                    }, GlobeMap.prototype.zoomClicked = function(zoomDirection) {
                        this.orbitControls.enabled !== !1 && (zoomDirection === -1 ? this.orbitControls.dollyOut(Math.pow(.95, GlobeMap.GlobeSettings.zoomSpeed)) : 1 === zoomDirection && this.orbitControls.dollyIn(Math.pow(.95, GlobeMap.GlobeSettings.zoomSpeed)), 
                        this.orbitControls.update(), this.animateCamera(this.camera.position));
                    }, GlobeMap.prototype.rotateCam = function(deltaX, deltaY) {
                        this.orbitControls.enabled && (this.orbitControls.rotateLeft(2 * Math.PI * deltaX / this.rendererCanvas.offsetHeight * GlobeMap.GlobeSettings.rotateSpeed), 
                        this.orbitControls.rotateUp(2 * Math.PI * deltaY / this.rendererCanvas.offsetHeight * GlobeMap.GlobeSettings.rotateSpeed), 
                        this.orbitControls.update(), this.animateCamera(this.camera.position));
                    }, GlobeMap.prototype.initTextures = function() {
                        var _this = this;
                        if (!GlobeMapCanvasLayers) {
                            GlobeMapCanvasLayers = [];
                            for (var level = 2; level <= 5; ++level) {
                                var canvas = this.getBingMapCanvas(level);
                                GlobeMapCanvasLayers.push(canvas);
                            }
                        }
                        var createTexture = function(canvas) {
                            var texture = new THREE.Texture(canvas.get(0));
                            return texture.needsUpdate = !0, canvas.on("ready", function(e, resolution) {
                                texture.needsUpdate = !0, _this.needsRender = !0;
                            }), texture;
                        };
                        this.mapTextures = [];
                        for (var i = 0; i < GlobeMapCanvasLayers.length; ++i) this.mapTextures.push(createTexture(GlobeMapCanvasLayers[i]));
                    }, GlobeMap.prototype.initHeatmap = function() {
                        try {
                            var heatmap = this.heatmap = new WebGLHeatmap({
                                width: GlobeMap.GlobeSettings.heatmapSize,
                                height: GlobeMap.GlobeSettings.heatmapSize,
                                intensityToAlpha: !0
                            });
                        } catch (e) {}
                        var texture = this.heatTexture = new THREE.Texture(heatmap.canvas);
                        texture.needsUpdate = !0;
                        var material = new THREE.MeshBasicMaterial({
                            map: texture,
                            transparent: !0
                        }), geometry = new THREE.SphereGeometry(GlobeMap.GlobeSettings.earthRadius + .01, GlobeMap.GlobeSettings.earthSegments, GlobeMap.GlobeSettings.earthSegments), mesh = new THREE.Mesh(geometry, material);
                        window.heatmap = heatmap, window.heatmapTexture = texture, this.scene.add(mesh);
                    }, GlobeMap.prototype.setEarthTexture = function() {
                        if (this.camera) {
                            var texture, maxDistance = GlobeMap.GlobeSettings.cameraRadius - GlobeMap.GlobeSettings.earthRadius, distance = (this.camera.position.length() - GlobeMap.GlobeSettings.earthRadius) / maxDistance;
                            texture = distance <= .2 ? this.mapTextures[3] : distance <= .4 ? this.mapTextures[2] : distance <= .6 ? this.mapTextures[1] : this.mapTextures[0], 
                            this.earth.material.map !== texture && (this.earth.material.map = texture), this.selectedBar ? this.orbitControls.rotateSpeed = GlobeMap.GlobeSettings.rotateSpeed : this.orbitControls.rotateSpeed = GlobeMap.GlobeSettings.rotateSpeed * distance;
                        }
                    }, GlobeMap.prototype.update = function(options) {
                        if (this.layout.viewport = options.viewport, this.root.css(this.layout.viewportIn), 
                        this.zoomContainer.style({
                            "padding-left": this.layout.viewportIn.width - parseFloat(this.zoomControl.attr("width")) + 6 + "px",
                            display: this.layout.viewportIn.height > $(this.zoomContainer.node()).height() && this.layout.viewportIn.width > $(this.zoomContainer.node()).width() ? null : "none"
                        }), this.layout.viewportChanged && this.camera && this.renderer && (this.camera.aspect = this.layout.viewportIn.width / this.layout.viewportIn.height, 
                        this.camera.updateProjectionMatrix(), this.renderer.setSize(this.layout.viewportIn.width, this.layout.viewportIn.height), 
                        this.renderer.render(this.scene, this.camera)), options.type === powerbi.VisualUpdateType.Data) {
                            this.cleanHeatAndBar();
                            var data = GlobeMap.converter(options.dataViews[0], this.colors);
                            data && (this.data = data, this.renderMagic());
                        }
                    }, GlobeMap.prototype.cleanHeatAndBar = function() {
                        this.heatmap.clear(), this.heatTexture.needsUpdate = !0, this.barsGroup && this.scene.remove(this.barsGroup);
                    }, GlobeMap.prototype.renderMagic = function() {
                        var _this = this;
                        if (this.data) {
                            if (this.data.dataPoints.forEach(function(d) {
                                return _this.geocodeRenderDatum(d);
                            }), this.data.dataPoints.forEach(function(d) {
                                return d.location = d.location || _this.globeMapLocationCache[d.placeKey];
                            }), !this.readyToRender) return void this.defferedRender();
                            this.heatmap.clear(), this.barsGroup && this.scene.remove(this.barsGroup), this.barsGroup = new THREE.Object3D(), 
                            this.scene.add(this.barsGroup), this.averageBarVector = new THREE.Vector3();
                            for (var i = 0, len = this.data.dataPoints.length; i < len; ++i) {
                                var renderDatum = this.data.dataPoints[i];
                                if (renderDatum.location && void 0 !== renderDatum.location.longitude && void 0 !== renderDatum.location.latitude) {
                                    if (renderDatum.heat > .001) {
                                        renderDatum.heat < .1 && (renderDatum.heat = .1);
                                        var x = (180 + renderDatum.location.longitude) / 360 * GlobeMap.GlobeSettings.heatmapSize, y = (1 - (90 + renderDatum.location.latitude) / 180) * GlobeMap.GlobeSettings.heatmapSize;
                                        this.heatmap.addPoint(x, y, GlobeMap.GlobeSettings.heatPointSize, renderDatum.heat * GlobeMap.GlobeSettings.heatIntensity);
                                    }
                                    if (renderDatum.height >= 0) {
                                        renderDatum.height < .01 && (renderDatum.height = .01);
                                        var latRadians = renderDatum.location.latitude / 180 * Math.PI, lngRadians = renderDatum.location.longitude / 180 * Math.PI, x = Math.cos(lngRadians) * Math.cos(latRadians), z = -Math.sin(lngRadians) * Math.cos(latRadians), y = Math.sin(latRadians), vector = new THREE.Vector3(x, y, z);
                                        this.averageBarVector.add(vector);
                                        var barHeight = GlobeMap.GlobeSettings.barHeight * renderDatum.height, measuresBySeries = [], dataPointToolTip = [];
                                        if (renderDatum.heightBySeries) for (var c = 0; c < renderDatum.heightBySeries.length; c++) renderDatum.heightBySeries[c] && measuresBySeries.push(renderDatum.heightBySeries[c]), 
                                        dataPointToolTip.push(renderDatum.seriesToolTipData[c]); else measuresBySeries.push(1);
                                        for (var previousMeasureValue = 0, j = 0; j < measuresBySeries.length; j++) {
                                            previousMeasureValue += measuresBySeries[j];
                                            var geometry = new THREE.BoxGeometry(GlobeMap.GlobeSettings.barWidth, GlobeMap.GlobeSettings.barWidth, barHeight * measuresBySeries[j]), bar = new THREE.Mesh(geometry, this.getBarMaterialByIndex(j)), position = vector.clone().multiplyScalar(GlobeMap.GlobeSettings.earthRadius + barHeight / 2 * previousMeasureValue);
                                            bar.position.set(position.x, position.y, position.z), bar.lookAt(vector), bar.toolTipData = 0 === dataPointToolTip.length ? renderDatum.toolTipData : this.getToolTipDataForSeries(renderDatum.toolTipData, dataPointToolTip[j]), 
                                            this.barsGroup.add(bar), previousMeasureValue += measuresBySeries[j];
                                        }
                                    }
                                }
                            }
                            this.barsGroup.children.length > 0 && this.camera && (this.averageBarVector.multiplyScalar(1 / this.barsGroup.children.length), 
                            this.locationsLoaded === this.locationsToLoad && this.animateCamera(this.averageBarVector)), 
                            this.heatmap.update(), this.heatmap.blur(), this.heatTexture.needsUpdate = !0, this.needsRender = !0;
                        }
                    }, GlobeMap.prototype.getBarMaterialByIndex = function(index) {
                        return new THREE.MeshPhongMaterial({
                            color: this.data.seriesDataPoints[index].color
                        });
                    }, GlobeMap.prototype.getToolTipDataForSeries = function(toolTipData, dataPointToolTip) {
                        var result = jQuery.extend(!0, {
                            series: {
                                displayName: dataPointToolTip.displayName,
                                value: dataPointToolTip.value
                            }
                        }, toolTipData);
                        return result.height.value = dataPointToolTip.dataPointValue, result;
                    }, GlobeMap.prototype.geocodeRenderDatum = function(renderDatum) {
                        var _this = this;
                        if (!renderDatum.location && !this.globeMapLocationCache[renderDatum.placeKey]) {
                            var location = {};
                            this.globeMapLocationCache[renderDatum.placeKey] = location, this.locationsToLoad++;
                            try {
                                var geocoder = powerbi.visuals.BI.Services.GeocodingManager.geocode;
                            } catch (e) {
                                geocoder = visuals.services.geocode;
                            }
                            geocoder && geocoder(renderDatum.place, renderDatum.locationType).always(function(l) {
                                l && (location.latitude = l.latitude, location.longitude = l.longitude), _this.locationsLoaded++, 
                                _this.defferedRender();
                            });
                        }
                    }, GlobeMap.prototype.defferedRender = function() {
                        var _this = this;
                        this.deferredRenderTimerId || (this.deferredRenderTimerId = setTimeout(function() {
                            _this.deferredRenderTimerId = null, _this.renderMagic();
                        }, 500));
                    }, GlobeMap.prototype.initRayCaster = function() {
                        var _this = this;
                        this.rayCaster = new THREE.Raycaster();
                        var mouseDownTime, element = this.root.get(0), elementStyle = window.getComputedStyle(element);
                        $(this.rendererCanvas).on("mousemove", function(event) {
                            var elementViewHeight = element.offsetHeight - element.offsetTop - parseFloat(elementStyle.paddingTop) - parseFloat(elementStyle.paddingBottom), elementViewWidth = element.offsetWidth - element.offsetLeft - parseFloat(elementStyle.paddingLeft) - parseFloat(elementStyle.paddingRight), fractionalPositionX = event.offsetX / elementViewWidth, fractionalPositionY = event.offsetY / elementViewHeight;
                            _this.mousePos = new THREE.Vector2(event.clientX, event.clientY), _this.mousePosNormalized = new THREE.Vector2(2 * fractionalPositionX - 1, 2 * -fractionalPositionY + 1), 
                            _this.needsRender = !0;
                        }).on("mousedown", function(event) {
                            cancelAnimationFrame(_this.cameraAnimationFrameId), mouseDownTime = Date.now();
                        }).on("mouseup", function(event) {
                            Date.now() - mouseDownTime > GlobeMap.GlobeSettings.clickInterval || (_this.hoveredBar && event.shiftKey ? (_this.selectedBar = _this.hoveredBar, 
                            _this.animateCamera(_this.selectedBar.position, function() {
                                _this.selectedBar && (_this.orbitControls.target.copy(_this.selectedBar.position.clone().normalize().multiplyScalar(GlobeMap.GlobeSettings.earthRadius)), 
                                _this.orbitControls.minDistance = 1);
                            })) : _this.selectedBar && (_this.animateCamera(_this.selectedBar.position, function() {
                                _this.orbitControls.target.set(0, 0, 0), _this.orbitControls.minDistance = GlobeMap.GlobeSettings.earthRadius + 1;
                            }), _this.selectedBar = null));
                        }).on("mousewheel DOMMouseScroll", function(e) {
                            if (_this.needsRender = !0, _this.orbitControls.enabled && _this.orbitControls.enableZoom) {
                                cancelAnimationFrame(_this.cameraAnimationFrameId), _this.heatTexture.needsUpdate = !0, 
                                e = e.originalEvent;
                                var delta = e.wheelDelta > 0 || e.detail < 0 ? 1 : -1, scale = delta > 0 ? GlobeMap.GlobeSettings.heatmapScaleOnZoom : 1 / GlobeMap.GlobeSettings.heatmapScaleOnZoom;
                                _this.heatmap.multiply(scale), _this.heatmap.update();
                            }
                        });
                    }, GlobeMap.prototype.intersectBars = function() {
                        if (this.rayCaster && this.barsGroup && this.mousePosNormalized && this.mousePos) {
                            var rayCaster = this.rayCaster;
                            rayCaster.setFromCamera(this.mousePosNormalized, this.camera);
                            var intersects = rayCaster.intersectObjects(this.barsGroup.children);
                            if (intersects && intersects.length > 0) {
                                var object = intersects[0].object;
                                if (!object || !object.toolTipData) return;
                                var toolTipData = object.toolTipData, toolTipItems = [];
                                toolTipData.location.displayName && toolTipItems.push(toolTipData.location), toolTipData.series && toolTipItems.push(toolTipData.series), 
                                toolTipData.height.displayName && toolTipItems.push(toolTipData.height), toolTipData.heat.displayName && toolTipItems.push(toolTipData.heat), 
                                this.hoveredBar = object, visuals.TooltipManager.ToolTipInstance.show(toolTipItems, {
                                    x: this.mousePos.x,
                                    y: this.mousePos.y,
                                    width: 0,
                                    height: 0
                                });
                            } else this.hoveredBar = null, visuals.TooltipManager.ToolTipInstance.hide();
                        }
                    }, GlobeMap.prototype.animateCamera = function(to, done) {
                        var _this = this;
                        if (visuals.TooltipManager.ToolTipInstance.hide(), this.camera) {
                            cancelAnimationFrame(this.cameraAnimationFrameId);
                            var startTime = Date.now(), duration = GlobeMap.GlobeSettings.cameraAnimDuration, endTime = startTime + duration, startPos = this.camera.position.clone().normalize(), endPos = to.clone().normalize(), length = this.camera.position.length(), easeInOut = function(t) {
                                return t *= 2, t < 1 ? t * t * t / 2 : (t -= 2, (t * t * t + 2) / 2);
                            }, onUpdate = function() {
                                var now = Date.now(), t = (now - startTime) / duration;
                                t > 1 && (t = 1), t = easeInOut(t);
                                var pos = new THREE.Vector3().add(startPos.clone().multiplyScalar(1 - t)).add(endPos.clone().multiplyScalar(t)).normalize().multiplyScalar(length);
                                _this.camera.position.set(pos.x, pos.y, pos.z), now < endTime ? _this.cameraAnimationFrameId = requestAnimationFrame(onUpdate) : done && done(), 
                                _this.needsRender = !0;
                            };
                            this.cameraAnimationFrameId = requestAnimationFrame(onUpdate);
                        }
                    }, GlobeMap.prototype.destroy = function() {
                        if (cancelAnimationFrame(this.animationFrameId), cancelAnimationFrame(this.cameraAnimationFrameId), 
                        clearTimeout(this.deferredRenderTimerId), this.renderLoopEnabled = !1, this.scene = null, 
                        this.heatmap = null, this.heatTexture = null, this.camera = null, this.renderer) {
                            if (this.renderer.context) {
                                var extension = this.renderer.context.getExtension("WEBGL_lose_context");
                                extension && extension.loseContext(), this.renderer.context = null;
                            }
                            this.renderer.domElement = null;
                        }
                        this.renderer = null, this.data = null, this.barsGroup = null, this.orbitControls && this.orbitControls.dispose(), 
                        this.orbitControls = null, this.rendererCanvas && $(this.rendererCanvas).off("mousemove mouseup mousedown mousewheel DOMMouseScroll"), 
                        this.rendererCanvas = null, this.root && this.root.empty(), visuals.TooltipManager.ToolTipInstance.hide();
                    }, GlobeMap.prototype.initZoomControl = function() {
                        function onMouseDown(callback) {
                            d3.event.stopPropagation(), 0 === d3.event.button && callback();
                        }
                        var _this = this, radius = 17, zoomControlWidth = 8.5 * radius, zoomControlHeight = 8.5 * radius, startX = 3 * radius, startY = radius + 3, gap = 2 * radius;
                        this.zoomContainer = d3.select(this.root[0]).append("div").style({
                            position: "absolute",
                            bottom: "-5px",
                            "z-index": "1000",
                            "pointer-events": "none"
                        }), this.zoomControl = this.zoomContainer.append("svg").attr({
                            width: zoomControlWidth,
                            height: zoomControlHeight,
                            "pointer-events": "all"
                        });
                        var bottom = this.zoomControl.append("g").on("mousedown", function() {
                            return onMouseDown(function() {
                                return _this.rotateCam(0, -5);
                            });
                        });
                        bottom.append("circle").attr({
                            cx: startX + gap,
                            cy: startY + 2 * gap,
                            r: radius,
                            fill: "white",
                            opacity: .5,
                            stroke: "gray"
                        }), bottom.append("path").attr({
                            d: "M" + (startX + 2 * radius) + " " + (startY + 4.7 * radius) + " l12 -20 a40,70 0 0,1 -24,0z",
                            fill: "gray"
                        });
                        var left = this.zoomControl.append("g").on("mousedown", function() {
                            return onMouseDown(function() {
                                return _this.rotateCam(5, 0);
                            });
                        });
                        left.append("circle").attr({
                            cx: startX,
                            cy: startY + gap,
                            r: radius,
                            fill: "white",
                            stroke: "gray",
                            opacity: .5
                        }), left.append("path").attr({
                            d: "M" + (startX - radius / 1.5) + " " + (startY + 2 * radius) + " l20 -12 a70,40 0 0,0 0,24z",
                            fill: "gray"
                        });
                        var top = this.zoomControl.append("g").on("mousedown", function() {
                            return onMouseDown(function() {
                                return _this.rotateCam(0, 5);
                            });
                        });
                        top.append("circle").attr({
                            cx: startX + gap,
                            cy: startY,
                            r: radius,
                            fill: "white",
                            stroke: "gray",
                            opacity: .5
                        }), top.append("path").attr({
                            d: "M" + (startX + 2 * radius) + " " + (startY - radius / 1.5) + " l12 20 a40,70 0 0,0 -24,0z",
                            fill: "gray"
                        });
                        var right = this.zoomControl.append("g").on("mousedown", function() {
                            return onMouseDown(function() {
                                return _this.rotateCam(-5, 0);
                            });
                        });
                        right.append("circle").attr({
                            cx: startX + 2 * gap,
                            cy: startY + gap,
                            r: radius,
                            fill: "white",
                            stroke: "gray",
                            opacity: .5
                        }), right.append("path").attr({
                            d: "M" + (startX + 4.7 * radius) + " " + (startY + 2 * radius) + " l-20 -12 a70,40 0 0,1 0,24z",
                            fill: "gray"
                        });
                        var zoomIn = this.zoomControl.append("g").on("mousedown", function() {
                            return onMouseDown(function() {
                                return _this.zoomClicked(-1);
                            });
                        });
                        zoomIn.append("circle").attr({
                            cx: startX + 4 * radius,
                            cy: startY + 6 * radius,
                            r: radius,
                            fill: "white",
                            stroke: "gray",
                            opacity: .5
                        }), zoomIn.append("rect").attr({
                            x: startX + 3.5 * radius,
                            y: startY + 5.9 * radius,
                            width: radius,
                            height: radius / 3,
                            fill: "gray"
                        }), zoomIn.append("rect").attr({
                            x: startX + 4 * radius - radius / 6,
                            y: startY + 5.55 * radius,
                            width: radius / 3,
                            height: radius,
                            fill: "gray"
                        });
                        var zoomOut = this.zoomControl.append("g").on("mousedown", function() {
                            return onMouseDown(function() {
                                return _this.zoomClicked(1);
                            });
                        });
                        zoomOut.append("circle").attr({
                            cx: startX,
                            cy: startY + 6 * radius,
                            r: radius,
                            fill: "white",
                            stroke: "gray",
                            opacity: "0.50"
                        }), zoomOut.append("rect").attr({
                            x: startX - radius / 2,
                            y: startY + 5.9 * radius,
                            width: radius,
                            height: radius / 3,
                            fill: "gray"
                        });
                    }, GlobeMap.prototype.initMercartorSphere = function() {
                        if (!GlobeMap.MercartorSphere) {
                            var MercartorSphere = function(radius, widthSegments, heightSegments) {
                                function interplolate(a, b, t) {
                                    return (1 - t) * a + t * b;
                                }
                                function interpolateVertex(u, v, t) {
                                    var maxLng = 2 * Math.PI, maxLat = Math.PI, radius = this.radius, sphereX = -radius * Math.cos(u * maxLng) * Math.sin(v * maxLat), sphereY = -radius * Math.cos(v * maxLat), sphereZ = radius * Math.sin(u * maxLng) * Math.sin(v * maxLat), planeX = u * radius * 2 - radius, planeY = v * radius * 2 - radius, planeZ = 0, x = interplolate(sphereX, planeX, t), y = interplolate(sphereY, planeY, t), z = interplolate(sphereZ, planeZ, t);
                                    return new THREE.Vector3(x, y, z);
                                }
                                function interpolateUV(u, v, t) {
                                    var lat = 89.99 * (v - .5) * 2 / 180 * Math.PI, sin = Math.sin(lat), normalizedV = .5 + .25 * Math.log((1 + sin) / (1 - sin)) / Math.PI;
                                    return new THREE.Vector2(u, normalizedV);
                                }
                                THREE.Geometry.call(this), this.radius = radius, this.widthSegments = widthSegments, 
                                this.heightSegments = heightSegments, this.t = 0;
                                var x, y, vertices = [], uvs = [];
                                for (y = 0; y <= heightSegments; y++) {
                                    var verticesRow = [], uvsRow = [];
                                    for (x = 0; x <= widthSegments; x++) {
                                        var u = x / widthSegments, v = y / heightSegments;
                                        this.vertices.push(interpolateVertex.call(this, u, v, this.t)), uvsRow.push(interpolateUV.call(this, u, v, this.t)), 
                                        verticesRow.push(this.vertices.length - 1);
                                    }
                                    vertices.push(verticesRow), uvs.push(uvsRow);
                                }
                                for (y = 0; y < this.heightSegments; y++) for (x = 0; x < this.widthSegments; x++) {
                                    var v1 = vertices[y][x + 1], v2 = vertices[y][x], v3 = vertices[y + 1][x], v4 = vertices[y + 1][x + 1], n1 = this.vertices[v1].clone().normalize(), n2 = this.vertices[v2].clone().normalize(), n3 = this.vertices[v3].clone().normalize(), n4 = this.vertices[v4].clone().normalize(), uv1 = uvs[y][x + 1], uv2 = uvs[y][x], uv3 = uvs[y + 1][x], uv4 = uvs[y + 1][x + 1];
                                    this.faces.push(new THREE.Face3(v1, v2, v3, [ n1, n2, n3 ])), this.faces.push(new THREE.Face3(v1, v3, v4, [ n1, n3, n4 ])), 
                                    this.faceVertexUvs[0].push([ uv1.clone(), uv2.clone(), uv3.clone() ]), this.faceVertexUvs[0].push([ uv1.clone(), uv3.clone(), uv4.clone() ]);
                                }
                                this.computeFaceNormals(), this.computeVertexNormals(), this.computeBoundingSphere();
                            };
                            MercartorSphere.prototype = Object.create(THREE.Geometry.prototype), GlobeMap.MercartorSphere = MercartorSphere;
                        }
                    }, GlobeMap.prototype.getBingMapCanvas = function(resolution) {
                        function generateQuads(res, quad) {
                            res <= resolution && (res === resolution && loadTile(quad), generateQuads(res + 1, quad + "0"), 
                            generateQuads(res + 1, quad + "1"), generateQuads(res + 1, quad + "2"), generateQuads(res + 1, quad + "3"));
                        }
                        function loadTile(quad) {
                            var template = "https://t{server}.tiles.virtualearth.net/tiles/r{quad}.jpeg?g=0&mkt={language}", numServers = 7, server = Math.round(Math.random() * numServers), language = navigator.languages && navigator.languages.length ? navigator.languages[0] : navigator.language, url = template.replace("{server}", server).replace("{quad}", quad).replace("{language}", language), coords = getCoords(quad), tile = new Image();
                            tile.onload = function() {
                                tilesLoaded++, canvasContext.drawImage(tile, coords.x * tileSize, coords.y * tileSize, tileSize, tileSize), 
                                tilesLoaded === numTiles && canvas.trigger("ready", resolution);
                            }, tile.crossOrigin = "", tile.src = url;
                        }
                        function getCoords(quad) {
                            for (var x = 0, y = 0, last = quad.length - 1, i = last; i >= 0; i--) {
                                var chr = quad.charAt(i), pow = Math.pow(2, last - i);
                                "1" === chr ? x += pow : "2" === chr ? y += pow : "3" === chr && (x += pow, y += pow);
                            }
                            return {
                                x: x,
                                y: y
                            };
                        }
                        var tileSize = 256, numSegments = Math.pow(2, resolution), numTiles = numSegments * numSegments, tilesLoaded = 0, canvasSize = tileSize * numSegments, canvas = $("<canvas/>").attr({
                            width: canvasSize,
                            height: canvasSize
                        }), canvasElem = canvas.get(0), canvasContext = canvasElem.getContext("2d");
                        return generateQuads(0, ""), canvas;
                    }, GlobeMap.GlobeSettings = {
                        autoRotate: !1,
                        earthRadius: 30,
                        cameraRadius: 100,
                        earthSegments: 100,
                        heatmapSize: 1e3,
                        heatPointSize: 7,
                        heatIntensity: 10,
                        heatmapScaleOnZoom: .95,
                        barWidth: .3,
                        barHeight: 5,
                        rotateSpeed: .5,
                        zoomSpeed: .8,
                        cameraAnimDuration: 1e3,
                        clickInterval: 200
                    }, GlobeMap.capabilities = {
                        dataRoles: [ {
                            name: "Category",
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: "Location",
                            preferredTypes: [ {
                                geography: {
                                    address: !0
                                }
                            }, {
                                geography: {
                                    city: !0
                                }
                            }, {
                                geography: {
                                    continent: !0
                                }
                            }, {
                                geography: {
                                    country: !0
                                }
                            }, {
                                geography: {
                                    county: !0
                                }
                            }, {
                                geography: {
                                    place: !0
                                }
                            }, {
                                geography: {
                                    postalCode: !0
                                }
                            }, {
                                geography: {
                                    region: !0
                                }
                            }, {
                                geography: {
                                    stateOrProvince: !0
                                }
                            } ]
                        }, {
                            name: "Series",
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: "Legend"
                        }, {
                            name: "X",
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: "Longitude",
                            description: "Use to override the longitude of locations",
                            preferredTypes: [ {
                                geography: {
                                    longitude: !0
                                }
                            } ]
                        }, {
                            name: "Y",
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: "Latitude",
                            description: "Use to override the latitude of locations",
                            preferredTypes: [ {
                                geography: {
                                    latitude: !0
                                }
                            } ]
                        }, {
                            name: "Height",
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: "Bar Height"
                        }, {
                            name: "Heat",
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: "Heat Intensity"
                        } ],
                        objects: {
                            general: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_General"),
                                properties: {
                                    formatString: {
                                        type: {
                                            formatting: {
                                                formatString: !0
                                            }
                                        }
                                    }
                                }
                            },
                            dataPoint: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_DataPoint"),
                                properties: {
                                    defaultColor: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_DefaultColor"),
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    showAllDataPoints: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_DataPoint_Show_All"),
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    fill: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Fill"),
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    fillRule: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Gradient"),
                                        type: {
                                            fillRule: {}
                                        },
                                        rule: {
                                            inputRole: "Gradient",
                                            output: {
                                                property: "fill",
                                                selector: [ "Category" ]
                                            }
                                        }
                                    }
                                }
                            }
                        },
                        dataViewMappings: [ {
                            conditions: [ {
                                Category: {
                                    max: 1
                                },
                                Series: {
                                    max: 1
                                },
                                Height: {
                                    max: 1
                                },
                                Heat: {
                                    max: 1
                                }
                            } ],
                            categorical: {
                                categories: {
                                    for: {
                                        in: "Category"
                                    },
                                    dataReductionAlgorithm: {
                                        top: {}
                                    }
                                },
                                values: {
                                    group: {
                                        by: "Series",
                                        select: [ {
                                            bind: {
                                                to: "Height"
                                            }
                                        }, {
                                            bind: {
                                                to: "Heat"
                                            }
                                        }, {
                                            bind: {
                                                to: "X"
                                            }
                                        }, {
                                            bind: {
                                                to: "Y"
                                            }
                                        } ],
                                        dataReductionAlgorithm: {
                                            top: {}
                                        }
                                    }
                                },
                                rowCount: {
                                    preferred: {
                                        min: 2
                                    }
                                }
                            }
                        } ],
                        sorting: {
                            custom: {}
                        }
                    }, GlobeMap;
                }();
                samples.GlobeMap = GlobeMap;
            }(samples = visuals.samples || (visuals.samples = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, jsCommon = window.jsCommon, powerbi = window.powerbi;
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var samples;
            !function(samples) {
                var CreateClassAndSelector = jsCommon.CssConstants.createClassAndSelector, PixelConverter = jsCommon.PixelConverter, RadarChartWebBehavior = function() {
                    function RadarChartWebBehavior() {}
                    return RadarChartWebBehavior.prototype.bindEvents = function(options, selectionHandler) {
                        var selection = this.selection = options.selection, clearCatcher = options.clearCatcher;
                        this.interactivityService = options.interactivityService, this.hasHighlights = options.hasHighlights, 
                        selection.on("click", function(d) {
                            selectionHandler.handleSelection(d, d3.event.ctrlKey), d3.event.stopPropagation();
                        }), clearCatcher.on("click", function() {
                            selectionHandler.handleClearSelection();
                        });
                    }, RadarChartWebBehavior.prototype.renderSelection = function(hasSelection) {
                        var hasHighlights = this.hasHighlights;
                        this.selection.style("opacity", function(d) {
                            return radarChartUtils.getFillOpacity(d.selected, d.highlight, !d.highlight && hasSelection, !d.selected && hasHighlights);
                        });
                    }, RadarChartWebBehavior;
                }();
                samples.RadarChartWebBehavior = RadarChartWebBehavior;
                var RadarChart = function() {
                    function RadarChart(options) {
                        options && (options.svg && (this.svg = options.svg), options.animator && (this.animator = options.animator), 
                        options.margin && (this.margin = options.margin));
                    }
                    return RadarChart.converter = function(dataView, colors, interactivityService) {
                        if (!(dataView && dataView.categorical && dataView.categorical.categories && dataView.categorical.categories.length > 0 && dataView.categorical.categories[0] && dataView.categorical.values && dataView.categorical.values.length > 0 && colors)) return {
                            legendData: {
                                dataPoints: []
                            },
                            settings: {
                                showLegend: !0,
                                line: !0,
                                lineWidth: 4
                            },
                            series: [],
                            dataLabelsSettings: visuals.dataLabelUtils.getDefaultPointLabelSettings()
                        };
                        for (var catDv = dataView.categorical, values = catDv.values, grouped = catDv && catDv.values ? catDv.values.grouped() : null, series = [], colorHelper = new visuals.ColorHelper(colors, RadarChart.Properties.dataPoint.fill), hasHighlights = !!(values.length > 0 && values[0].highlights), legendData = {
                            fontSize: 8.25,
                            dataPoints: [],
                            title: ""
                        }, legendSettings = RadarChart.parseSettings(dataView), dataLabelsSettings = RadarChart.parseLabelSettings(dataView), i = 0, iLen = values.length; i < iLen; i++) {
                            var serieIdentity, queryName, displayName, color = colors.getColorByIndex(i).value, dataPoints = [], columnGroup = grouped && grouped.length > i && grouped[i].values ? grouped[i] : null;
                            if (values[i].source) {
                                var source = values[i].source;
                                if (source.queryName && (queryName = source.queryName, serieIdentity = visuals.SelectionId.createWithMeasure(queryName)), 
                                source.displayName && (displayName = source.displayName), source.objects) {
                                    var objects = source.objects;
                                    color = colorHelper.getColorForMeasure(objects, queryName);
                                }
                            }
                            legendData.dataPoints.push({
                                label: displayName,
                                color: color,
                                icon: visuals.LegendIcon.Box,
                                selected: !1,
                                identity: serieIdentity
                            });
                            for (var k = 0, kLen = values[i].values.length; k < kLen; k++) {
                                var dataPointIdentity = visuals.SelectionIdBuilder.builder().withMeasure(queryName).withCategory(catDv.categories[0], k).withSeries(dataView.categorical.values, columnGroup).createSelectionId(), tooltipInfo = visuals.TooltipBuilder.createTooltipInfo(RadarChart.formatStringProp, catDv, catDv.categories[0].values[k], values[i].values[k], null, null, i), labelFormatString = visuals.valueFormatter.getFormatString(catDv.values[i].source, RadarChart.formatStringProp), fontSizeInPx = jsCommon.PixelConverter.fromPoint(dataLabelsSettings.fontSize);
                                dataPoints.push({
                                    x: k,
                                    y: values[i].values[k],
                                    color: color,
                                    identity: dataPointIdentity,
                                    selected: !1,
                                    tooltipInfo: tooltipInfo,
                                    value: values[i].values[k],
                                    labelFormatString: labelFormatString,
                                    labelFontSize: fontSizeInPx,
                                    highlight: hasHighlights && !!values[0].highlights[k]
                                });
                            }
                            dataPoints.length > 0 && (interactivityService && !hasHighlights && interactivityService.applySelectionStateToData(dataPoints), 
                            series.push({
                                fill: color,
                                name: displayName,
                                dataPoints: dataPoints,
                                identity: serieIdentity,
                                hasHighlights: hasHighlights
                            }));
                        }
                        return {
                            legendData: legendData,
                            settings: legendSettings,
                            series: series,
                            dataLabelsSettings: dataLabelsSettings
                        };
                    }, RadarChart.prototype.init = function(options) {
                        var element = options.element;
                        this.svg || (this.svg = d3.select(element.get(0)).append("svg"), this.svg.style("position", "absolute")), 
                        this.margin || (this.margin = RadarChart.DefaultMargin), this.svg.classed(RadarChart.VisualClassName, !0), 
                        this.interactivityService = visuals.createInteractivityService(options.host), this.behavior = new RadarChartWebBehavior(), 
                        this.isInteractiveChart = options.interactivity && options.interactivity.isInteractiveLegend, 
                        this.legend = visuals.createLegend(element, this.isInteractiveChart, this.interactivityService, !0, visuals.LegendPosition.Top), 
                        this.colors = options.style.colorPalette.dataColors, this.mainGroupElement = this.svg.append("g"), 
                        this.segments = this.mainGroupElement.append("g").classed(RadarChart.Segments.class, !0), 
                        this.zeroSegment = this.mainGroupElement.append("g").classed(RadarChart.ZeroSegment.class, !0), 
                        this.axis = this.mainGroupElement.append("g").classed(RadarChart.Axis.class, !0), 
                        this.chart = this.mainGroupElement.append("g").classed(RadarChart.Chart.class, !0);
                    }, RadarChart.prototype.update = function(options) {
                        if (options.dataViews && options.dataViews[0]) {
                            var dataView = options.dataViews[0];
                            this.radarChartData = RadarChart.converter(dataView, this.colors, this.interactivityService);
                            var dataViewMetadataColumn, categories = [], series = this.radarChartData.series, duration = visuals.AnimatorCommon.GetAnimationDuration(this.animator, options.suppressAnimations);
                            dataView.categorical && dataView.categorical.categories && dataView.categorical.categories[0] && dataView.categorical.categories[0].values && (categories = dataView.categorical.categories[0].values), 
                            dataView.metadata && dataView.metadata.columns && dataView.metadata.columns.length > 0 && (dataViewMetadataColumn = dataView.metadata.columns[0]), 
                            this.viewport = {
                                height: options.viewport.height > 0 ? options.viewport.height : 0,
                                width: options.viewport.width > 0 ? options.viewport.width : 0
                            }, this.parseLegendProperties(dataView), this.parseLineWidth(), this.renderLegend(this.radarChartData), 
                            this.updateViewport(), this.svg.attr({
                                height: this.viewport.height,
                                width: this.viewport.width
                            });
                            var mainGroup = this.mainGroupElement;
                            mainGroup.attr("transform", visuals.SVGUtil.translate(this.viewport.width / 2, this.viewport.height / 2));
                            var width = this.viewport.width - this.margin.left - this.margin.right, height = this.viewport.height - this.margin.top - this.margin.bottom;
                            this.angle = RadarChart.Radians / categories.length, this.radius = RadarChart.SegmentFactor * RadarChart.Scale * Math.min(width, height) / 2, 
                            this.drawCircularSegments(categories), this.drawAxes(categories), this.drawAxesLabels(categories, dataViewMetadataColumn), 
                            this.drawChart(series, duration), this.drawDataLabels(series), this.drawZeroCircularSegment(categories), 
                            0 !== this.zeroPointRadius ? this.drawZeroLabel() : this.mainGroupElement.selectAll(RadarChart.ZeroLabel.selector).remove();
                        }
                    }, RadarChart.prototype.getRadarChartLabelLayout = function(labelSettings, allDataPoints) {
                        var formattersCache = visuals.dataLabelUtils.createColumnFormatterCacheManager(), angle = this.angle, viewport = this.viewport, halfHeight = this.viewport.height / 2, halfWidth = this.viewport.width / 2, y = this.calculateChartDomain(this.radarChartData.series);
                        return {
                            labelText: function(d) {
                                var formatter = formattersCache.getOrCreate(d.labelFormatString, labelSettings);
                                if (0 === labelSettings.displayUnits) {
                                    var maxDataPoint = _.max(allDataPoints, function(d) {
                                        return d.value;
                                    }), maxValue = maxDataPoint.value > 0 ? maxDataPoint.value : 0;
                                    formatter = formattersCache.getOrCreate(d.labelFormatString, labelSettings, maxValue);
                                }
                                return visuals.dataLabelUtils.getLabelFormattedText({
                                    label: formatter.format(d.value),
                                    maxWidth: viewport.width,
                                    fontSize: labelSettings.fontSize
                                });
                            },
                            labelLayout: {
                                x: function(d) {
                                    return -1 * y(d.y) * Math.sin(d.x * angle) + halfWidth;
                                },
                                y: function(d) {
                                    return -1 * y(d.y) * Math.cos(d.x * angle) + halfHeight - 7;
                                }
                            },
                            filter: function(d) {
                                return null != d && null != d.value;
                            },
                            style: {
                                fill: labelSettings.labelColor,
                                "font-size": function(d) {
                                    return PixelConverter.fromPoint(labelSettings.fontSize);
                                }
                            }
                        };
                    }, RadarChart.prototype.drawCircularSegments = function(values) {
                        for (var data = [], angle = this.angle, factor = RadarChart.SegmentFactor, levels = RadarChart.SegmentLevels, radius = this.radius, level = 0; level < levels; level++) for (var levelFactor = radius * ((level + 1) / levels), transform = -1 * levelFactor, i = 0; i < values.length; i++) data.push({
                            x1: levelFactor * (1 - factor * Math.sin(i * angle)),
                            y1: levelFactor * (1 - factor * Math.cos(i * angle)),
                            x2: levelFactor * (1 - factor * Math.sin((i + 1) * angle)),
                            y2: levelFactor * (1 - factor * Math.cos((i + 1) * angle)),
                            translate: visuals.SVGUtil.translate(transform, transform)
                        });
                        var selection = this.mainGroupElement.select(RadarChart.Segments.selector).selectAll(RadarChart.SegmentNode.selector).data(data);
                        selection.enter().append("svg:line").classed(RadarChart.SegmentNode.class, !0), 
                        selection.attr({
                            x1: function(item) {
                                return item.x1;
                            },
                            y1: function(item) {
                                return item.y1;
                            },
                            x2: function(item) {
                                return item.x2;
                            },
                            y2: function(item) {
                                return item.y2;
                            },
                            transform: function(item) {
                                return item.translate;
                            }
                        }), selection.exit().remove();
                    }, RadarChart.prototype.drawDataLabels = function(series) {
                        var allDataPoints = this.getAllDataPointsList(series);
                        if (this.radarChartData.dataLabelsSettings.show) {
                            var layout = this.getRadarChartLabelLayout(this.radarChartData.dataLabelsSettings, allDataPoints), viewport = this.viewport, labels = visuals.dataLabelUtils.drawDefaultLabelsForDataPointChart(allDataPoints, this.mainGroupElement, layout, viewport);
                            labels.attr("transform", visuals.SVGUtil.translate(-(viewport.width / 2), -(viewport.height / 2)));
                        } else visuals.dataLabelUtils.cleanDataLabels(this.mainGroupElement);
                    }, RadarChart.prototype.drawAxes = function(values) {
                        var angle = this.angle, radius = -1 * this.radius, selection = this.mainGroupElement.select(RadarChart.Axis.selector).selectAll(RadarChart.AxisNode.selector), axis = selection.data(values);
                        axis.enter().append("svg:line"), axis.attr({
                            x1: 0,
                            y1: 0,
                            x2: function(name, i) {
                                return radius * Math.sin(i * angle);
                            },
                            y2: function(name, i) {
                                return radius * Math.cos(i * angle);
                            }
                        }).classed(RadarChart.AxisNode.class, !0), axis.exit().remove();
                    }, RadarChart.prototype.drawAxesLabels = function(values, dataViewMetadataColumn) {
                        var _this = this, angle = this.angle, radius = -1 * this.radius, length = values.length, formatter = visuals.valueFormatter.create({
                            format: visuals.valueFormatter.getFormatString(dataViewMetadataColumn, RadarChart.formatStringProp, !0),
                            value: values[0],
                            value2: values[length - 1]
                        }), selection = this.mainGroupElement.select(RadarChart.Axis.selector).selectAll(RadarChart.AxisLabel.selector), labels = selection.data(values);
                        labels.enter().append("svg:text"), labels.attr("text-anchor", function(name, i) {
                            return i * angle > Math.PI ? "start" : "end";
                        }).attr("dy", "1.5em").attr("transform", function(name, i) {
                            var angleInDegrees = i * angle * 180 / Math.PI, labelAngle = 90 - angleInDegrees;
                            labelAngle < -90 ? (labelAngle += 180, angleInDegrees += 2.5) : angleInDegrees -= 3;
                            var angleInRadian = angleInDegrees / 180 * Math.PI, x = (radius - 8) * Math.sin(angleInRadian), y = (radius - 7) * Math.cos(angleInRadian);
                            return visuals.SVGUtil.translate(x, y) + " rotate(" + labelAngle + ") ";
                        }).text(function(item) {
                            var properties = {
                                fontFamily: RadarChart.AxesLabelsFontFamily,
                                fontSize: RadarChart.AxesLabelsfontSize,
                                text: formatter.format(item)
                            };
                            return powerbi.TextMeasurementService.getTailoredTextOrDefault(properties, Math.min(RadarChart.AxesLabelsMaxWidth, _this.viewport.width));
                        }).classed(RadarChart.AxisLabel.class, !0), labels.exit().remove();
                    }, RadarChart.prototype.drawChart = function(series, duration) {
                        var angle = this.angle, dotRadius = 5, dataPoints = this.getDataPoints(series), stack = d3.layout.stack(), layers = stack(dataPoints), y = this.calculateChartDomain(series), calculatePoints = function(points) {
                            return points.map(function(value) {
                                var x1 = -1 * y(value.y) * Math.sin(value.x * angle), y1 = -1 * y(value.y) * Math.cos(value.x * angle);
                                return x1 + "," + y1;
                            }).join(" ");
                        }, areas = this.chart.selectAll(RadarChart.ChartArea.selector).data(layers);
                        areas.enter().append("g").classed(RadarChart.ChartArea.class, !0);
                        var polygon = areas.selectAll(RadarChart.ChartPolygon.selector).data(function(d) {
                            return d && d.length > 0 ? [ d ] : [];
                        });
                        polygon.enter().append("polygon").classed(RadarChart.ChartPolygon.class, !0);
                        var settings = this.radarChartData.settings;
                        settings.line ? polygon.style("fill", "none").style("stroke", function(d) {
                            return d[0].color;
                        }).style("stroke-width", settings.lineWidth) : polygon.style("fill", function(d) {
                            return d[0].color;
                        }).style("stroke-width", 0), polygon.style("opacity", RadarChart.DimmedAreaFillOpacity).on("mouseover", function(d) {
                            d3.select(this).transition().duration(duration).style("opacity", RadarChart.AreaFillOpacity);
                        }).on("mouseout", function(d) {
                            d3.select(this).transition().duration(duration).style("opacity", RadarChart.DimmedAreaFillOpacity);
                        }).attr("points", calculatePoints), polygon.exit().remove(), areas.exit().remove();
                        var selection = this.chart.selectAll(RadarChart.ChartNode.selector).data(layers);
                        selection.enter().append("g").classed(RadarChart.ChartNode.class, !0);
                        var hasHighlights = series.length > 0 && series[0].hasHighlights, hasSelection = this.interactivityService && this.interactivityService.hasSelection(), dots = selection.selectAll(RadarChart.ChartDot.selector).data(function(d) {
                            return d.filter(function(d) {
                                return null != d.y;
                            });
                        });
                        dots.enter().append("svg:circle").classed(RadarChart.ChartDot.class, !0), dots.attr("r", dotRadius).attr({
                            cx: function(value) {
                                return -1 * y(value.y) * Math.sin(value.x * angle);
                            },
                            cy: function(value) {
                                return -1 * y(value.y) * Math.cos(value.x * angle);
                            }
                        }).style("fill", function(d) {
                            return d.color;
                        }).style("opacity", function(d) {
                            return radarChartUtils.getFillOpacity(d.selected, d.highlight, !d.highlight && hasSelection, !d.selected && hasHighlights);
                        }), dots.exit().remove(), visuals.TooltipManager.addTooltip(dots, function(tooltipEvent) {
                            return tooltipEvent.data.tooltipInfo;
                        }, !0), selection.exit().remove();
                        var behaviorOptions = void 0;
                        if (this.interactivityService) {
                            var dataPointsToBind = this.getAllDataPointsList(series);
                            behaviorOptions = {
                                selection: dots,
                                clearCatcher: this.svg,
                                interactivityService: this.interactivityService,
                                hasHighlights: hasHighlights
                            }, this.interactivityService.bind(dataPointsToBind, this.behavior, behaviorOptions);
                        }
                    }, RadarChart.prototype.onClearSelection = function() {
                        this.interactivityService && this.interactivityService.clearSelection();
                    }, RadarChart.prototype.calculateChartDomain = function(series) {
                        var radius = this.radius * RadarChart.SegmentFactor, dataPointsList = this.getAllDataPointsList(series), minValue = d3.min(dataPointsList, function(d) {
                            return d.y;
                        }), maxValue = d3.max(dataPointsList, function(d) {
                            return d.y;
                        });
                        this.isPercentChart(dataPointsList) && (minValue = minValue >= 0 ? 0 : -1, maxValue = maxValue <= 0 ? 0 : 1);
                        var y = d3.scale.linear().domain([ minValue, maxValue ]).range([ 0, radius ]);
                        return this.zeroPointRadius = minValue < 0 && maxValue > 0 ? y(0) : 0, y;
                    }, RadarChart.prototype.renderLegend = function(radarChartData) {
                        if (radarChartData.legendData) {
                            var legendData = radarChartData.legendData;
                            if (this.legendObjectProperties) {
                                visuals.LegendData.update(legendData, this.legendObjectProperties);
                                var position = this.legendObjectProperties[visuals.legendProps.position];
                                position && this.legend.changeOrientation(visuals.LegendPosition[position]);
                            } else this.legend.changeOrientation(visuals.LegendPosition.Top);
                            var viewport = this.viewport;
                            this.legend.drawLegend(legendData, {
                                height: viewport.height,
                                width: viewport.width
                            }), visuals.Legend.positionChartArea(this.svg, this.legend);
                        }
                    }, RadarChart.prototype.drawZeroCircularSegment = function(values) {
                        for (var data = [], angle = this.angle, factor = RadarChart.SegmentFactor, radius = this.zeroPointRadius, transform = -1 * radius, i = 0; i < values.length; i++) data.push({
                            x1: radius * (1 - factor * Math.sin(i * angle)),
                            y1: radius * (1 - factor * Math.cos(i * angle)),
                            x2: radius * (1 - factor * Math.sin((i + 1) * angle)),
                            y2: radius * (1 - factor * Math.cos((i + 1) * angle)),
                            translate: visuals.SVGUtil.translate(transform, transform)
                        });
                        var selection = this.mainGroupElement.select(RadarChart.ZeroSegment.selector).selectAll(RadarChart.ZeroSegmentNode.selector).data(data);
                        selection.enter().append("svg:line").classed(RadarChart.ZeroSegmentNode.class, !0), 
                        selection.attr({
                            x1: function(item) {
                                return item.x1;
                            },
                            y1: function(item) {
                                return item.y1;
                            },
                            x2: function(item) {
                                return item.x2;
                            },
                            y2: function(item) {
                                return item.y2;
                            },
                            transform: function(item) {
                                return item.translate;
                            }
                        }), selection.exit().remove();
                    }, RadarChart.prototype.drawZeroLabel = function() {
                        var data = [];
                        data.push({
                            x: this.zeroPointRadius * (1 - RadarChart.SegmentFactor) + 5,
                            y: -1 * this.zeroPointRadius
                        });
                        var zeroLabel = this.mainGroupElement.select(RadarChart.ZeroSegment.selector).selectAll(RadarChart.ZeroLabel.selector).data(data);
                        zeroLabel.enter().append("text").classed(RadarChart.ZeroLabel.class, !0).text("0"), 
                        zeroLabel.attr({
                            x: function(item) {
                                return item.x;
                            },
                            y: function(item) {
                                return item.y;
                            }
                        });
                    }, RadarChart.prototype.getDataPoints = function(series) {
                        for (var dataPoints = [], i = 0; i < series.length; i++) dataPoints.push(series[i].dataPoints);
                        return dataPoints;
                    }, RadarChart.prototype.getAllDataPointsList = function(series) {
                        for (var dataPoints = [], i = 0; i < series.length; i++) dataPoints = dataPoints.concat(series[i].dataPoints);
                        return dataPoints;
                    }, RadarChart.prototype.isPercentChart = function(dataPointsList) {
                        for (var i = 0; i < dataPointsList.length; i++) if (dataPointsList[i].labelFormatString.indexOf("%") === -1) return !1;
                        return !0;
                    }, RadarChart.prototype.parseLegendProperties = function(dataView) {
                        return dataView && dataView.metadata ? void (this.legendObjectProperties = powerbi.DataViewObjects.getObject(dataView.metadata.objects, "legend", {})) : void (this.legendObjectProperties = {});
                    }, RadarChart.parseSettings = function(dataView) {
                        var objects;
                        return objects = dataView && dataView.metadata && dataView.metadata.columns && dataView.metadata.objects ? dataView.metadata.objects : null, 
                        {
                            showLegend: powerbi.DataViewObjects.getValue(objects, RadarChart.Properties.legend.show, !0),
                            line: powerbi.DataViewObjects.getValue(objects, RadarChart.Properties.line.show, !1),
                            lineWidth: powerbi.DataViewObjects.getValue(objects, RadarChart.Properties.line.lineWidth, RadarChart.DefaultLineWidth)
                        };
                    }, RadarChart.getPrecision = function(value) {
                        return Math.max(RadarChart.MinPrecision, Math.min(RadarChart.MaxPrecision, value));
                    }, RadarChart.parseLabelSettings = function(dataView) {
                        var objects;
                        objects = dataView && dataView.metadata && dataView.metadata.objects ? dataView.metadata.objects : null;
                        var dataLabelsSettings = visuals.dataLabelUtils.getDefaultPointLabelSettings(), labelsObj = {
                            show: powerbi.DataViewObjects.getValue(objects, RadarChart.Properties.labels.show, dataLabelsSettings.show),
                            labelColor: powerbi.DataViewObjects.getFillColor(objects, RadarChart.Properties.labels.color, dataLabelsSettings.labelColor),
                            displayUnits: powerbi.DataViewObjects.getValue(objects, RadarChart.Properties.labels.displayUnits, dataLabelsSettings.displayUnits),
                            precision: RadarChart.getPrecision(powerbi.DataViewObjects.getValue(objects, RadarChart.Properties.labels.precision, dataLabelsSettings.precision)),
                            fontSize: powerbi.DataViewObjects.getValue(objects, RadarChart.Properties.labels.fontSize, dataLabelsSettings.fontSize),
                            position: dataLabelsSettings.position
                        };
                        return labelsObj;
                    }, RadarChart.prototype.enumerateObjectInstances = function(options) {
                        var settings, enumeration = new visuals.ObjectEnumerationBuilder();
                        if (!this.radarChartData || !this.radarChartData.settings) return [];
                        switch (settings = this.radarChartData.settings, options.objectName) {
                          case "legend":
                            enumeration.pushInstance(this.enumerateLegend(settings));
                            break;

                          case "dataPoint":
                            this.enumerateDataPoint(enumeration);
                            break;

                          case "line":
                            enumeration.pushInstance(this.enumerateLine(settings));
                            break;

                          case "labels":
                            this.enumerateDataLabels(enumeration);
                        }
                        return enumeration.complete();
                    }, RadarChart.prototype.getLabelSettingsOptions = function(enumeration, labelSettings) {
                        return {
                            enumeration: enumeration,
                            dataLabelsSettings: labelSettings,
                            show: !0,
                            displayUnits: !0,
                            precision: !0,
                            fontSize: !0
                        };
                    }, RadarChart.prototype.enumerateDataLabels = function(enumeration) {
                        var labelSettings = this.radarChartData.dataLabelsSettings;
                        visuals.dataLabelUtils.enumerateDataLabels(this.getLabelSettingsOptions(enumeration, labelSettings));
                    }, RadarChart.prototype.enumerateLegend = function(settings) {
                        var legend, labelColor, position, showTitle = !0, titleText = "", fontSize = 8;
                        return showTitle = powerbi.DataViewObject.getValue(this.legendObjectProperties, visuals.legendProps.showTitle, showTitle), 
                        titleText = powerbi.DataViewObject.getValue(this.legendObjectProperties, visuals.legendProps.titleText, titleText), 
                        labelColor = powerbi.DataViewObject.getValue(this.legendObjectProperties, visuals.legendProps.labelColor, labelColor), 
                        fontSize = powerbi.DataViewObject.getValue(this.legendObjectProperties, visuals.legendProps.fontSize, fontSize), 
                        position = powerbi.DataViewObject.getValue(this.legendObjectProperties, visuals.legendProps.position, visuals.legendPosition.top), 
                        legend = {
                            objectName: "legend",
                            displayName: "legend",
                            selector: null,
                            properties: {
                                show: settings.showLegend,
                                position: position,
                                showTitle: showTitle,
                                titleText: titleText,
                                labelColor: labelColor,
                                fontSize: fontSize
                            }
                        };
                    }, RadarChart.prototype.enumerateLine = function(settings) {
                        return {
                            objectName: RadarChart.Properties.line.show.objectName,
                            displayName: "Draw Lines",
                            selector: null,
                            properties: {
                                show: settings.line,
                                lineWidth: settings.lineWidth
                            }
                        };
                    }, RadarChart.prototype.enumerateDataPoint = function(enumeration) {
                        if (this.radarChartData && this.radarChartData.series) for (var series = this.radarChartData.series, i = 0; i < series.length; i++) {
                            var serie = series[i];
                            enumeration.pushInstance({
                                objectName: "dataPoint",
                                displayName: serie.name,
                                selector: visuals.ColorHelper.normalizeSelector(serie.identity.getSelector(), !1),
                                properties: {
                                    fill: {
                                        solid: {
                                            color: serie.fill
                                        }
                                    }
                                }
                            });
                        }
                    }, RadarChart.prototype.updateViewport = function() {
                        var legendPosition, legendMargins = this.legend.getMargins();
                        switch (legendPosition = visuals.LegendPosition[this.legendObjectProperties[visuals.legendProps.position]]) {
                          case visuals.LegendPosition.Top:
                          case visuals.LegendPosition.TopCenter:
                          case visuals.LegendPosition.Bottom:
                          case visuals.LegendPosition.BottomCenter:
                            this.viewport.height = Math.max(this.viewport.height - legendMargins.height, 0);
                            break;

                          case visuals.LegendPosition.Left:
                          case visuals.LegendPosition.LeftCenter:
                          case visuals.LegendPosition.Right:
                          case visuals.LegendPosition.RightCenter:
                            this.viewport.width = Math.max(this.viewport.width - legendMargins.width, 0);
                        }
                    }, RadarChart.prototype.parseLineWidth = function() {
                        var settings = this.radarChartData.settings;
                        settings.lineWidth = Math.max(RadarChart.MinLineWidth, Math.min(RadarChart.MaxLineWidth, settings.lineWidth));
                    }, RadarChart.capabilities = {
                        dataRoles: [ {
                            displayName: "Category",
                            name: "Category",
                            kind: powerbi.VisualDataRoleKind.Grouping
                        }, {
                            displayName: "Y Axis",
                            name: "Y",
                            kind: powerbi.VisualDataRoleKind.Measure
                        } ],
                        dataViewMappings: [ {
                            conditions: [ {
                                Category: {
                                    min: 1,
                                    max: 1
                                }
                            } ],
                            categorical: {
                                categories: {
                                    for: {
                                        in: "Category"
                                    },
                                    dataReductionAlgorithm: {
                                        top: {}
                                    }
                                },
                                values: {
                                    group: {
                                        by: "Series",
                                        select: [ {
                                            bind: {
                                                to: "Y"
                                            }
                                        } ],
                                        dataReductionAlgorithm: {
                                            top: {}
                                        }
                                    }
                                },
                                rowCount: {
                                    preferred: {
                                        min: 2
                                    },
                                    supported: {
                                        min: 1
                                    }
                                }
                            }
                        } ],
                        supportsHighlight: !0,
                        objects: {
                            general: {
                                displayName: "General",
                                properties: {
                                    formatString: {
                                        type: {
                                            formatting: {
                                                formatString: !0
                                            }
                                        }
                                    }
                                }
                            },
                            legend: {
                                displayName: "Legend",
                                description: "Display Legend Options",
                                properties: {
                                    show: {
                                        displayName: "Show",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    position: {
                                        displayName: "Position",
                                        description: "Select the location for the legend",
                                        type: {
                                            enumeration: visuals.legendPosition.type
                                        }
                                    },
                                    showTitle: {
                                        displayName: "Title",
                                        description: "Display a title for legend symbols",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    titleText: {
                                        displayName: "Name",
                                        description: "Title Text",
                                        type: {
                                            text: !0
                                        },
                                        suppressFormatPainterCopy: !0
                                    },
                                    labelColor: {
                                        displayName: "Color",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    fontSize: {
                                        displayName: "Text Size",
                                        type: {
                                            formatting: {
                                                fontSize: !0
                                            }
                                        }
                                    }
                                }
                            },
                            dataPoint: {
                                displayName: "Data colors",
                                description: "Display data color options",
                                properties: {
                                    fill: {
                                        displayName: "Fill",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    }
                                }
                            },
                            line: {
                                displayName: "Draw Lines",
                                properties: {
                                    show: {
                                        displayName: "Draw Lines",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    lineWidth: {
                                        displayName: "Line Width",
                                        type: {
                                            numeric: !0
                                        }
                                    }
                                }
                            },
                            labels: {
                                displayName: "Data Labels",
                                description: "Display data label options",
                                properties: {
                                    show: {
                                        displayName: "Show",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    color: {
                                        displayName: "Color",
                                        description: "Select color for data labels",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    labelDisplayUnits: {
                                        displayName: "Display Units",
                                        description: "Select the units (millions, billions, etc.)",
                                        type: {
                                            formatting: {
                                                labelDisplayUnits: !0
                                            }
                                        },
                                        suppressFormatPainterCopy: !0
                                    },
                                    labelPrecision: {
                                        displayName: "Decimal Places",
                                        description: "Select the number of decimal places to display",
                                        placeHolderText: "Auto",
                                        type: {
                                            numeric: !0
                                        },
                                        suppressFormatPainterCopy: !0
                                    },
                                    fontSize: {
                                        displayName: "Text Size",
                                        type: {
                                            formatting: {
                                                fontSize: !0
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }, RadarChart.formatStringProp = {
                        objectName: "general",
                        propertyName: "formatString"
                    }, RadarChart.Properties = {
                        legend: {
                            show: {
                                objectName: "legend",
                                propertyName: "show"
                            }
                        },
                        line: {
                            show: {
                                objectName: "line",
                                propertyName: "show"
                            },
                            lineWidth: {
                                objectName: "line",
                                propertyName: "lineWidth"
                            }
                        },
                        dataPoint: {
                            fill: {
                                objectName: "dataPoint",
                                propertyName: "fill"
                            }
                        },
                        labels: {
                            show: {
                                objectName: "labels",
                                propertyName: "show"
                            },
                            color: {
                                objectName: "labels",
                                propertyName: "color"
                            },
                            displayUnits: {
                                objectName: "labels",
                                propertyName: "labelDisplayUnits"
                            },
                            precision: {
                                objectName: "labels",
                                propertyName: "labelPrecision"
                            },
                            fontSize: {
                                objectName: "labels",
                                propertyName: "fontSize"
                            }
                        }
                    }, RadarChart.VisualClassName = "radarChart", RadarChart.Segments = CreateClassAndSelector("segments"), 
                    RadarChart.SegmentNode = CreateClassAndSelector("segmentNode"), RadarChart.ZeroSegment = CreateClassAndSelector("zeroSegment"), 
                    RadarChart.ZeroSegmentNode = CreateClassAndSelector("zeroSegmentNode"), RadarChart.ZeroLabel = CreateClassAndSelector("zeroLabel"), 
                    RadarChart.Axis = CreateClassAndSelector("axis"), RadarChart.AxisNode = CreateClassAndSelector("axisNode"), 
                    RadarChart.AxisLabel = CreateClassAndSelector("axisLabel"), RadarChart.Chart = CreateClassAndSelector("chart"), 
                    RadarChart.ChartNode = CreateClassAndSelector("chartNode"), RadarChart.ChartArea = CreateClassAndSelector("chartArea"), 
                    RadarChart.ChartPolygon = CreateClassAndSelector("chartPolygon"), RadarChart.ChartDot = CreateClassAndSelector("chartDot"), 
                    RadarChart.MaxPrecision = 17, RadarChart.MinPrecision = 0, RadarChart.MaxLineWidth = 10, 
                    RadarChart.MinLineWidth = 1, RadarChart.DefaultLineWidth = 5, RadarChart.DefaultMargin = {
                        top: 50,
                        bottom: 50,
                        right: 100,
                        left: 100
                    }, RadarChart.SegmentLevels = 5, RadarChart.SegmentFactor = .9, RadarChart.Radians = 2 * Math.PI, 
                    RadarChart.Scale = 1, RadarChart.NodeFillOpacity = 1, RadarChart.AreaFillOpacity = .6, 
                    RadarChart.DimmedAreaFillOpacity = .4, RadarChart.AxesLabelsFontFamily = "sans-serif", 
                    RadarChart.AxesLabelsfontSize = "11px", RadarChart.AxesLabelsMaxWidth = 200, RadarChart;
                }();
                samples.RadarChart = RadarChart;
                var radarChartUtils;
                !function(radarChartUtils) {
                    function getFillOpacity(selected, highlight, hasSelection, hasPartialHighlights) {
                        return hasPartialHighlights && !highlight || hasSelection && !selected ? radarChartUtils.DimmedOpacity : radarChartUtils.DefaultOpacity;
                    }
                    radarChartUtils.DimmedOpacity = .4, radarChartUtils.DefaultOpacity = 1, radarChartUtils.getFillOpacity = getFillOpacity;
                }(radarChartUtils = samples.radarChartUtils || (samples.radarChartUtils = {}));
            }(samples = visuals.samples || (visuals.samples = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, jsCommon = window.jsCommon, powerbi = window.powerbi;
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var samples;
            !function(samples) {
                var PixelConverter = jsCommon.PixelConverter, createClassAndSelector = jsCommon.CssConstants.createClassAndSelector, VisualDataRoleKind = powerbi.VisualDataRoleKind, ValueType = powerbi.ValueType, DateTimeSequence = powerbi.DateTimeSequence, DataViewObjects = powerbi.DataViewObjects, TextMeasurementService = powerbi.TextMeasurementService, ValueFormatter = powerbi.visuals.valueFormatter, SelectionId = powerbi.visuals.SelectionId, axisStyle = powerbi.visuals.axisStyle, yAxisPosition = powerbi.visuals.yAxisPosition, DataColorPalette = powerbi.visuals.DataColorPalette, ColorHelper = powerbi.visuals.ColorHelper, SVGUtil = powerbi.visuals.SVGUtil, TooltipManager = powerbi.visuals.TooltipManager, dataLabelUtils = powerbi.visuals.dataLabelUtils, willLabelsFit = powerbi.visuals.AxisHelper.LabelLayoutStrategy.willLabelsFit, willLabelsWordBreak = powerbi.visuals.AxisHelper.LabelLayoutStrategy.willLabelsWordBreak, axisScale = powerbi.visuals.axisScale, valueFormatter = powerbi.visuals.valueFormatter, ObjectEnumerationBuilder = powerbi.visuals.ObjectEnumerationBuilder, appendClearCatcher = powerbi.visuals.appendClearCatcher, createInteractivityService = powerbi.visuals.createInteractivityService, HistogramChartWarning = function() {
                    function HistogramChartWarning(message) {
                        this.message = message;
                    }
                    return Object.defineProperty(HistogramChartWarning.prototype, "code", {
                        get: function() {
                            return "HistogramChartWarning";
                        },
                        enumerable: !0,
                        configurable: !0
                    }), HistogramChartWarning.prototype.getMessages = function(resourceProvider) {
                        return {
                            message: this.message,
                            title: resourceProvider.get(""),
                            detail: resourceProvider.get("")
                        };
                    }, HistogramChartWarning.ErrorInvalidDataValues = "Some data values are invalid or too big", 
                    HistogramChartWarning;
                }();
                samples.HistogramChartWarning = HistogramChartWarning;
                var Histogram = function() {
                    function Histogram(constructorOptions) {
                        this.widthOfColumn = 0, this.yTitleMargin = 0, this.outerPadding = 0, constructorOptions && (this.svg = constructorOptions.svg, 
                        this.animator = constructorOptions.animator, this.margin = constructorOptions.margin, 
                        this.behavior = constructorOptions.behavior), this.svg = this.svg || void 0, this.animator = this.animator || void 0, 
                        this.margin = this.margin || Histogram.DefaultMargin, this.behavior = this.behavior || HistogramBehavior.create();
                    }
                    return Object.defineProperty(Histogram.prototype, "columnsSelection", {
                        get: function() {
                            return this.main.select(Histogram.Columns.selector).selectAll(Histogram.Column.selector);
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Histogram.prototype.init = function(visualsOptions) {
                        this.hostService = visualsOptions.host, this.interactivityService = createInteractivityService(this.hostService), 
                        this.svg ? this.root = this.svg : this.root = d3.select(visualsOptions.element.get(0)).append("svg");
                        var style = visualsOptions.style;
                        this.colors = style && style.colorPalette ? style.colorPalette.dataColors : new DataColorPalette(), 
                        this.clearCatcher = appendClearCatcher(this.root), this.root.classed(Histogram.ClassName, !0), 
                        this.main = this.root.append("g"), this.columns = this.main.append("g").classed(Histogram.Columns.class, !0), 
                        this.axes = this.main.append("g").classed(Histogram.Axes.class, !0), this.axisX = this.axes.append("g").classed(Histogram.Axis.class, !0).classed(Histogram.XAxis.class, !0), 
                        this.axisY = this.axes.append("g").classed(Histogram.Axis.class, !0).classed(Histogram.YAxis.class, !0), 
                        this.legend = this.main.append("g").classed(Histogram.Legends.class, !0), this.labelGraphicsContext = this.main.append("g").classed(Histogram.LabelGraphicsContext.class, !0);
                    }, Histogram.converter = function(dataView, colors) {
                        if (!(dataView && dataView.categorical && dataView.categorical.categories && dataView.categorical.categories[0] && dataView.categorical.categories[0].values && dataView.categorical.categories[0].values.length > 0 && colors)) return null;
                        var settings, histogramLayout, values, bins, dataPoints, valueFormatter, xLabelFormatter, yLabelFormatter, xLegendSize, yLegendSize, borderValues, yAxisSettings, numericalValues = [], frequencies = [], identities = [], shiftByValues = 0, sumFrequency = 0, sourceValues = dataView.categorical.categories[0].values;
                        if (settings = Histogram.parseSettings(dataView, colors), !settings || !Histogram.areValuesNumbers(dataView.categorical.categories[0]) || sourceValues.length < Histogram.MinAmountOfValues) return null;
                        xLegendSize = Histogram.getLegendSize(settings.xAxisSettings), yLegendSize = Histogram.getLegendSize(settings.yAxisSettings), 
                        dataView.categorical.values && dataView.categorical.values[0] && dataView.categorical.values[0].values && (frequencies = dataView.categorical.values[0].values), 
                        dataView.categorical.categories[0].identity && dataView.categorical.categories[0].identity.length > 0 && (identities = dataView.categorical.categories[0].identity), 
                        values = Histogram.getValuesByFrequencies(sourceValues, frequencies, identities), 
                        values.forEach(function(value) {
                            numericalValues.push(value.value), sumFrequency += value.frequency;
                        }), histogramLayout = d3.layout.histogram(), settings.bins && settings.bins > Histogram.MinNumberOfBins && (histogramLayout = histogramLayout.bins(settings.bins)), 
                        bins = histogramLayout.frequency(settings.frequency)(numericalValues), bins.forEach(function(bin, index) {
                            var filteredValues, frequency;
                            filteredValues = values.filter(function(value) {
                                return Histogram.isValueContainedInRange(value, bin, index);
                            }), frequency = filteredValues.reduce(function(previousValue, currentValue) {
                                return previousValue + currentValue.frequency;
                            }, 0), bin.y = settings.frequency ? frequency : frequency / sumFrequency, shiftByValues += bin.length;
                        }), borderValues = Histogram.getBorderValues(bins), yAxisSettings = settings.yAxisSettings;
                        var maxYvalue = null !== yAxisSettings.end && yAxisSettings.end > yAxisSettings.start ? yAxisSettings.end : borderValues.maxY, minYValue = yAxisSettings.start < maxYvalue ? yAxisSettings.start : 0;
                        return settings.yAxisSettings.start = Histogram.getCorrectXAxisValue(minYValue), 
                        settings.yAxisSettings.end = Histogram.getCorrectXAxisValue(maxYvalue), values.length >= Histogram.MinAmountOfValues && (valueFormatter = ValueFormatter.create({
                            format: ValueFormatter.getFormatString(dataView.categorical.categories[0].source, Histogram.Properties.general.formatString),
                            value: values[0].value,
                            value2: values[values.length - 1].value,
                            precision: settings.precision
                        }), xLabelFormatter = ValueFormatter.create({
                            value: 0 === settings.xAxisSettings.displayUnits ? values[values.length - 1].value : settings.xAxisSettings.displayUnits,
                            precision: settings.xAxisSettings.precision
                        }), yLabelFormatter = ValueFormatter.create({
                            value: settings.yAxisSettings.displayUnits,
                            precision: settings.yAxisSettings.precision
                        })), dataPoints = Histogram.getDataPoints(values, numericalValues, bins, settings, yLabelFormatter, xLabelFormatter), 
                        {
                            dataPoints: dataPoints,
                            borderValues: borderValues,
                            settings: settings,
                            formatter: valueFormatter,
                            xLabelFormatter: xLabelFormatter,
                            yLabelFormatter: yLabelFormatter,
                            xLegendSize: xLegendSize,
                            yLegendSize: yLegendSize
                        };
                    }, Histogram.getBorderValues = function(bins) {
                        var borderValues = {
                            minX: Number.MAX_VALUE,
                            maxX: -Number.MAX_VALUE,
                            minY: Number.MAX_VALUE,
                            maxY: -Number.MAX_VALUE
                        };
                        return bins.forEach(function(dataPoint) {
                            var minX = Number.MAX_VALUE, maxX = -Number.MAX_VALUE;
                            dataPoint.forEach(function(x) {
                                x > maxX && (maxX = x), x < minX && (minX = x);
                            }), minX < borderValues.minX && (borderValues.minX = minX), maxX > borderValues.maxX && (borderValues.maxX = maxX), 
                            dataPoint.y < borderValues.minY && (borderValues.minY = dataPoint.y), dataPoint.y > borderValues.maxY && (borderValues.maxY = dataPoint.y);
                        }), borderValues;
                    }, Histogram.getCorrectXAxisValue = function(value) {
                        return Math.max(Math.min(value, Histogram.MaxXAxisEndValue), Histogram.MinXAxisStartValue);
                    }, Histogram.areValuesNumbers = function(categoryColumn) {
                        return categoryColumn && categoryColumn.source && (categoryColumn.source.type.numeric || categoryColumn.source.type.integer);
                    }, Histogram.getValuesByFrequencies = function(sourceValues, frequencies, identities) {
                        var values = [];
                        return sourceValues.forEach(function(item, index) {
                            var frequency = 1, value = Number(item);
                            value = isNaN(value) ? 0 : value, frequencies && frequencies[index] && !isNaN(frequencies[index]) && frequencies[index] > 1 && (frequency = frequencies[index]), 
                            values.push({
                                value: value,
                                frequency: frequency,
                                selectionId: SelectionId.createWithId(identities[index])
                            });
                        }), values;
                    }, Histogram.getDataPoints = function(values, numericalValues, bins, settings, yValueFormatter, xValueFormatter) {
                        var fontSizeInPx = PixelConverter.fromPoint(settings.labelSettings.fontSize);
                        return bins.map(function(bin, index) {
                            return bin.range = Histogram.getRange(bin.x, bin.dx), bin.tooltipInfo = Histogram.getTooltipData(bin.y, bin.range, settings, 0 === index, yValueFormatter, xValueFormatter), 
                            bin.subDataPoints = Histogram.getSubDataPoints(values, bin, index), bin.labelFontSize = fontSizeInPx, 
                            bin;
                        });
                    }, Histogram.getRange = function(x, dx) {
                        return [ x, x + dx ];
                    }, Histogram.getTooltipData = function(value, range, settings, includeLeftBorder, yValueFormatter, xValueFormatter) {
                        return [ {
                            displayName: Histogram.getLegendText(settings),
                            value: yValueFormatter.format(value)
                        }, {
                            displayName: Histogram.TooltipDisplayName,
                            value: Histogram.rangeToString(range, includeLeftBorder, xValueFormatter)
                        } ];
                    }, Histogram.getSubDataPoints = function(values, bin, index) {
                        var dataPoints = [];
                        return values.forEach(function(value) {
                            Histogram.isValueContainedInRange(value, bin, index) && dataPoints.push({
                                identity: value.selectionId,
                                selected: !1
                            });
                        }), dataPoints;
                    }, Histogram.isValueContainedInRange = function(value, bin, index) {
                        return (0 === index && value.value >= bin.x || value.value > bin.x) && value.value <= bin.x + bin.dx;
                    }, Histogram.parseSettings = function(dataView, colors) {
                        if (!(dataView && dataView.metadata && dataView.metadata.columns && dataView.metadata.columns[0])) return null;
                        var objects, colorHelper, histogramSettings = {};
                        colorHelper = new ColorHelper(colors, Histogram.Properties.dataPoint.fill, Histogram.DefaultHistogramSettings.fillColor), 
                        histogramSettings.displayName = dataView.metadata.columns[0].displayName || Histogram.DefaultHistogramSettings.displayName, 
                        objects = Histogram.getObjectsFromDataView(dataView);
                        var xAxisSettings = {
                            axisColor: Histogram.getXAxisColor(objects).solid.color,
                            title: Histogram.getXTitle(objects),
                            precision: Histogram.getXPrecision(objects),
                            style: Histogram.getXStyle(objects),
                            displayUnits: Histogram.getXDisplayUnit(objects),
                            show: Histogram.getXAxisShow(objects)
                        }, yAxisSettings = {
                            axisColor: Histogram.getYAxisColor(objects).solid.color,
                            title: Histogram.getYTitle(objects),
                            precision: Histogram.getYPrecision(objects),
                            style: Histogram.getYStyle(objects),
                            displayUnits: Histogram.getYDisplayUnit(objects),
                            show: Histogram.getYAxisShow(objects),
                            start: Histogram.getYStart(objects),
                            end: Histogram.getYEnd(objects),
                            position: Histogram.getYPosition(objects)
                        }, labelSettings = {
                            show: Histogram.getLabelShow(objects),
                            color: Histogram.getLabelColor(objects).solid.color,
                            displayUnits: Histogram.getLabelDisplayUnits(objects),
                            precision: Histogram.getLabelPrecision(objects),
                            fontSize: Histogram.getLabelFontSize(objects)
                        };
                        return histogramSettings.fillColor = colorHelper.getColorForMeasure(objects, ""), 
                        histogramSettings.bins = Histogram.getBins(objects), histogramSettings.frequency = Histogram.getFrequency(objects), 
                        histogramSettings.precision = Histogram.getPrecision(objects), histogramSettings.displayName = Histogram.getLegend(histogramSettings.displayName, xAxisSettings.style, xAxisSettings.displayUnits), 
                        histogramSettings.xAxisSettings = xAxisSettings, histogramSettings.yAxisSettings = yAxisSettings, 
                        histogramSettings.labelSettings = labelSettings, histogramSettings;
                    }, Histogram.getLegend = function(title, style, displayUnit) {
                        var retValue, formatter;
                        switch (formatter = ValueFormatter.create({
                            value: displayUnit
                        }), style) {
                          case axisStyle.showTitleOnly:
                            retValue = title;
                            break;

                          case axisStyle.showUnitOnly:
                            retValue = 0 !== displayUnit && 1 !== displayUnit && formatter.displayUnit ? formatter.displayUnit.title : title;
                            break;

                          case axisStyle.showBoth:
                            retValue = 0 !== displayUnit && 1 !== displayUnit && formatter.displayUnit ? title + " (" + formatter.displayUnit.title + ")" : title;
                        }
                        return retValue;
                    }, Histogram.getLabelFontSize = function(objects) {
                        return DataViewObjects.getValue(objects, Histogram.Properties.labels.fontSize, Histogram.DefaultHistogramSettings.labelSettings.fontSize);
                    }, Histogram.getLabelShow = function(objects) {
                        return DataViewObjects.getValue(objects, Histogram.Properties.labels.show, Histogram.DefaultHistogramSettings.labelSettings.show);
                    }, Histogram.getLabelColor = function(objects) {
                        return DataViewObjects.getValue(objects, Histogram.Properties.labels.color, {
                            solid: {
                                color: Histogram.DefaultHistogramSettings.labelSettings.color
                            }
                        });
                    }, Histogram.getLabelDisplayUnits = function(objects) {
                        return DataViewObjects.getValue(objects, Histogram.Properties.labels.displayUnits, Histogram.DefaultHistogramSettings.labelSettings.displayUnits);
                    }, Histogram.getLabelPrecision = function(objects) {
                        var precision = DataViewObjects.getValue(objects, Histogram.Properties.labels.precision, Histogram.DefaultHistogramSettings.labelSettings.precision);
                        return precision <= Histogram.MinPrecision ? Histogram.MinPrecision : precision >= Histogram.MaxPrecision ? Histogram.MaxPrecision : precision;
                    }, Histogram.getXStyle = function(objects) {
                        return DataViewObjects.getValue(objects, Histogram.Properties.xAxis.style, Histogram.DefaultHistogramSettings.xAxisSettings.style);
                    }, Histogram.getXDisplayUnit = function(objects) {
                        return DataViewObjects.getValue(objects, Histogram.Properties.xAxis.displayUnits, Histogram.DefaultHistogramSettings.xAxisSettings.displayUnits);
                    }, Histogram.getXPrecision = function(objects) {
                        var precision = DataViewObjects.getValue(objects, Histogram.Properties.xAxis.precision, Histogram.DefaultHistogramSettings.xAxisSettings.precision);
                        return precision <= Histogram.MinPrecision ? Histogram.MinPrecision : precision >= Histogram.MaxPrecision ? Histogram.MaxPrecision : precision;
                    }, Histogram.getXAxisShow = function(objects) {
                        return DataViewObjects.getValue(objects, Histogram.Properties.xAxis.show, Histogram.DefaultHistogramSettings.xAxisSettings.show);
                    }, Histogram.getXAxisColor = function(objects) {
                        return DataViewObjects.getValue(objects, Histogram.Properties.xAxis.axisColor, {
                            solid: {
                                color: Histogram.DefaultHistogramSettings.xAxisSettings.axisColor
                            }
                        });
                    }, Histogram.getXTitle = function(objects) {
                        return DataViewObjects.getValue(objects, Histogram.Properties.xAxis.title, Histogram.DefaultHistogramSettings.xAxisSettings.title);
                    }, Histogram.getYStyle = function(objects) {
                        return DataViewObjects.getValue(objects, Histogram.Properties.yAxis.style, Histogram.DefaultHistogramSettings.yAxisSettings.style);
                    }, Histogram.getYPosition = function(objects) {
                        return DataViewObjects.getValue(objects, Histogram.Properties.yAxis.position, Histogram.DefaultHistogramSettings.yAxisSettings.position);
                    }, Histogram.getYAxisShow = function(objects) {
                        return DataViewObjects.getValue(objects, Histogram.Properties.yAxis.show, Histogram.DefaultHistogramSettings.yAxisSettings.show);
                    }, Histogram.getYAxisColor = function(objects) {
                        return DataViewObjects.getValue(objects, Histogram.Properties.yAxis.axisColor, {
                            solid: {
                                color: Histogram.DefaultHistogramSettings.yAxisSettings.axisColor
                            }
                        });
                    }, Histogram.getYStart = function(objects) {
                        return DataViewObjects.getValue(objects, Histogram.Properties.yAxis.start, Histogram.DefaultHistogramSettings.yAxisSettings.start);
                    }, Histogram.getYEnd = function(objects) {
                        return DataViewObjects.getValue(objects, Histogram.Properties.yAxis.end, Histogram.DefaultHistogramSettings.yAxisSettings.end);
                    }, Histogram.getYDisplayUnit = function(objects) {
                        return DataViewObjects.getValue(objects, Histogram.Properties.yAxis.displayUnits, Histogram.DefaultHistogramSettings.yAxisSettings.displayUnits);
                    }, Histogram.getYPrecision = function(objects) {
                        var precision = DataViewObjects.getValue(objects, Histogram.Properties.yAxis.precision, Histogram.DefaultHistogramSettings.yAxisSettings.precision);
                        return precision <= Histogram.MinPrecision ? Histogram.MinPrecision : precision >= Histogram.MaxPrecision ? Histogram.MaxPrecision : precision;
                    }, Histogram.getYTitle = function(objects) {
                        return DataViewObjects.getValue(objects, Histogram.Properties.yAxis.title, Histogram.DefaultHistogramSettings.yAxisSettings.title);
                    }, Histogram.getBins = function(objects) {
                        var binsNumber = Number(DataViewObjects.getValue(objects, Histogram.Properties.general.bins, Histogram.DefaultHistogramSettings.bins));
                        return !binsNumber || isNaN(binsNumber) || binsNumber <= Histogram.MinNumberOfBins ? Histogram.DefaultHistogramSettings.bins : binsNumber > Histogram.MaxNumberOfBins ? Histogram.MaxNumberOfBins : binsNumber;
                    }, Histogram.getFrequency = function(objects) {
                        return DataViewObjects.getValue(objects, Histogram.Properties.general.frequency, Histogram.DefaultHistogramSettings.frequency);
                    }, Histogram.getPrecision = function(objects) {
                        var precision = DataViewObjects.getValue(objects, Histogram.Properties.labels.precision, Histogram.DefaultHistogramSettings.precision);
                        return precision <= Histogram.MinPrecision ? Histogram.MinPrecision : precision >= Histogram.MaxPrecision ? Histogram.MaxPrecision : precision;
                    }, Histogram.prototype.isDataValid = function(data) {
                        return !(!data || !data.dataPoints || 0 === data.dataPoints.length) && (!data.dataPoints.some(function(x) {
                            return x.range.some(function(x) {
                                return isNaN(x) || x === 1 / 0 || x === -(1 / 0);
                            });
                        }) || (this.hostService.setWarnings([ new HistogramChartWarning(HistogramChartWarning.ErrorInvalidDataValues) ]), 
                        !1));
                    }, Histogram.prototype.update = function(visualUpdateOptions) {
                        if (visualUpdateOptions && visualUpdateOptions.dataViews && visualUpdateOptions.dataViews[0]) {
                            var maxWidthOfVerticalAxisLabel, dataView = visualUpdateOptions.dataViews[0];
                            if (this.setSize(visualUpdateOptions.viewport), this.dataView = Histogram.converter(dataView, this.colors), 
                            !this.isDataValid(this.dataView)) return void this.clear();
                            this.updateViewportIn(), maxWidthOfVerticalAxisLabel = this.updateAxes(dataView), 
                            this.columsAndAxesTransform(maxWidthOfVerticalAxisLabel), this.updateWidthOfColumn(), 
                            this.createScales(), this.applySelectionStateToData(), this.render();
                        }
                    }, Histogram.prototype.updateAxes = function(dataView) {
                        var maxWidthOfVerticalAxisLabel, maxWidthOfHorizontalAxisLabel, maxHeightOfVerticalAxisLabel;
                        maxWidthOfVerticalAxisLabel = Histogram.getWidthOfLabel(this.dataView.borderValues.maxY, this.dataView.yLabelFormatter), 
                        maxWidthOfHorizontalAxisLabel = Histogram.getWidthOfLabel(this.dataView.borderValues.maxX, this.dataView.xLabelFormatter), 
                        maxHeightOfVerticalAxisLabel = Histogram.getHeightOfLabel(this.dataView.borderValues.maxX, this.dataView.xLabelFormatter);
                        var ySource = dataView.categorical.values && dataView.categorical.values[0] && dataView.categorical.values[0].values ? dataView.categorical.values[0].source : dataView.categorical.categories[0].source;
                        return this.yAxisProperties = this.calculateYAxes(ySource, maxHeightOfVerticalAxisLabel), 
                        this.renderYAxis(), this.yTitleMargin = this.shouldShowYOnRight() ? this.viewport.width - Histogram.YTitleMargin + this.dataView.yLegendSize : 0, 
                        this.updateViewportIn(maxWidthOfVerticalAxisLabel), this.xAxisProperties = this.calculateXAxes(dataView.categorical.categories[0].source, Histogram.DefaultTextProperties, maxWidthOfHorizontalAxisLabel, !1), 
                        this.renderXAxis(), maxWidthOfVerticalAxisLabel;
                    }, Histogram.prototype.applySelectionStateToData = function() {
                        var _this = this;
                        this.interactivityService && this.dataView.dataPoints.forEach(function(dataPoint) {
                            _this.interactivityService.applySelectionStateToData(dataPoint.subDataPoints);
                        });
                    }, Histogram.prototype.createScales = function() {
                        var yAxisSettings = this.dataView.settings.yAxisSettings, borderValues = this.dataView.borderValues;
                        this.dataView.xScale = d3.scale.linear().domain([ borderValues.minX, borderValues.maxX ]).range([ 0, this.viewportIn.width ]), 
                        this.dataView.yScale = d3.scale.linear().domain([ yAxisSettings.start, yAxisSettings.end ]).range([ this.viewportIn.height, this.outerPadding ]);
                    }, Histogram.prototype.updateViewportIn = function(maxWidthOfVerticalAxisLabel) {
                        void 0 === maxWidthOfVerticalAxisLabel && (maxWidthOfVerticalAxisLabel = 0);
                        var width, height;
                        width = this.viewport.width - this.dataView.yLegendSize - maxWidthOfVerticalAxisLabel, 
                        height = this.viewport.height - this.dataView.xLegendSize, this.viewportIn = {
                            height: Math.max(height, Histogram.MinViewportInSize),
                            width: Math.max(width, Histogram.MinViewportInSize)
                        };
                    }, Histogram.prototype.updateWidthOfColumn = function() {
                        var widthOfColumn, countOfValues = this.dataView.dataPoints.length;
                        widthOfColumn = countOfValues ? this.viewportIn.width / countOfValues - Histogram.ColumnPadding : Histogram.MinViewportInSize, 
                        this.widthOfColumn = Math.max(widthOfColumn, Histogram.MinViewportInSize);
                    }, Histogram.prototype.clear = function() {
                        var _this = this;
                        [ this.axisX, this.axisY, this.legend, this.columns, this.labelGraphicsContext ].forEach(function(selection) {
                            _this.clearElement(selection);
                        });
                    }, Histogram.prototype.clearElement = function(selection) {
                        selection.selectAll("*").remove();
                    }, Histogram.getLegendSize = function(axisSettings) {
                        return axisSettings.title ? Histogram.LegendSizeWhenTitleIsActive : Histogram.LegendSizeWhenTitleIsNotActive;
                    }, Histogram.getWidthOfLabel = function(labelValue, valueFormatter) {
                        var textProperties = Histogram.getTextPropertiesForMeasurement(labelValue, valueFormatter);
                        return TextMeasurementService.measureSvgTextWidth(textProperties) + Histogram.AdditionalWidthOfLabel;
                    }, Histogram.getHeightOfLabel = function(labelValue, valueFormatter) {
                        var textProperties = Histogram.getTextPropertiesForMeasurement(labelValue, valueFormatter);
                        return TextMeasurementService.measureSvgTextHeight(textProperties) + Histogram.AdditionalHeightOfLabel;
                    }, Histogram.getTextPropertiesForMeasurement = function(labelValue, valueFormatter) {
                        var labelText;
                        return labelText = valueFormatter ? valueFormatter.format(labelValue) : labelValue, 
                        Histogram.getTextProperties(labelText);
                    }, Histogram.prototype.setSize = function(viewport) {
                        var height, width;
                        height = viewport.height - this.margin.top - this.margin.bottom, width = viewport.width - this.margin.left - this.margin.right, 
                        this.viewport = {
                            height: Math.max(height, Histogram.MinViewportSize),
                            width: Math.max(width, Histogram.MinViewportSize)
                        }, this.updateElements(Math.max(viewport.height, Histogram.MinViewportSize), Math.max(viewport.width, Histogram.MinViewportSize));
                    }, Histogram.prototype.updateElements = function(height, width) {
                        var transform = SVGUtil.translate(this.margin.left, this.margin.top);
                        this.root.attr({
                            height: height,
                            width: width
                        }), this.main.attr("transform", transform), this.legend.attr("transform", transform);
                    }, Histogram.prototype.shouldShowYOnRight = function() {
                        return this.dataView.settings.yAxisSettings.position === yAxisPosition.right;
                    }, Histogram.prototype.columsAndAxesTransform = function(labelWidth) {
                        var offsetToRightStr, offsetToRight = this.shouldShowYOnRight() ? this.margin.left : this.dataView.settings.yAxisSettings.title ? this.margin.left + labelWidth + Histogram.YAxisMargin : this.margin.left + labelWidth;
                        offsetToRightStr = SVGUtil.translate(offsetToRight + Histogram.ColumnAndLabelOffset, 0), 
                        this.columns.attr("transform", offsetToRightStr), this.labelGraphicsContext.attr("transform", offsetToRightStr), 
                        this.axes.attr("transform", SVGUtil.translate(offsetToRight, 0)), this.axisY.attr("transform", SVGUtil.translate(this.shouldShowYOnRight() ? this.viewportIn.width : 0, 0)), 
                        this.axisX.attr("transform", SVGUtil.translate(0, this.viewportIn.height));
                    }, Histogram.prototype.render = function() {
                        var columnsSelection = this.renderColumns();
                        Histogram.bindTooltipsToSelection(columnsSelection), this.bindSelectionHandler(columnsSelection), 
                        this.renderLegend(), this.renderLabels();
                    }, Histogram.prototype.renderColumns = function() {
                        var updateColumnsSelection, _this = this, data = this.dataView.dataPoints, xScale = this.dataView.xScale, yScale = this.dataView.yScale;
                        return updateColumnsSelection = this.columnsSelection.data(data), updateColumnsSelection.enter().append("svg:rect").classed(Histogram.Column.class, !0), 
                        updateColumnsSelection.attr({
                            x: function(dataPoint) {
                                return xScale(dataPoint.x);
                            },
                            y: function(dataPoint) {
                                return yScale(dataPoint.y);
                            },
                            width: this.widthOfColumn,
                            height: function(item) {
                                return _this.getColumnHeight(item, yScale);
                            }
                        }).style("fill", this.dataView.settings.fillColor), histogramUtils.updateFillOpacity(updateColumnsSelection, this.interactivityService, !1), 
                        updateColumnsSelection.exit().remove(), updateColumnsSelection;
                    }, Histogram.bindTooltipsToSelection = function(selection) {
                        TooltipManager.addTooltip(selection, function(tooltipEvent) {
                            return tooltipEvent.data.tooltipInfo;
                        });
                    }, Histogram.prototype.getColumnHeight = function(column, y) {
                        var height = this.viewportIn.height - y(column.y);
                        return Math.max(height, Histogram.MinColumnHeight);
                    }, Histogram.prototype.renderXAxis = function() {
                        var xAxis, _this = this, xShow = this.dataView.settings.xAxisSettings.show, axisColor = this.dataView.settings.xAxisSettings.axisColor;
                        xAxis = this.xAxisProperties.axis.tickFormat(function(value, index) {
                            var tickValues = _this.xAxisProperties.axis.tickValues(), amountOfLabels = tickValues && tickValues.length || 0;
                            return _this.formatLabelOfXAxis(value, index, amountOfLabels);
                        }).orient("bottom"), xShow ? this.axisX.call(xAxis) : this.axisX.selectAll("*").remove(), 
                        this.updateFillColorOfAxis(this.axisX, axisColor);
                    }, Histogram.prototype.formatLabelOfXAxis = function(labelValue, index, amountOfLabels) {
                        var maxWidthOfTheLatestLabel, formattedLabel = this.dataView.xLabelFormatter.format(labelValue);
                        return 0 !== index && index !== amountOfLabels - 1 || (maxWidthOfTheLatestLabel = Math.min(this.viewportIn.width, Histogram.MaxWidthOfTheLatestLabel), 
                        formattedLabel = Histogram.getTailoredTextOrDefault(formattedLabel, maxWidthOfTheLatestLabel)), 
                        formattedLabel;
                    }, Histogram.getTailoredTextOrDefault = function(text, maxWidth) {
                        var textProperties = Histogram.getTextProperties(text);
                        return TextMeasurementService.getTailoredTextOrDefault(textProperties, maxWidth);
                    }, Histogram.getTextProperties = function(text) {
                        return {
                            text: text,
                            fontFamily: Histogram.DefaultTextProperties.fontFamily,
                            fontSize: Histogram.DefaultTextProperties.fontSize
                        };
                    }, Histogram.prototype.renderYAxis = function() {
                        var yAxis, _this = this, yShow = this.dataView.settings.yAxisSettings.show, axisColor = this.dataView.settings.yAxisSettings.axisColor;
                        yAxis = this.yAxisProperties.axis.orient(this.dataView.settings.yAxisSettings.position.toLowerCase()).tickFormat(function(item) {
                            return _this.dataView.yLabelFormatter.format(item);
                        }), yShow ? this.axisY.call(yAxis) : this.axisY.selectAll("*").remove(), this.updateFillColorOfAxis(this.axisY, axisColor);
                    }, Histogram.prototype.updateFillColorOfAxis = function(axisSelection, fillColor) {
                        axisSelection.selectAll("g.tick text").style({
                            fill: fillColor
                        });
                    }, Histogram.prototype.getLabelLayout = function() {
                        var _this = this, labelSettings = this.dataView.settings.labelSettings, fontSizeInPx = PixelConverter.fromPoint(labelSettings.fontSize), fontFamily = dataLabelUtils.LabelTextProperties.fontFamily, xScale = this.dataView.xScale, yScale = this.dataView.yScale, dataLabelFormatter = ValueFormatter.create({
                            value: labelSettings.displayUnits,
                            precision: labelSettings.precision
                        });
                        return {
                            labelText: function(dataPoint) {
                                return dataLabelFormatter.format(dataPoint.y).toString();
                            },
                            labelLayout: {
                                x: function(dataPoint) {
                                    var x, dx;
                                    return x = xScale(dataPoint.x), dx = dataPoint.size.width / Histogram.DataLabelXOffset - _this.widthOfColumn / 2, 
                                    x - dx;
                                },
                                y: function(dataPoint) {
                                    var y, dy;
                                    return y = yScale(dataPoint.y), dy = dataPoint.size.height, y - dy;
                                }
                            },
                            filter: function(dataPoint) {
                                return null != dataPoint;
                            },
                            style: {
                                fill: labelSettings.color,
                                "font-size": fontSizeInPx,
                                "font-family": fontFamily
                            }
                        };
                    }, Histogram.prototype.renderLabels = function() {
                        var labels, labelSettings = this.dataView.settings.labelSettings, dataPointsArray = this.dataView.dataPoints;
                        return labelSettings.show ? (labels = dataLabelUtils.drawDefaultLabelsForDataPointChart(dataPointsArray, this.labelGraphicsContext, this.getLabelLayout(), this.viewportIn), 
                        void (labels && labels.attr("transform", function(dataPoint) {
                            var dx, dy, size = dataPoint.size;
                            return dx = size.width / Histogram.DataLabelXOffset, dy = size.height / Histogram.DataLabelYOffset, 
                            SVGUtil.translate(dx, dy);
                        }))) : void dataLabelUtils.cleanDataLabels(this.labelGraphicsContext);
                    }, Histogram.rangesToArray = function(data) {
                        return data.reduce(function(previousValue, currentValue, index) {
                            var range;
                            return range = 0 === index ? currentValue.range : currentValue.range.slice(1), previousValue.concat(range);
                        }, []);
                    }, Histogram.rangeToString = function(range, includeLeftBorder, valueFormatter) {
                        var leftBracket, rightBracket = Histogram.IncludeBrackets.right, leftBorder = valueFormatter.format(range[0]), rightBorder = valueFormatter.format(range[1]);
                        return leftBracket = includeLeftBorder ? Histogram.IncludeBrackets.left : Histogram.ExcludeBrackets.left, 
                        "" + leftBracket + leftBorder + Histogram.SeparatorNumbers + rightBorder + rightBracket;
                    }, Histogram.prototype.renderLegend = function() {
                        var legendElements, legendSelection, datalegends = this.getDataLegends(this.dataView.settings);
                        legendElements = this.main.select(Histogram.Legends.selector).selectAll(Histogram.Legend.selector), 
                        legendSelection = legendElements.data(datalegends), legendSelection.enter().append("svg:text"), 
                        legendSelection.attr({
                            x: 0,
                            y: 0,
                            dx: function(item) {
                                return item.dx;
                            },
                            dy: function(item) {
                                return item.dy;
                            },
                            transform: function(item) {
                                return item.transform;
                            }
                        }).text(function(item) {
                            return item.text;
                        }).classed(Histogram.Legend.class, !0), legendSelection.exit().remove(), this.legend.select("text").style({
                            display: Histogram.getDispayForAxisTitle(this.dataView.settings.xAxisSettings)
                        }), this.legend.selectAll("text").filter(function(d, index) {
                            return 1 === index;
                        }).style({
                            display: Histogram.getDispayForAxisTitle(this.dataView.settings.yAxisSettings)
                        });
                    }, Histogram.getDispayForAxisTitle = function(axisSettings) {
                        return axisSettings && axisSettings.title ? null : "none";
                    }, Histogram.prototype.getDataLegends = function(settings) {
                        var bottomLegendText = Histogram.getLegendText(settings);
                        return bottomLegendText = Histogram.getLegend(bottomLegendText, settings.yAxisSettings.style, settings.yAxisSettings.displayUnits), 
                        [ {
                            transform: SVGUtil.translate(this.viewport.width / 2, this.viewport.height),
                            text: Histogram.getTailoredTextOrDefault(settings.displayName, this.viewportIn.width),
                            dx: "-0.5em",
                            dy: "-1em"
                        }, {
                            transform: SVGUtil.translateAndRotate(this.shouldShowYOnRight() ? this.yTitleMargin : 0, this.viewport.height / 2, 0, 0, 270),
                            text: Histogram.getTailoredTextOrDefault(bottomLegendText, this.viewportIn.height),
                            dx: "3em"
                        } ];
                    }, Histogram.getLegendText = function(settings) {
                        return settings.frequency ? Histogram.FrequencyText : Histogram.DensityText;
                    }, Histogram.prototype.bindSelectionHandler = function(columnsSelection) {
                        if (this.interactivityService && this.dataView && this.dataView.dataPoints) {
                            var subDataPoints = [];
                            this.dataView.dataPoints.forEach(function(dataPoint) {
                                subDataPoints = subDataPoints.concat(dataPoint.subDataPoints);
                            });
                            var behaviorOptions = {
                                columns: columnsSelection,
                                clearCatcher: this.clearCatcher,
                                interactivityService: this.interactivityService
                            };
                            this.interactivityService.bind(subDataPoints, this.behavior, behaviorOptions);
                        }
                    }, Histogram.prototype.enumerateObjectInstances = function(options) {
                        var settings, enumeration = new ObjectEnumerationBuilder();
                        if (!this.dataView || !this.dataView.settings) return [];
                        switch (settings = this.dataView.settings, options.objectName) {
                          case "general":
                            this.enumerateGeneral(enumeration, settings);
                            break;

                          case "dataPoint":
                            this.enumerateDataPoint(enumeration, settings);
                            break;

                          case "labels":
                            this.enumerateLabels(enumeration, settings);
                            break;

                          case "xAxis":
                            this.enumerateXAxis(enumeration, settings);
                            break;

                          case "yAxis":
                            this.enumerateYAxis(enumeration, settings);
                        }
                        return enumeration.complete() || [];
                    }, Histogram.prototype.enumerateGeneral = function(enumeration, settings) {
                        var general = {
                            objectName: "general",
                            displayName: "general",
                            selector: null,
                            properties: {
                                bins: settings.bins,
                                frequency: settings.frequency
                            }
                        };
                        enumeration.pushInstance(general);
                    }, Histogram.prototype.enumerateDataPoint = function(enumeration, settings) {
                        var dataPoint = {
                            objectName: "dataPoint",
                            displayName: "dataPoint",
                            selector: null,
                            properties: {
                                fill: settings.fillColor
                            }
                        };
                        enumeration.pushInstance(dataPoint);
                    }, Histogram.prototype.enumerateLabels = function(enumeration, settings) {
                        var labelsSettings = settings.labelSettings, labels = {
                            objectName: "labels",
                            displayName: "labels",
                            selector: null,
                            properties: {
                                show: labelsSettings.show,
                                color: labelsSettings.color,
                                displayUnits: labelsSettings.displayUnits,
                                precision: labelsSettings.precision,
                                fontSize: labelsSettings.fontSize
                            }
                        };
                        enumeration.pushInstance(labels);
                    }, Histogram.prototype.enumerateXAxis = function(enumeration, settings) {
                        var xAxisSettings = settings.xAxisSettings, xAxis = {
                            objectName: "xAxis",
                            displayName: "X-Axis",
                            selector: null,
                            properties: {
                                show: xAxisSettings.show,
                                title: xAxisSettings.title,
                                style: xAxisSettings.style,
                                axisColor: xAxisSettings.axisColor,
                                displayUnits: xAxisSettings.displayUnits,
                                precision: xAxisSettings.precision
                            }
                        };
                        enumeration.pushInstance(xAxis);
                    }, Histogram.prototype.enumerateYAxis = function(enumeration, settings) {
                        var yAxisSettings = settings.yAxisSettings, yAxis = {
                            objectName: "yAxis",
                            displayName: "Y-Axis",
                            selector: null,
                            properties: {
                                show: yAxisSettings.show,
                                position: yAxisSettings.position,
                                start: yAxisSettings.start,
                                end: yAxisSettings.end,
                                title: yAxisSettings.title,
                                style: yAxisSettings.style,
                                axisColor: yAxisSettings.axisColor,
                                displayUnits: yAxisSettings.displayUnits,
                                precision: yAxisSettings.precision
                            }
                        };
                        enumeration.pushInstance(yAxis);
                    }, Histogram.getObjectsFromDataView = function(dataView) {
                        return dataView && dataView.metadata && dataView.metadata.columns && dataView.metadata.objects ? dataView.metadata.objects : null;
                    }, Histogram.prototype.destroy = function() {
                        this.root = null;
                    }, Histogram.prototype.calculateXAxes = function(source, textProperties, widthOfLabel, scrollbarVisible) {
                        var axes, width = this.viewportIn.width;
                        return axes = this.calculateXAxesProperties(Histogram.rangesToArray(this.dataView.dataPoints), axisScale.linear, source, Histogram.InnerPaddingRatio, widthOfLabel), 
                        axes.willLabelsFit = willLabelsFit(axes, width, TextMeasurementService.measureSvgTextWidth, textProperties), 
                        axes.willLabelsWordBreak = !axes.willLabelsFit && !scrollbarVisible && willLabelsWordBreak(axes, this.margin, width, TextMeasurementService.measureSvgTextWidth, TextMeasurementService.estimateSvgTextHeight, TextMeasurementService.getTailoredTextOrDefault, textProperties), 
                        axes;
                    }, Histogram.prototype.calculateXAxesProperties = function(forcedXDomain, categoryAxisScaleType, metaDataColumn, innerPaddingRatio, minOrdinalRectThickness) {
                        var xAxisProperties = HistogramAxisHelper.createAxis({
                            pixelSpan: this.viewportIn.width,
                            dataDomain: forcedXDomain,
                            metaDataColumn: metaDataColumn,
                            formatString: valueFormatter.getFormatString(metaDataColumn, Histogram.Properties.general.formatString),
                            outerPadding: 0,
                            isScalar: !1,
                            isVertical: !1,
                            useTickIntervalForDisplayUnits: !0,
                            isCategoryAxis: !0,
                            getValueFn: function(index, type) {
                                return index;
                            },
                            scaleType: categoryAxisScaleType,
                            innerPaddingRatio: innerPaddingRatio,
                            minOrdinalRectThickness: minOrdinalRectThickness,
                            tickLabelPadding: void 0
                        });
                        return xAxisProperties.axisLabel = this.dataView.settings.displayName, xAxisProperties;
                    }, Histogram.prototype.calculateYAxes = function(source, heightOfLabel) {
                        var yAxisSettings = this.dataView.settings.yAxisSettings;
                        return this.calculateYAxesProperties([ yAxisSettings.start, yAxisSettings.end ], axisScale.linear, source, Histogram.InnerPaddingRatio, heightOfLabel);
                    }, Histogram.prototype.calculateYAxesProperties = function(forcedYDomain, categoryAxisScaleType, metaDataColumn, innerPaddingRatio, minOrdinalRectThickness) {
                        var formatString = void 0;
                        return this.dataView.settings.frequency && (formatString = valueFormatter.getFormatString(metaDataColumn, Histogram.Properties.general.formatString)), 
                        HistogramAxisHelper.createAxis({
                            pixelSpan: this.viewportIn.height,
                            dataDomain: forcedYDomain,
                            metaDataColumn: metaDataColumn,
                            formatString: formatString,
                            outerPadding: this.outerPadding,
                            isScalar: !0,
                            isVertical: !0,
                            useTickIntervalForDisplayUnits: !0,
                            isCategoryAxis: !1,
                            getValueFn: function(index, type) {
                                return index;
                            },
                            scaleType: categoryAxisScaleType,
                            innerPaddingRatio: innerPaddingRatio,
                            minOrdinalRectThickness: minOrdinalRectThickness,
                            tickLabelPadding: void 0,
                            is100Pct: !0
                        });
                    }, Histogram.ClassName = "histogram", Histogram.FrequencyText = "Frequency", Histogram.DensityText = "Density", 
                    Histogram.Properties = {
                        general: {
                            bins: {
                                objectName: "general",
                                propertyName: "bins"
                            },
                            frequency: {
                                objectName: "general",
                                propertyName: "frequency"
                            },
                            formatString: {
                                objectName: "general",
                                propertyName: "formatString"
                            }
                        },
                        dataPoint: {
                            fill: {
                                objectName: "dataPoint",
                                propertyName: "fill"
                            }
                        },
                        labels: {
                            show: {
                                objectName: "labels",
                                propertyName: "show"
                            },
                            color: {
                                objectName: "labels",
                                propertyName: "color"
                            },
                            displayUnits: {
                                objectName: "labels",
                                propertyName: "displayUnits"
                            },
                            precision: {
                                objectName: "labels",
                                propertyName: "precision"
                            },
                            fontSize: {
                                objectName: "labels",
                                propertyName: "fontSize"
                            }
                        },
                        xAxis: {
                            show: {
                                objectName: "xAxis",
                                propertyName: "show"
                            },
                            axisColor: {
                                objectName: "xAxis",
                                propertyName: "axisColor"
                            },
                            title: {
                                objectName: "xAxis",
                                propertyName: "title"
                            },
                            displayUnits: {
                                objectName: "xAxis",
                                propertyName: "displayUnits"
                            },
                            precision: {
                                objectName: "xAxis",
                                propertyName: "precision"
                            },
                            style: {
                                objectName: "xAxis",
                                propertyName: "style"
                            }
                        },
                        yAxis: {
                            show: {
                                objectName: "yAxis",
                                propertyName: "show"
                            },
                            axisColor: {
                                objectName: "yAxis",
                                propertyName: "axisColor"
                            },
                            title: {
                                objectName: "yAxis",
                                propertyName: "title"
                            },
                            displayUnits: {
                                objectName: "yAxis",
                                propertyName: "displayUnits"
                            },
                            precision: {
                                objectName: "yAxis",
                                propertyName: "precision"
                            },
                            style: {
                                objectName: "yAxis",
                                propertyName: "style"
                            },
                            start: {
                                objectName: "yAxis",
                                propertyName: "start"
                            },
                            end: {
                                objectName: "yAxis",
                                propertyName: "end"
                            },
                            position: {
                                objectName: "yAxis",
                                propertyName: "position"
                            }
                        }
                    }, Histogram.DefaultHistogramSettings = {
                        frequency: !0,
                        displayName: "Histogram",
                        bins: null,
                        fillColor: "#01b8aa",
                        precision: 2,
                        xAxisSettings: {
                            show: !0,
                            axisColor: "#777",
                            title: !0,
                            displayUnits: 0,
                            precision: 2,
                            style: axisStyle.showTitleOnly
                        },
                        yAxisSettings: {
                            show: !0,
                            axisColor: "#777",
                            title: !0,
                            displayUnits: 0,
                            precision: 2,
                            style: axisStyle.showTitleOnly,
                            start: 0,
                            position: yAxisPosition.left
                        },
                        labelSettings: {
                            show: !1,
                            color: "#777",
                            displayUnits: 0,
                            precision: 2,
                            fontSize: 9
                        }
                    }, Histogram.Axes = createClassAndSelector("axes"), Histogram.Axis = createClassAndSelector("axis"), 
                    Histogram.XAxis = createClassAndSelector("xAxis"), Histogram.YAxis = createClassAndSelector("yAxis"), 
                    Histogram.Columns = createClassAndSelector("columns"), Histogram.Column = createClassAndSelector("column"), 
                    Histogram.Legends = createClassAndSelector("legends"), Histogram.Legend = createClassAndSelector("legend"), 
                    Histogram.LabelGraphicsContext = createClassAndSelector("labelGraphicsContext"), 
                    Histogram.MinNumberOfBins = 0, Histogram.MaxNumberOfBins = 100, Histogram.MinPrecision = 0, 
                    Histogram.MaxPrecision = 17, Histogram.MinXAxisStartValue = 0, Histogram.MaxXAxisEndValue = 1e25, 
                    Histogram.YTitleMargin = 70, Histogram.YAxisMargin = 20, Histogram.MinViewportSize = 100, 
                    Histogram.MinViewportInSize = 0, Histogram.MinAmountOfValues = 2, Histogram.AdditionalWidthOfLabel = 3, 
                    Histogram.AdditionalHeightOfLabel = 3, Histogram.LegendSizeWhenTitleIsActive = 50, 
                    Histogram.LegendSizeWhenTitleIsNotActive = 25, Histogram.InnerPaddingRatio = 1, 
                    Histogram.DataLabelXOffset = 2, Histogram.DataLabelYOffset = 1.8, Histogram.ColumnPadding = 2.5, 
                    Histogram.ColumnAndLabelOffset = 1.5, Histogram.MinColumnHeight = 1, Histogram.TooltipDisplayName = "Range", 
                    Histogram.SeparatorNumbers = ", ", Histogram.MaxWidthOfTheLatestLabel = 40, Histogram.ExcludeBrackets = {
                        left: "(",
                        right: ")"
                    }, Histogram.IncludeBrackets = {
                        left: "[",
                        right: "]"
                    }, Histogram.DefaultMargin = {
                        top: 10,
                        right: 10,
                        bottom: 10,
                        left: 10
                    }, Histogram.DefaultTextProperties = {
                        fontFamily: "'Segoe UI', 'wf_segoe-ui_normal', helvetica, arial, sans-serif",
                        fontSize: PixelConverter.toString(11)
                    }, Histogram.capabilities = {
                        dataRoles: [ {
                            name: "Values",
                            kind: VisualDataRoleKind.Grouping,
                            displayName: "Values"
                        }, {
                            name: "Frequency",
                            kind: VisualDataRoleKind.Measure,
                            displayName: "Frequency"
                        } ],
                        dataViewMappings: [ {
                            conditions: [ {
                                Values: {
                                    min: 1,
                                    max: 1
                                },
                                Frequency: {
                                    min: 0,
                                    max: 1
                                }
                            } ],
                            categorical: {
                                categories: {
                                    bind: {
                                        to: "Values"
                                    },
                                    dataReductionAlgorithm: {
                                        top: {}
                                    }
                                },
                                values: {
                                    for: {
                                        in: "Frequency"
                                    }
                                }
                            }
                        } ],
                        sorting: {
                            implicit: {
                                clauses: [ {
                                    role: "Values",
                                    direction: 1
                                } ]
                            }
                        },
                        objects: {
                            general: {
                                displayName: "General",
                                properties: {
                                    formatString: {
                                        type: {
                                            formatting: {
                                                formatString: !0
                                            }
                                        }
                                    },
                                    bins: {
                                        displayName: "Bins",
                                        type: {
                                            numeric: !0
                                        }
                                    },
                                    frequency: {
                                        displayName: "Frequency",
                                        type: {
                                            bool: !0
                                        }
                                    }
                                }
                            },
                            dataPoint: {
                                displayName: "Data colors",
                                properties: {
                                    fill: {
                                        displayName: "Fill",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    }
                                }
                            },
                            xAxis: {
                                displayName: "X-Axis",
                                properties: {
                                    show: {
                                        displayName: "Show",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    axis: {
                                        displayName: "Axis",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    axisColor: {
                                        displayName: "Color",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    title: {
                                        displayName: "Title",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    displayUnits: {
                                        displayName: "Display Units",
                                        type: {
                                            formatting: {
                                                labelDisplayUnits: !0
                                            }
                                        }
                                    },
                                    precision: {
                                        displayName: "Decimal Places",
                                        type: {
                                            numeric: !0
                                        }
                                    },
                                    style: {
                                        displayName: "Style",
                                        type: {
                                            enumeration: axisStyle.type
                                        }
                                    }
                                }
                            },
                            yAxis: {
                                displayName: "Y-Axis",
                                properties: {
                                    show: {
                                        displayName: "Show",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    axis: {
                                        displayName: "yAxis",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    axisColor: {
                                        displayName: "Color",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    title: {
                                        displayName: "Title",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    displayUnits: {
                                        displayName: "Display Units",
                                        type: {
                                            formatting: {
                                                labelDisplayUnits: !0
                                            }
                                        }
                                    },
                                    precision: {
                                        displayName: "Decimal Places",
                                        type: {
                                            numeric: !0
                                        }
                                    },
                                    style: {
                                        displayName: "Style",
                                        type: {
                                            enumeration: axisStyle.type
                                        }
                                    },
                                    start: {
                                        displayName: "Start",
                                        type: {
                                            numeric: !0
                                        },
                                        placeHolderText: "Start",
                                        suppressFormatPainterCopy: !0
                                    },
                                    end: {
                                        displayName: "End",
                                        type: {
                                            numeric: !0
                                        },
                                        placeHolderText: "End",
                                        suppressFormatPainterCopy: !0
                                    },
                                    position: {
                                        displayName: "Position",
                                        type: {
                                            enumeration: yAxisPosition.type
                                        }
                                    }
                                }
                            },
                            labels: {
                                displayName: "Data Labels",
                                properties: {
                                    show: {
                                        displayName: "Show",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    color: {
                                        displayName: "Color",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    displayUnits: {
                                        displayName: "Display Units",
                                        type: {
                                            formatting: {
                                                labelDisplayUnits: !0
                                            }
                                        },
                                        suppressFormatPainterCopy: !0
                                    },
                                    precision: {
                                        displayName: "Decimal Places",
                                        type: {
                                            numeric: !0
                                        },
                                        suppressFormatPainterCopy: !0
                                    },
                                    fontSize: {
                                        displayName: "Text Size",
                                        type: {
                                            formatting: {
                                                fontSize: !0
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }, Histogram;
                }();
                samples.Histogram = Histogram;
                var HistogramAxisHelper;
                !function(HistogramAxisHelper) {
                    function createAxis(options) {
                        var pixelSpan = options.pixelSpan, dataDomain = options.dataDomain, metaDataColumn = options.metaDataColumn, formatString = options.formatString, outerPadding = options.outerPadding || 0, isCategoryAxis = !!options.isCategoryAxis, isScalar = !!options.isScalar, isVertical = !!options.isVertical, useTickIntervalForDisplayUnits = !!options.useTickIntervalForDisplayUnits, getValueFn = options.getValueFn, categoryThickness = options.categoryThickness, axisDisplayUnits = options.axisDisplayUnits, axisPrecision = options.axisPrecision, is100Pct = !!options.is100Pct, tickLabelPadding = options.tickLabelPadding || TickLabelPadding, dataType = getCategoryValueType(metaDataColumn, isScalar), scaleResult = createScale(options), scale = scaleResult.scale, bestTickCount = scaleResult.bestTickCount, scaleDomain = scale.domain(), isLogScaleAllowed = isLogScalePossible(dataDomain, dataType);
                        if (categoryThickness && isScalar && dataDomain && 2 === dataDomain.length) {
                            var oldSpan = dataDomain[1] - dataDomain[0], newSpan = scaleDomain[1] - scaleDomain[0];
                            oldSpan > 0 && newSpan > 0 && (categoryThickness = categoryThickness * oldSpan / newSpan);
                        }
                        var tickValues;
                        if (isScalar && 1 === bestTickCount) tickValues = [ dataDomain[0] ]; else {
                            var minTickInterval = isScalar ? getMinTickValueInterval(formatString, dataType, is100Pct) : void 0;
                            tickValues = getRecommendedTickValues(bestTickCount, scale, dataType, isScalar, minTickInterval);
                        }
                        options.scaleType && options.scaleType === axisScale.log && isLogScaleAllowed && (tickValues = tickValues.filter(function(d) {
                            return powerOfTen(d);
                        }));
                        var formatter = createFormatter(scaleDomain, dataDomain, dataType, isScalar, formatString, bestTickCount, tickValues, getValueFn, useTickIntervalForDisplayUnits, axisDisplayUnits, axisPrecision), axis = d3.svg.axis().scale(scale).tickSize(6, 0).orient(isVertical ? "left" : "bottom").ticks(bestTickCount).tickValues(tickValues), formattedTickValues = [];
                        metaDataColumn && (formattedTickValues = formatAxisTickValues(axis, tickValues, formatter, dataType, getValueFn));
                        var xLabelMaxWidth;
                        return !isScalar && categoryThickness ? xLabelMaxWidth = Math.max(1, categoryThickness - 2 * tickLabelPadding) : (xLabelMaxWidth = tickValues.length > 1 ? getScalarLabelMaxWidth(scale, tickValues) : pixelSpan, 
                        xLabelMaxWidth -= 2 * ScalarTickLabelPadding), {
                            scale: scale,
                            axis: axis,
                            formatter: formatter,
                            values: formattedTickValues,
                            axisType: dataType,
                            axisLabel: null,
                            isCategoryAxis: isCategoryAxis,
                            xLabelMaxWidth: xLabelMaxWidth,
                            categoryThickness: categoryThickness,
                            outerPadding: outerPadding,
                            usingDefaultDomain: scaleResult.usingDefaultDomain,
                            isLogScaleAllowed: isLogScaleAllowed,
                            dataDomain: dataDomain
                        };
                    }
                    function powerOfTen(d) {
                        var value = Math.abs(d), log10 = Math.log(value) / Math.LN10;
                        return log10 = Math.ceil(log10 - 1e-12), value / Math.pow(10, log10) === 1;
                    }
                    function getScalarLabelMaxWidth(scale, tickValues) {
                        return scale && !_.isEmpty(tickValues) ? Math.abs(scale(tickValues[1]) - scale(tickValues[0])) : 1;
                    }
                    function createFormatter(scaleDomain, dataDomain, dataType, isScalar, formatString, bestTickCount, tickValues, getValueFn, useTickIntervalForDisplayUnits, axisDisplayUnits, axisPrecision) {
                        void 0 === useTickIntervalForDisplayUnits && (useTickIntervalForDisplayUnits = !1);
                        var formatter;
                        if (dataType.dateTime) if (isScalar) {
                            var value = new Date(scaleDomain[0]), value2 = new Date(scaleDomain[1]);
                            1 === bestTickCount && (value = value2 = new Date(dataDomain[0])), formatter = valueFormatter.create({
                                format: formatString,
                                value: value,
                                value2: value2,
                                tickCount: bestTickCount
                            });
                        } else formatter = valueFormatter.createDefaultFormatter(formatString, !0); else if (useTickIntervalForDisplayUnits && isScalar && tickValues.length > 1) {
                            var value1 = axisDisplayUnits ? axisDisplayUnits : tickValues[1] - tickValues[0], options = {
                                format: formatString,
                                value: value1,
                                value2: 0,
                                allowFormatBeautification: !0
                            };
                            axisPrecision ? options.precision = axisPrecision : options.precision = visuals.AxisHelper.calculateAxisPrecision(tickValues[1] - tickValues[0], axisDisplayUnits, formatString), 
                            formatter = valueFormatter.create(options);
                        } else formatter = valueFormatter.createDefaultFormatter(formatString, !0);
                        return formatter;
                    }
                    function getMinTickValueInterval(formatString, columnType, is100Pct) {
                        var isCustomFormat = formatString && !NumberFormat.isStandardFormat(formatString);
                        if (isCustomFormat) {
                            var precision = NumberFormat.getCustomFormatMetadata(formatString, !0).precision;
                            return formatString.indexOf("%") > -1 && (precision += 2), Math.pow(10, -precision);
                        }
                        return is100Pct ? .01 : columnType.integer ? 1 : 0;
                    }
                    function formatAxisTickValues(axis, tickValues, formatter, dataType, getValueFn) {
                        var formattedTickValues = [];
                        return getValueFn || (getValueFn = function(data) {
                            return data;
                        }), formatter ? (axis.tickFormat(function(d) {
                            return formatter.format(getValueFn(d, dataType));
                        }), formattedTickValues = tickValues.map(function(d) {
                            return formatter.format(getValueFn(d, dataType));
                        })) : formattedTickValues = tickValues.map(function(d) {
                            return getValueFn(d, dataType);
                        }), formattedTickValues;
                    }
                    function isLogScalePossible(domain, axisType) {
                        return null != domain && (!isDateTime(axisType) && (domain[0] > 0 && domain[1] > 0 || domain[0] < 0 && domain[1] < 0));
                    }
                    function isDateTime(type) {
                        return !(!type || !type.dateTime);
                    }
                    function getRecommendedTickValues(maxTicks, scale, axisType, isScalar, minTickInterval) {
                        return !isScalar || isOrdinalScale(scale) ? getRecommendedTickValuesForAnOrdinalRange(maxTicks, scale.domain()) : isDateTime(axisType) ? getRecommendedTickValuesForADateTimeRange(maxTicks, scale.domain()) : getRecommendedTickValuesForAQuantitativeRange(maxTicks, scale, minTickInterval);
                    }
                    function getRecommendedTickValuesForAnOrdinalRange(maxTicks, labels) {
                        var tickLabels = [];
                        if (maxTicks <= 0) return tickLabels;
                        var len = labels.length;
                        if (maxTicks > len) return labels;
                        for (var i = 0, step = Math.ceil(len / maxTicks); i < len; i += step) tickLabels.push(labels[i]);
                        return tickLabels;
                    }
                    function getRecommendedTickValuesForAQuantitativeRange(maxTicks, scale, minInterval) {
                        var tickLabels = [];
                        if (0 === maxTicks) return tickLabels;
                        var quantitiveScale = scale;
                        if (quantitiveScale.ticks) {
                            if (tickLabels = quantitiveScale.ticks(maxTicks), tickLabels.length > maxTicks && maxTicks > 1 && (tickLabels = quantitiveScale.ticks(maxTicks - 1)), 
                            tickLabels.length < MinTickCount && (tickLabels = quantitiveScale.ticks(maxTicks + 1)), 
                            tickLabels = createTrueZeroTickLabel(tickLabels), minInterval && tickLabels.length > 1) {
                                for (var tickInterval = tickLabels[1] - tickLabels[0]; tickInterval > 0 && tickInterval < minInterval; ) {
                                    for (var i = 1; i < tickLabels.length; i++) tickLabels.splice(i, 1);
                                    tickInterval = 2 * tickInterval;
                                }
                                1 === tickLabels.length && tickLabels.push(tickLabels[0] + minInterval);
                            }
                            return tickLabels;
                        }
                        return tickLabels;
                    }
                    function getRecommendedTickValuesForADateTimeRange(maxTicks, dataDomain) {
                        var tickLabels = [];
                        if (0 === dataDomain[0] && 0 === dataDomain[1]) return [];
                        var dateTimeTickLabels = DateTimeSequence.calculate(new Date(dataDomain[0]), new Date(dataDomain[1]), maxTicks).sequence;
                        return tickLabels = dateTimeTickLabels.map(function(d) {
                            return d.getTime();
                        }), tickLabels = ensureValuesInRange(tickLabels, dataDomain[0], dataDomain[1]);
                    }
                    function isOrdinalScale(scale) {
                        return "undefined" == typeof scale.invert;
                    }
                    function getCategoryValueType(metadataColumn, isScalar) {
                        return metadataColumn && columnDataTypeHasValue(metadataColumn.type) ? metadataColumn.type : isScalar ? ValueType.fromDescriptor({
                            numeric: !0
                        }) : ValueType.fromDescriptor({
                            text: !0
                        });
                    }
                    function columnDataTypeHasValue(dataType) {
                        return dataType && (dataType.bool || dataType.numeric || dataType.text || dataType.dateTime);
                    }
                    function createScale(options) {
                        var pixelSpan = options.pixelSpan, dataDomain = options.dataDomain, metaDataColumn = options.metaDataColumn, outerPadding = options.outerPadding || 0, isScalar = !!options.isScalar, isVertical = !!options.isVertical, forcedTickCount = options.forcedTickCount, categoryThickness = options.categoryThickness, shouldClamp = !!options.shouldClamp, maxTickCount = options.maxTickCount, innerPaddingRatio = options.innerPaddingRatio || InnerPaddingRatio, minOrdinalRectThickness = options.minOrdinalRectThickness || MinOrdinalRectThickness, dataType = getCategoryValueType(metaDataColumn, isScalar), maxTicks = isVertical ? getRecommendedNumberOfTicksForYAxis(pixelSpan) : getRecommendedNumberOfTicksForXAxis(pixelSpan);
                        maxTickCount && maxTicks > maxTickCount && (maxTicks = maxTickCount);
                        var scale, scalarDomain = dataDomain ? dataDomain.slice() : null, bestTickCount = maxTicks, usingDefaultDomain = !1;
                        if (null == dataDomain || 2 === dataDomain.length && null == dataDomain[0] && null == dataDomain[1] || 2 !== dataDomain.length && isScalar) usingDefaultDomain = !0, 
                        dataDomain = dataType.dateTime || !isOrdinal(dataType) ? HistogramAxisHelper.emptyDomain : [], 
                        scale = isOrdinal(dataType) ? createOrdinalScale(pixelSpan, dataDomain, innerPaddingRatio, categoryThickness ? outerPadding / categoryThickness : 0) : createNumericalScale(options.scaleType, pixelSpan, dataDomain, dataType, outerPadding, bestTickCount); else {
                            if (isScalar && dataDomain.length > 0) {
                                bestTickCount = void 0 !== forcedTickCount ? 0 !== maxTicks ? forcedTickCount : 0 : getBestNumberOfTicks(dataDomain[0], dataDomain[dataDomain.length - 1], [ metaDataColumn ], maxTicks, dataType.dateTime);
                                var normalizedRange = normalizeLinearDomain({
                                    min: dataDomain[0],
                                    max: dataDomain[dataDomain.length - 1]
                                });
                                scalarDomain = [ normalizedRange.min, normalizedRange.max ];
                            }
                            isScalar && dataType.numeric && !dataType.dateTime ? (scale = createNumericalScale(options.scaleType, pixelSpan, scalarDomain, dataType, outerPadding, null, shouldClamp), 
                            bestTickCount = 0 === maxTicks ? 0 : Math.floor((pixelSpan - 2 * outerPadding) / minOrdinalRectThickness)) : isScalar && dataType.dateTime ? scale = createLinearScale(pixelSpan, scalarDomain, outerPadding, null, shouldClamp) : (dataType.text || dataType.dateTime || dataType.numeric || dataType.bool) && (scale = createOrdinalScale(pixelSpan, scalarDomain, innerPaddingRatio, categoryThickness ? outerPadding / categoryThickness : 0), 
                            bestTickCount = 0 === maxTicks ? 0 : Math.min(scalarDomain.length, (pixelSpan - 2 * outerPadding) / minOrdinalRectThickness));
                        }
                        return isVertical && isScalar && scale.range(scale.range().reverse()), normalizeInfinityInScale(scale), 
                        {
                            scale: scale,
                            bestTickCount: bestTickCount,
                            usingDefaultDomain: usingDefaultDomain
                        };
                    }
                    function normalizeInfinityInScale(scale) {
                        for (var scaledDomain = scale.domain(), i = 0, len = scaledDomain.length; i < len; ++i) scaledDomain[i] === Number.POSITIVE_INFINITY ? scaledDomain[i] = Number.MAX_VALUE : scaledDomain[i] === Number.NEGATIVE_INFINITY && (scaledDomain[i] = -Number.MAX_VALUE);
                        scale.domain(scaledDomain);
                    }
                    function createOrdinalScale(pixelSpan, dataDomain, innerPaddingRatio, outerPaddingRatio) {
                        var scale = d3.scale.ordinal().rangeBands([ 0, pixelSpan ], innerPaddingRatio, outerPaddingRatio).domain(dataDomain);
                        return scale;
                    }
                    function normalizeLinearDomain(domain) {
                        return isNaN(domain.min) || isNaN(domain.max) ? (domain.min = HistogramAxisHelper.emptyDomain[0], 
                        domain.max = HistogramAxisHelper.emptyDomain[1]) : domain.min === domain.max ? (domain.min = domain.min < 0 ? 1.2 * domain.min : .8 * domain.min, 
                        domain.max = domain.max < 0 ? .8 * domain.max : 1.2 * domain.max) : Math.abs(domain.min) < 1e-4 && domain.min / (domain.max - domain.min) < 1e-4 && (domain.min = 0), 
                        domain;
                    }
                    function createNumericalScale(axisScaleType, pixelSpan, dataDomain, dataType, outerPadding, niceCount, shouldClamp) {
                        return void 0 === outerPadding && (outerPadding = 0), axisScaleType === axisScale.log && isLogScalePossible(dataDomain, dataType) ? createLogScale(pixelSpan, dataDomain, outerPadding, niceCount) : createLinearScale(pixelSpan, dataDomain, outerPadding, niceCount, shouldClamp);
                    }
                    function createLogScale(pixelSpan, dataDomain, outerPadding, niceCount) {
                        void 0 === outerPadding && (outerPadding = 0);
                        var scale = d3.scale.log().range([ outerPadding, pixelSpan - outerPadding ]).domain([ dataDomain[0], dataDomain[1] ]).clamp(!0);
                        return niceCount && scale.nice(niceCount), scale;
                    }
                    function createLinearScale(pixelSpan, dataDomain, outerPadding, niceCount, shouldClamp) {
                        void 0 === outerPadding && (outerPadding = 0);
                        var scale = d3.scale.linear().range([ outerPadding, pixelSpan - outerPadding ]).domain([ dataDomain[0], dataDomain[1] ]).clamp(shouldClamp);
                        return niceCount && scale.nice(niceCount), scale;
                    }
                    function getRecommendedNumberOfTicksForXAxis(availableWidth) {
                        return availableWidth < 300 ? 3 : availableWidth < 500 ? 5 : 8;
                    }
                    function getRecommendedNumberOfTicksForYAxis(availableWidth) {
                        return availableWidth < 150 ? 3 : availableWidth < 300 ? 5 : 8;
                    }
                    function isOrdinal(type) {
                        return !(!type || !(type.text || type.bool || type.misc && type.misc.barcode || type.geography && type.geography.postalCode));
                    }
                    function getBestNumberOfTicks(min, max, valuesMetadata, maxTickCount, isDateTime) {
                        return isNaN(min) || isNaN(max) ? DefaultBestTickCount : maxTickCount <= 1 || max <= 1 && min >= -1 ? maxTickCount : min === max ? isDateTime ? 1 : DefaultBestTickCount : hasNonIntegerData(valuesMetadata) ? maxTickCount : Math.min(max - min + 1, maxTickCount);
                    }
                    function ensureValuesInRange(values, min, max) {
                        var filteredValues = values.filter(function(v) {
                            return v >= min && v <= max;
                        });
                        return filteredValues.length < 2 && (filteredValues = [ min, max ]), filteredValues;
                    }
                    function hasNonIntegerData(valuesMetadata) {
                        for (var i = 0, len = valuesMetadata.length; i < len; i++) {
                            var currentMetadata = valuesMetadata[i];
                            if (currentMetadata && currentMetadata.type && !currentMetadata.type.integer) return !0;
                        }
                        return !1;
                    }
                    function createTrueZeroTickLabel(ticks, epsilon) {
                        if (void 0 === epsilon && (epsilon = 1e-5), !ticks || ticks.length < 2) return ticks;
                        var closeZero = epsilon * Math.abs(ticks[1] - ticks[0]);
                        return ticks.map(function(tick) {
                            return Math.abs(tick) <= closeZero ? 0 : tick;
                        });
                    }
                    var NumberFormat = powerbi.NumberFormat;
                    HistogramAxisHelper.emptyDomain = [ 0, 0 ];
                    var InnerPaddingRatio = .2, TickLabelPadding = 2, MinOrdinalRectThickness = 20, ScalarTickLabelPadding = 3, MinTickCount = 2, DefaultBestTickCount = 3;
                    HistogramAxisHelper.createAxis = createAxis, HistogramAxisHelper.powerOfTen = powerOfTen, 
                    HistogramAxisHelper.createFormatter = createFormatter, HistogramAxisHelper.getMinTickValueInterval = getMinTickValueInterval, 
                    HistogramAxisHelper.isLogScalePossible = isLogScalePossible, HistogramAxisHelper.isDateTime = isDateTime, 
                    HistogramAxisHelper.getRecommendedTickValues = getRecommendedTickValues, HistogramAxisHelper.getRecommendedTickValuesForAnOrdinalRange = getRecommendedTickValuesForAnOrdinalRange, 
                    HistogramAxisHelper.getRecommendedTickValuesForAQuantitativeRange = getRecommendedTickValuesForAQuantitativeRange, 
                    HistogramAxisHelper.isOrdinalScale = isOrdinalScale, HistogramAxisHelper.getCategoryValueType = getCategoryValueType, 
                    HistogramAxisHelper.columnDataTypeHasValue = columnDataTypeHasValue, HistogramAxisHelper.createScale = createScale, 
                    HistogramAxisHelper.normalizeInfinityInScale = normalizeInfinityInScale, HistogramAxisHelper.createOrdinalScale = createOrdinalScale, 
                    HistogramAxisHelper.createNumericalScale = createNumericalScale, HistogramAxisHelper.createLinearScale = createLinearScale, 
                    HistogramAxisHelper.getRecommendedNumberOfTicksForXAxis = getRecommendedNumberOfTicksForXAxis, 
                    HistogramAxisHelper.getRecommendedNumberOfTicksForYAxis = getRecommendedNumberOfTicksForYAxis, 
                    HistogramAxisHelper.isOrdinal = isOrdinal, HistogramAxisHelper.getBestNumberOfTicks = getBestNumberOfTicks, 
                    HistogramAxisHelper.ensureValuesInRange = ensureValuesInRange, HistogramAxisHelper.hasNonIntegerData = hasNonIntegerData;
                }(HistogramAxisHelper = samples.HistogramAxisHelper || (samples.HistogramAxisHelper = {}));
                var HistogramBehavior = function() {
                    function HistogramBehavior() {}
                    return HistogramBehavior.create = function() {
                        return new HistogramBehavior();
                    }, HistogramBehavior.prototype.bindEvents = function(behaviorOptions, selectionHandler) {
                        var _this = this;
                        this.columns = behaviorOptions.columns, this.interactivityService = behaviorOptions.interactivityService, 
                        this.clearCatcher = behaviorOptions.clearCatcher, this.columns.on("click", function(dataPoint) {
                            selectionHandler.handleClearSelection(), HistogramBehavior.areDataPointsSelected(_this.selectedDataPoints, dataPoint.subDataPoints) ? _this.createAnEmptySelectedDataPoints() : (dataPoint.subDataPoints.forEach(function(subDataPoint) {
                                selectionHandler.handleSelection(subDataPoint, !0);
                            }), _this.selectedDataPoints = dataPoint.subDataPoints);
                        }), this.clearCatcher.on("click", function() {
                            selectionHandler.handleClearSelection(), _this.createAnEmptySelectedDataPoints();
                        });
                    }, HistogramBehavior.prototype.renderSelection = function(hasSelection) {
                        histogramUtils.updateFillOpacity(this.columns, this.interactivityService, hasSelection);
                    }, HistogramBehavior.areDataPointsSelected = function(selectedDataPoints, dataPoints) {
                        return !(!dataPoints || !selectedDataPoints || dataPoints.length !== selectedDataPoints.length) && selectedDataPoints.every(function(selectedDataPoint) {
                            return dataPoints.some(function(dataPoint) {
                                return selectedDataPoint && dataPoint && selectedDataPoint.identity && dataPoint.identity && selectedDataPoint.identity.equals(dataPoint.identity);
                            });
                        });
                    }, HistogramBehavior.prototype.createAnEmptySelectedDataPoints = function() {
                        this.selectedDataPoints = [];
                    }, HistogramBehavior;
                }();
                samples.HistogramBehavior = HistogramBehavior;
                var histogramUtils;
                !function(histogramUtils) {
                    function getFillOpacity(selected, highlight, hasSelection, hasPartialHighlights) {
                        return hasPartialHighlights && !highlight || hasSelection && !selected ? histogramUtils.DimmedOpacity : histogramUtils.DefaultOpacity;
                    }
                    function getStateOfDataPoint(dataPoint) {
                        var selected = !1, highlight = !1;
                        return dataPoint.subDataPoints && dataPoint.subDataPoints.length > 0 && dataPoint.subDataPoints.forEach(function(subDataPoint) {
                            selected = selected || subDataPoint.selected, highlight = highlight || subDataPoint.highlight;
                        }), {
                            selected: selected,
                            highlight: highlight
                        };
                    }
                    function updateFillOpacity(columns, interactivityService, hasSelection) {
                        void 0 === hasSelection && (hasSelection = !1);
                        var hasHighlights = !1;
                        interactivityService && (hasHighlights = interactivityService.hasSelection()), columns.style("fill-opacity", function(dataPoint) {
                            var selectedDataPoint = histogramUtils.getStateOfDataPoint(dataPoint);
                            return histogramUtils.getFillOpacity(selectedDataPoint.selected, selectedDataPoint.highlight, !selectedDataPoint.highlight && hasSelection, !selectedDataPoint.selected && hasHighlights);
                        });
                    }
                    histogramUtils.DimmedOpacity = .4, histogramUtils.DefaultOpacity = 1, histogramUtils.getFillOpacity = getFillOpacity, 
                    histogramUtils.getStateOfDataPoint = getStateOfDataPoint, histogramUtils.updateFillOpacity = updateFillOpacity;
                }(histogramUtils = samples.histogramUtils || (samples.histogramUtils = {}));
            }(samples = visuals.samples || (visuals.samples = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, jsCommon = window.jsCommon, powerbi = window.powerbi;
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var samples;
            !function(samples) {
                var getAnimationDuration = powerbi.visuals.AnimatorCommon.GetAnimationDuration, CreateClassAndSelector = jsCommon.CssConstants.createClassAndSelector, AxisScale = powerbi.visuals.axisScale, PixelConverter = jsCommon.PixelConverter, createEnumType = powerbi.createEnumType, SelectionId = powerbi.visuals.SelectionId, VisualDataRoleKind = powerbi.VisualDataRoleKind, dataLabelUtils = powerbi.visuals.dataLabelUtils, DataViewObjects = powerbi.DataViewObjects, SelectionIdBuilder = powerbi.visuals.SelectionIdBuilder, createInteractivityService = powerbi.visuals.createInteractivityService, appendClearCatcher = powerbi.visuals.appendClearCatcher, SVGUtil = powerbi.visuals.SVGUtil, ObjectEnumerationBuilder = powerbi.visuals.ObjectEnumerationBuilder, valueFormatter = powerbi.visuals.valueFormatter, TooltipManager = powerbi.visuals.TooltipManager, AxisHelper = powerbi.visuals.AxisHelper, TextMeasurementService = powerbi.TextMeasurementService, LabelTextProperties = powerbi.visuals.dataLabelUtils.LabelTextProperties, DefaultRadius = 5, DefaultStrokeWidth = 1;
                !function(DotPlotLabelsOrientation) {
                    DotPlotLabelsOrientation[DotPlotLabelsOrientation.Horizontal = "Horizontal"] = "Horizontal", 
                    DotPlotLabelsOrientation[DotPlotLabelsOrientation.Vertical = "Vertical"] = "Vertical";
                }(samples.DotPlotLabelsOrientation || (samples.DotPlotLabelsOrientation = {}));
                var DotPlotLabelsOrientation = samples.DotPlotLabelsOrientation, VisualLayout = function() {
                    function VisualLayout(defaultViewport, defaultMargin) {
                        this.defaultViewport = defaultViewport || {
                            width: 0,
                            height: 0
                        }, this.defaultMargin = defaultMargin || {
                            top: 0,
                            bottom: 0,
                            right: 0,
                            left: 0
                        };
                    }
                    return Object.defineProperty(VisualLayout.prototype, "viewport", {
                        get: function() {
                            return this.viewportValue || (this.viewportValue = this.defaultViewport);
                        },
                        set: function(value) {
                            var _this = this;
                            this.previousOriginalViewportValue = _.clone(this.originalViewportValue), this.originalViewportValue = _.clone(value), 
                            this.setUpdateObject(value, function(v) {
                                return _this.viewportValue = v;
                            }, function(o) {
                                return VisualLayout.restrictToMinMax(o, _this.minViewport);
                            });
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(VisualLayout.prototype, "viewportCopy", {
                        get: function() {
                            return _.clone(this.viewport);
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(VisualLayout.prototype, "viewportIn", {
                        get: function() {
                            return this.viewportInValue || this.viewport;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(VisualLayout.prototype, "minViewport", {
                        get: function() {
                            return this.minViewportValue || {
                                width: 0,
                                height: 0
                            };
                        },
                        set: function(value) {
                            var _this = this;
                            this.setUpdateObject(value, function(v) {
                                return _this.minViewportValue = v;
                            }, VisualLayout.restrictToMinMax);
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(VisualLayout.prototype, "margin", {
                        get: function() {
                            return this.marginValue || (this.marginValue = this.defaultMargin);
                        },
                        set: function(value) {
                            var _this = this;
                            this.setUpdateObject(value, function(v) {
                                return _this.marginValue = v;
                            }, VisualLayout.restrictToMinMax);
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(VisualLayout.prototype, "viewportChanged", {
                        get: function() {
                            return !(!this.originalViewportValue || this.previousOriginalViewportValue && this.previousOriginalViewportValue.height === this.originalViewportValue.height && this.previousOriginalViewportValue.width === this.originalViewportValue.width);
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(VisualLayout.prototype, "viewportInIsZero", {
                        get: function() {
                            return 0 === this.viewportIn.width || 0 === this.viewportIn.height;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), VisualLayout.prototype.resetMargin = function() {
                        this.margin = this.defaultMargin;
                    }, VisualLayout.prototype.update = function() {
                        this.viewportInValue = VisualLayout.restrictToMinMax({
                            width: this.viewport.width - (this.margin.left + this.margin.right),
                            height: this.viewport.height - (this.margin.top + this.margin.bottom)
                        }, this.minViewportValue);
                    }, VisualLayout.prototype.setUpdateObject = function(object, setObjectFn, beforeUpdateFn) {
                        var _this = this;
                        object = _.clone(object), setObjectFn(VisualLayout.createNotifyChangedObject(object, function(o) {
                            beforeUpdateFn && beforeUpdateFn(object), _this.update();
                        })), beforeUpdateFn && beforeUpdateFn(object), this.update();
                    }, VisualLayout.createNotifyChangedObject = function(object, objectChanged) {
                        var result = {};
                        return _.keys(object).forEach(function(key) {
                            return Object.defineProperty(result, key, {
                                get: function() {
                                    return object[key];
                                },
                                set: function(value) {
                                    object[key] = value, objectChanged(object, key);
                                },
                                enumerable: !0,
                                configurable: !0
                            });
                        }), result;
                    }, VisualLayout.restrictToMinMax = function(value, minValue) {
                        return _.keys(value).forEach(function(x) {
                            return value[x] = Math.max(minValue && minValue[x] || 0, value[x]);
                        }), value;
                    }, VisualLayout;
                }(), DotPlotSettings = function() {
                    function DotPlotSettings() {
                        this.categoryAxis = {
                            show: !0,
                            showAxisTitle: !0,
                            labelColor: dataLabelUtils.defaultLabelColor
                        }, this.dataPoint = {
                            fill: "#00B8AA"
                        }, this.labels = {
                            show: !0,
                            color: dataLabelUtils.defaultLabelColor,
                            labelDisplayUnits: 0,
                            labelPrecision: 2,
                            fontSize: dataLabelUtils.DefaultFontSizeInPt
                        };
                    }
                    return Object.defineProperty(DotPlotSettings, "Default", {
                        get: function() {
                            return new this();
                        },
                        enumerable: !0,
                        configurable: !0
                    }), DotPlotSettings.parse = function(dataView, capabilities) {
                        var settings = new this();
                        if (!dataView || !dataView.metadata || !dataView.metadata.objects) return settings;
                        var properties = this.getProperties(capabilities);
                        for (var objectKey in capabilities.objects) for (var propKey in capabilities.objects[objectKey].properties) if (settings[objectKey] && _.has(settings[objectKey], propKey)) {
                            var type = capabilities.objects[objectKey].properties[propKey].type, getValueFn = this.getValueFnByType(type);
                            settings[objectKey][propKey] = getValueFn(dataView.metadata.objects, properties[objectKey][propKey], settings[objectKey][propKey]);
                        }
                        return settings;
                    }, DotPlotSettings.getProperties = function(capabilities) {
                        var objects = _.merge({
                            general: {
                                properties: {
                                    formatString: {}
                                }
                            }
                        }, capabilities.objects), properties = {};
                        for (var objectKey in objects) {
                            properties[objectKey] = {};
                            for (var propKey in objects[objectKey].properties) properties[objectKey][propKey] = {
                                objectName: objectKey,
                                propertyName: propKey
                            };
                        }
                        return properties;
                    }, DotPlotSettings.createEnumTypeFromEnum = function(type) {
                        var even = !1;
                        return createEnumType(Object.keys(type).filter(function(key, i) {
                            return !!(i % 2) === even && type[key] === key && !void (even = !even) || !!(i % 2) !== even;
                        }).map(function(x) {
                            return {
                                value: x,
                                displayName: x
                            };
                        }));
                    }, DotPlotSettings.getValueFnByType = function(type) {
                        switch (_.keys(type)[0]) {
                          case "fill":
                            return DataViewObjects.getFillColor;

                          default:
                            return DataViewObjects.getValue;
                        }
                    }, DotPlotSettings.enumerateObjectInstances = function(settings, options, capabilities) {
                        void 0 === settings && (settings = new this());
                        var enumeration = new ObjectEnumerationBuilder(), object = settings && settings[options.objectName];
                        if (!object) return enumeration;
                        var instance = {
                            objectName: options.objectName,
                            selector: null,
                            properties: {}
                        };
                        for (var key in object) _.has(object, key) && (instance.properties[key] = object[key]);
                        return enumeration.pushInstance(instance), enumeration;
                    }, DotPlotSettings.prototype.createOriginalSettings = function() {
                        this.originalSettings = _.cloneDeep(this);
                    }, DotPlotSettings;
                }();
                samples.DotPlotSettings = DotPlotSettings;
                var DotPlot = function() {
                    function DotPlot(options) {
                        this.durationAnimations = 200, this.scaleType = AxisScale.linear, this.dotPlotSelectors = {
                            scrollableContainer: CreateClassAndSelector("dotPlotScrollableContainer"),
                            svgPlotSelector: CreateClassAndSelector("dotplot"),
                            plotSelector: CreateClassAndSelector("dotplotSelector"),
                            plotGroupSelector: CreateClassAndSelector("dotplotGroup"),
                            axisSelector: CreateClassAndSelector("axisGraphicsContext"),
                            xAxisSelector: CreateClassAndSelector("x axis"),
                            circleSeletor: CreateClassAndSelector("circleSelector")
                        }, options && (options.svg && (this.svg = options.svg), options.animator && (this.animator = options.animator), 
                        this.radius = options.radius || DefaultRadius, this.strokeWidth = options.strokeWidth || DefaultStrokeWidth);
                    }
                    return DotPlot.getCategoryTextProperties = function(text) {
                        return {
                            text: text,
                            fontFamily: "'Segoe UI',wf_segoe-ui_normal,helvetica,arial,sans-serif",
                            fontSize: PixelConverter.toString(11)
                        };
                    }, DotPlot.getValueTextProperties = function(fontSize, text) {
                        return {
                            text: text,
                            fontFamily: "'Segoe UI',wf_segoe-ui_normal,helvetica,arial,sans-serif",
                            fontSize: PixelConverter.toString(fontSize)
                        };
                    }, Object.defineProperty(DotPlot.prototype, "settings", {
                        get: function() {
                            return this.data && this.data.settings;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), DotPlot.getTooltipData = function(value) {
                        return [ {
                            displayName: "Value",
                            value: value.toString()
                        } ];
                    }, DotPlot.converter = function(dataView, height, colors, radius) {
                        if (!dataView || !dataView.categorical || _.isEmpty(dataView.categorical.values) || _.isEmpty(dataView.categorical.categories)) return null;
                        for (var properties = DotPlotSettings.getProperties(this.capabilities), settings = this.parseSettings(dataView), categoryColumn = dataView.categorical.categories[0], valueColumn = dataView.categorical.values[0], valueValues = valueColumn.values.map(function(x) {
                            return x || 0;
                        }), minValue = _.min(valueValues), maxValue = _.max(valueValues), valuesFormatter = valueFormatter.create({
                            format: valueFormatter.getFormatString(valueColumn.source, properties.general.formatString),
                            precision: settings.labels.labelPrecision,
                            value: settings.labels.labelDisplayUnits || maxValue
                        }), formattedValues = valueValues.map(valuesFormatter.format), categoriesFormatter = valueFormatter.create({
                            format: valueFormatter.getFormatString(categoryColumn.source, properties.general.formatString)
                        }), categories = categoryColumn.values.map(function(x, i) {
                            return {
                                value: categoriesFormatter.format(x),
                                selectionId: SelectionId.createWithId(categoryColumn.identity[i])
                            };
                        }), labelFontSize = PixelConverter.fromPointToPixel(settings.labels.fontSize), categoryLabelHeight = 15, maxXAxisHeight = (settings.categoryAxis.show ? 20 : 0) + (settings.categoryAxis.showAxisTitle ? categoryLabelHeight : 0), maxCategoryLength = _.max(categories.map(function(x) {
                            return x.value.length;
                        })), maxCategoryWidth = maxCategoryLength * TextMeasurementService.measureSvgTextWidth(DotPlot.getCategoryTextProperties("W")), maxLabelLength = _.max(formattedValues.map(function(x) {
                            return x.length;
                        })), maxLabelWidth = Math.max(70, maxLabelLength * TextMeasurementService.measureSvgTextWidth(DotPlot.getValueTextProperties(labelFontSize, "0")) * .8), diameter = 2 * radius + 1, dotsTotalHeight = height - maxXAxisHeight - 2 * radius - labelFontSize, maxDots = Math.floor(dotsTotalHeight / diameter), yScale = d3.scale.linear().domain([ 0, maxDots ]).range([ dotsTotalHeight, 0 ]), dataPointsGroup = [], color = settings.dataPoint.fill, minDots = minValue / (maxValue / maxDots), dotScale = d3.scale.log().domain([ minValue < 0 ? 1 : minValue, maxValue ]).range([ minDots <= 0 ? 1 : minDots, maxDots ]).clamp(!0), vi = 0, length = valueValues.length; vi < length; vi++) {
                            for (var value = valueValues[vi], scaledValue = dotScale(value), dataPoints = [], level = 0; level < scaledValue && maxDots > 0; level++) dataPoints.push({
                                y: yScale(level),
                                tooltipInfo: DotPlot.getTooltipData(value.toFixed(settings.labels.labelPrecision).toString())
                            });
                            var categorySelectionId = SelectionIdBuilder.builder().withCategory(categoryColumn, vi).createSelectionId(), tooltipInfo = DotPlot.getTooltipData(value.toFixed(settings.labels.labelPrecision));
                            dataPointsGroup.push({
                                category: categories[vi],
                                selected: !1,
                                value: value,
                                label: formattedValues[vi],
                                color: color,
                                identity: categorySelectionId,
                                tooltipInfo: tooltipInfo,
                                dataPoints: dataPoints,
                                highlight: !1,
                                index: dataPointsGroup.length,
                                labelFontSize: labelFontSize + "px"
                            });
                        }
                        return {
                            dataGroups: dataPointsGroup,
                            categoryAxisName: categoryColumn.source.displayName,
                            categoryColumn: categoryColumn,
                            settings: settings,
                            maxXAxisHeight: maxXAxisHeight,
                            labelFontSize: labelFontSize,
                            categoryLabelHeight: categoryLabelHeight,
                            dotsTotalHeight: dotsTotalHeight,
                            maxLabelWidth: maxLabelWidth,
                            maxCategoryWidth: maxCategoryWidth
                        };
                    }, DotPlot.parseSettings = function(dataView) {
                        var settings = DotPlotSettings.parse(dataView, this.capabilities);
                        return settings.labels.labelPrecision = Math.min(Math.max(0, settings.labels.labelPrecision), 17), 
                        settings.createOriginalSettings(), settings;
                    }, DotPlot.prototype.init = function(options) {
                        var element = options.element;
                        this.behavior = new DotplotBehavior(), this.interactivityService = createInteractivityService(options.host), 
                        this.radius = DefaultRadius, this.strokeWidth = DefaultStrokeWidth, this.colors = options.style.colorPalette.dataColors, 
                        this.layout = new VisualLayout(options.viewport, {
                            top: 5,
                            bottom: 15,
                            right: 0,
                            left: 0
                        }), this.divContainer = d3.select(element.get(0)).append("div").classed(this.dotPlotSelectors.scrollableContainer.class, !0), 
                        this.svg = this.divContainer.append("svg").classed(this.dotPlotSelectors.svgPlotSelector.class, !0), 
                        this.clearCatcher = appendClearCatcher(this.svg);
                        var axisGraphicsContext = this.svg.append("g").classed(this.dotPlotSelectors.axisSelector.class, !0);
                        this.dotPlot = this.svg.append("g").classed(this.dotPlotSelectors.plotSelector.class, !0), 
                        this.xAxisSelection = axisGraphicsContext.append("g").classed(this.dotPlotSelectors.xAxisSelector.class, !0);
                    }, DotPlot.prototype.update = function(options) {
                        if (options.dataViews && options.dataViews[0]) {
                            this.layout.viewport = options.viewport;
                            var data = DotPlot.converter(options.dataViews[0], this.layout.viewportIn.height, this.colors, this.radius);
                            if (!data) return void this.clear();
                            if (this.data = data, this.durationAnimations = getAnimationDuration(this.animator, options.suppressAnimations), 
                            this.dataViewport = {
                                height: this.layout.viewportIn.height,
                                width: Math.max(this.layout.viewportIn.width, this.data.dataGroups.length * (2 * this.radius + 2) + this.data.maxLabelWidth)
                            }, this.svg.style({
                                height: PixelConverter.toString(this.dataViewport.height),
                                width: PixelConverter.toString(this.dataViewport.width)
                            }), this.divContainer.style({
                                width: this.layout.viewport.width + "px",
                                height: this.layout.viewport.height + "px"
                            }), this.interactivityService && this.interactivityService.applySelectionStateToData(this.data.dataGroups), 
                            this.calculateAxes(!1), this.renderAxis(this.durationAnimations), this.drawDotPlot(), 
                            this.settings.labels.show) {
                                var layout = this.getDotPlotLabelsLayout(), labels = dataLabelUtils.drawDefaultLabelsForDataPointChart(this.data.dataGroups, this.svg, layout, this.dataViewport, !options.suppressAnimations, this.durationAnimations);
                                labels && labels.attr("transform", function(dataGroup) {
                                    var size = dataGroup.size;
                                    if (DotPlot.DefaultValues.labelOrientation === DotPlotLabelsOrientation.Vertical) {
                                        var px = dataGroup.anchorPoint.x, py = dataGroup.anchorPoint.y, dx = size.width / DotPlot.DataLabelXOffset + size.height * DotPlot.DataLabelXOffsetIndex, dy = size.height + size.height / DotPlot.DataLabelYOffset;
                                        return SVGUtil.translateAndRotate(dx, -dy, px, py, DotPlot.DataLabelAngle);
                                    }
                                    var dx = size.width / DotPlot.DataLabelXOffset, dy = size.height / DotPlot.DataLabelYOffset;
                                    return SVGUtil.translate(dx, dy);
                                });
                            } else dataLabelUtils.cleanDataLabels(this.svg);
                        }
                    }, DotPlot.prototype.enumerateObjectInstances = function(options) {
                        if (!this.settings || !this.settings.originalSettings) return [];
                        var enumeration = DotPlotSettings.enumerateObjectInstances(this.settings.originalSettings, options, DotPlot.capabilities);
                        return enumeration.complete();
                    }, DotPlot.prototype.drawDotPlot = function() {
                        var _this = this, dotGroupSelection = this.dotPlot.selectAll(this.dotPlotSelectors.plotGroupSelector.selector).data(this.data.dataGroups), hasSelection = this.interactivityService && this.interactivityService.hasSelection();
                        dotGroupSelection.enter().append("g").classed(this.dotPlotSelectors.plotGroupSelector.class, !0), 
                        dotGroupSelection.attr({
                            transform: function(d) {
                                return SVGUtil.translate(_this.getXDotPositionByIndex(d.index), _this.layout.margin.top + _this.data.labelFontSize);
                            },
                            stroke: "black",
                            "stroke-width": this.strokeWidth
                        }).style("fill-opacity", function(item) {
                            return dotPlotUtils.getFillOpacity(item.selected, item.highlight, hasSelection, !1);
                        });
                        var circleSelection = dotGroupSelection.selectAll(this.dotPlotSelectors.circleSeletor.selector).data(function(d) {
                            return d.dataPoints;
                        });
                        circleSelection.enter().append("circle").classed(this.dotPlotSelectors.circleSeletor.class, !0), 
                        circleSelection.attr({
                            cy: function(point) {
                                return point.y;
                            },
                            r: this.radius,
                            fill: this.settings.dataPoint.fill
                        }), this.renderTooltip(dotGroupSelection), circleSelection.exit().remove(), dotGroupSelection.exit().remove();
                        var interactivityService = this.interactivityService;
                        if (interactivityService) {
                            interactivityService.applySelectionStateToData(this.data.dataGroups);
                            var behaviorOptions = {
                                columns: dotGroupSelection,
                                clearCatcher: this.clearCatcher,
                                interactivityService: this.interactivityService
                            };
                            interactivityService.bind(this.data.dataGroups, this.behavior, behaviorOptions);
                        }
                    }, DotPlot.prototype.getXDotPositionByIndex = function(index) {
                        var scale = this.xAxisProperties.scale;
                        return this.data.maxLabelWidth / 2 + scale(index);
                    }, DotPlot.prototype.getDotPlotLabelsLayout = function() {
                        var _this = this;
                        return {
                            labelText: function(dataGroup) {
                                return dataLabelUtils.getLabelFormattedText({
                                    label: dataGroup.label,
                                    fontSize: parseFloat(_this.settings.labels.fontSize),
                                    maxWidth: _this.dataViewport.width
                                });
                            },
                            labelLayout: {
                                x: function(dataGroup) {
                                    var x = _this.getXDotPositionByIndex(dataGroup.index), dx = dataGroup.size.width / DotPlot.DataLabelXOffset;
                                    return x - dx;
                                },
                                y: function(dataGroup) {
                                    var y = (_.isEmpty(dataGroup.dataPoints) ? _this.data.dotsTotalHeight + 2 * _this.radius : _.last(dataGroup.dataPoints).y) + _this.data.labelFontSize, dy = dataGroup.size.height;
                                    return y - dy;
                                }
                            },
                            filter: function(dataGroup) {
                                return !!(dataGroup && dataGroup.dataPoints && _this.layout.viewportIn.height - _this.data.maxXAxisHeight + 2 * _this.radius > _this.data.labelFontSize);
                            },
                            style: {
                                fill: this.settings.labels.color,
                                "font-size": this.data.labelFontSize + "px",
                                "font-family": LabelTextProperties.fontFamily
                            }
                        };
                    }, DotPlot.prototype.clear = function() {
                        this.dotPlot.selectAll("*").remove(), this.xAxisSelection.selectAll("*").remove(), 
                        dataLabelUtils.cleanDataLabels(this.svg);
                    }, DotPlot.prototype.renderTooltip = function(selection) {
                        TooltipManager.addTooltip(selection, function(tooltipEvent) {
                            return tooltipEvent.data.tooltipInfo;
                        });
                    }, DotPlot.prototype.calculateAxes = function(scrollbarVisible) {
                        var _this = this, pixelSpan = this.dataViewport.width - this.data.maxLabelWidth, xAxisProperties = AxisHelper.createAxis({
                            pixelSpan: pixelSpan,
                            dataDomain: [ 0, this.data.dataGroups.length - 1 ],
                            metaDataColumn: null,
                            formatString: null,
                            outerPadding: 0,
                            isScalar: !0,
                            isVertical: !1,
                            forcedTickCount: Math.min(this.data.dataGroups.length, Math.floor((pixelSpan + this.data.maxCategoryWidth) / Math.min(55, this.data.maxCategoryWidth))),
                            useTickIntervalForDisplayUnits: !0,
                            isCategoryAxis: !1,
                            scaleType: this.scaleType,
                            axisDisplayUnits: 0
                        }), scale = xAxisProperties.axis.scale();
                        scale.domain([ 0, this.data.dataGroups.length - 1 ]);
                        var tickValues = xAxisProperties.axis.tickValues().filter(function(x) {
                            return x < _this.data.dataGroups.length;
                        });
                        xAxisProperties.axis.tickValues(tickValues);
                        var tickWidth = (tickValues.length > 1 ? scale(tickValues[1]) - scale(tickValues[0]) : pixelSpan) - 3;
                        xAxisProperties.axis.tickFormat(function(index) {
                            if (!_this.settings.categoryAxis.show || !_this.data.dataGroups[index]) return "";
                            var textProperties = DotPlot.getCategoryTextProperties(_this.data.dataGroups[index].category.value);
                            return TextMeasurementService.getTailoredTextOrDefault(textProperties, tickWidth);
                        }), this.settings.categoryAxis.show && (xAxisProperties.axisLabel = this.data.categoryAxisName), 
                        this.xAxisProperties = xAxisProperties;
                    }, DotPlot.prototype.renderAxis = function(duration) {
                        var _this = this, height = this.dataViewport.height - this.data.maxXAxisHeight;
                        this.xAxisSelection.attr({
                            transform: SVGUtil.translate(this.data.maxLabelWidth / 2, height)
                        });
                        var xAxis = this.xAxisProperties.axis.orient("bottom");
                        if (this.xAxisSelection.transition().duration(duration).call(xAxis).selectAll("g.tick text").style("fill", this.settings.categoryAxis.labelColor), 
                        this.xAxisSelection.selectAll(".tick text").append("title").text(function(index) {
                            return _this.data.dataGroups[index] && _this.data.dataGroups[index].category.value;
                        }), this.xAxisSelection.selectAll("line").style("opacity", this.settings.categoryAxis.show ? 1 : 0), 
                        this.xAxisSelection.selectAll(".xAxisLabel").remove(), this.settings.categoryAxis.showAxisTitle) {
                            var titleWidth = TextMeasurementService.measureSvgTextWidth(DotPlot.getCategoryTextProperties(this.data.categoryAxisName));
                            this.xAxisSelection.append("text").text(this.data.categoryAxisName).style("text-anchor", "middle").attr("class", "xAxisLabel").style("fill", this.settings.categoryAxis.labelColor).attr("transform", SVGUtil.translate(this.dataViewport.width / 2 - titleWidth / 2, this.data.maxXAxisHeight - this.data.categoryLabelHeight + 13));
                        }
                    }, DotPlot.DataLabelXOffset = 2, DotPlot.DataLabelYOffset = 1.5, DotPlot.DataLabelAngle = -90, 
                    DotPlot.DataLabelXOffsetIndex = .3, DotPlot.capabilities = {
                        dataRoles: [ {
                            name: "Category",
                            kind: VisualDataRoleKind.Grouping,
                            displayName: "Category"
                        }, {
                            name: "Values",
                            kind: VisualDataRoleKind.Measure,
                            displayName: "Values"
                        } ],
                        dataViewMappings: [ {
                            conditions: [ {
                                Category: {
                                    max: 1
                                },
                                Values: {
                                    max: 1
                                }
                            } ],
                            categorical: {
                                categories: {
                                    for: {
                                        in: "Category"
                                    },
                                    dataReductionAlgorithm: {
                                        top: {}
                                    }
                                },
                                values: {
                                    group: {
                                        by: "Series",
                                        select: [ {
                                            for: {
                                                in: "Values"
                                            }
                                        } ],
                                        dataReductionAlgorithm: {
                                            top: {}
                                        }
                                    }
                                }
                            }
                        } ],
                        objects: {
                            general: {
                                displayName: "General",
                                properties: {
                                    formatString: {
                                        type: {
                                            formatting: {
                                                formatString: !0
                                            }
                                        }
                                    }
                                }
                            },
                            categoryAxis: {
                                displayName: "X-Axis",
                                properties: {
                                    show: {
                                        displayName: "Show",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    showAxisTitle: {
                                        displayName: "Title",
                                        description: "Title options",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    labelColor: {
                                        displayName: "Label color",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    }
                                }
                            },
                            dataPoint: {
                                displayName: "Data colors",
                                properties: {
                                    fill: {
                                        displayName: "Fill",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    }
                                }
                            },
                            labels: {
                                displayName: "Data labels",
                                description: "Display data label options",
                                properties: {
                                    show: {
                                        displayName: "Show",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    color: {
                                        displayName: "Color",
                                        description: "Select color for data labels",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    labelDisplayUnits: {
                                        displayName: "Display units",
                                        description: "Select the units (millions, billions, etc.)",
                                        type: {
                                            formatting: {
                                                labelDisplayUnits: !0
                                            }
                                        },
                                        suppressFormatPainterCopy: !0
                                    },
                                    labelPrecision: {
                                        displayName: "Decimal places",
                                        description: "Select the number of decimal places to display",
                                        placeHolderText: "Auto",
                                        type: {
                                            numeric: !0
                                        },
                                        suppressFormatPainterCopy: !0
                                    },
                                    fontSize: {
                                        displayName: "Text Size",
                                        type: {
                                            formatting: {
                                                fontSize: !0
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }, DotPlot.DefaultValues = {
                        labelOrientation: DotPlotLabelsOrientation.Horizontal
                    }, DotPlot;
                }();
                samples.DotPlot = DotPlot;
                var DotplotBehavior = function() {
                    function DotplotBehavior() {}
                    return DotplotBehavior.prototype.bindEvents = function(options, selectionHandler) {
                        this.columns = options.columns, this.clearCatcher = options.clearCatcher, this.interactivityService = options.interactivityService, 
                        this.columns.on("click", function(d, i) {
                            selectionHandler.handleSelection(d, d3.event.ctrlKey);
                        }), options.clearCatcher.on("click", function() {
                            selectionHandler.handleClearSelection();
                        });
                    }, DotplotBehavior.prototype.renderSelection = function(hasSelection) {
                        var hasHighlights = this.interactivityService.hasSelection();
                        this.columns.style("fill-opacity", function(d) {
                            return dotPlotUtils.getFillOpacity(d.selected, d.highlight, !d.highlight && hasSelection, !d.selected && hasHighlights);
                        });
                    }, DotplotBehavior;
                }();
                samples.DotplotBehavior = DotplotBehavior;
                var dotPlotUtils;
                !function(dotPlotUtils) {
                    function getFillOpacity(selected, highlight, hasSelection, hasPartialHighlights) {
                        return hasPartialHighlights && !highlight || hasSelection && !selected ? dotPlotUtils.DimmedOpacity : dotPlotUtils.DefaultOpacity;
                    }
                    dotPlotUtils.DimmedOpacity = .4, dotPlotUtils.DefaultOpacity = 1, dotPlotUtils.getFillOpacity = getFillOpacity;
                }(dotPlotUtils = samples.dotPlotUtils || (samples.dotPlotUtils = {}));
            }(samples = visuals.samples || (visuals.samples = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, jsCommon = window.jsCommon, powerbi = window.powerbi;
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var samples;
            !function(samples) {
                var PixelConverter = jsCommon.PixelConverter, createEnumType = powerbi.createEnumType, DataViewObjects = powerbi.DataViewObjects, ObjectEnumerationBuilder = powerbi.visuals.ObjectEnumerationBuilder, dataLabelUtils = powerbi.visuals.dataLabelUtils, VisualDataRoleKind = powerbi.VisualDataRoleKind, valueFormatter = powerbi.visuals.valueFormatter, TooltipManager = powerbi.visuals.TooltipManager, hasRole = powerbi.data.DataRoleHelper.hasRole;
                !function(LinkColorType) {
                    LinkColorType[LinkColorType.ByWeight = "By Weight"] = "ByWeight", LinkColorType[LinkColorType.ByLinkType = "By Link Type"] = "ByLinkType", 
                    LinkColorType[LinkColorType.Interactive = "Interactive"] = "Interactive";
                }(samples.LinkColorType || (samples.LinkColorType = {}));
                var LinkColorType = samples.LinkColorType, ForceGraphSettings = function() {
                    function ForceGraphSettings() {
                        this.labels = {
                            show: !0,
                            color: dataLabelUtils.defaultLabelColor,
                            fontSize: dataLabelUtils.DefaultFontSizeInPt
                        }, this.links = {
                            showArrow: !1,
                            showLabel: !1,
                            colorLink: LinkColorType.Interactive,
                            thickenLink: !0,
                            displayUnits: 0,
                            decimalPlaces: null
                        }, this.nodes = {
                            displayImage: !1,
                            defaultImage: "Home",
                            imageUrl: "",
                            imageExt: ".png",
                            nameMaxLength: 10,
                            highlightReachableLinks: !1
                        }, this.size = {
                            charge: -15
                        };
                    }
                    return Object.defineProperty(ForceGraphSettings, "Default", {
                        get: function() {
                            return new this();
                        },
                        enumerable: !0,
                        configurable: !0
                    }), ForceGraphSettings.parse = function(dataView, capabilities) {
                        var settings = new this();
                        if (!dataView || !dataView.metadata || !dataView.metadata.objects) return settings;
                        var properties = this.getProperties(capabilities);
                        for (var objectKey in capabilities.objects) for (var propKey in capabilities.objects[objectKey].properties) if (settings[objectKey] && _.has(settings[objectKey], propKey)) {
                            var type = capabilities.objects[objectKey].properties[propKey].type, getValueFn = this.getValueFnByType(type);
                            settings[objectKey][propKey] = getValueFn(dataView.metadata.objects, properties[objectKey][propKey], settings[objectKey][propKey]);
                        }
                        return settings;
                    }, ForceGraphSettings.getProperties = function(capabilities) {
                        var properties = {};
                        for (var objectKey in capabilities.objects) {
                            properties[objectKey] = {};
                            for (var propKey in capabilities.objects[objectKey].properties) properties[objectKey][propKey] = {
                                objectName: objectKey,
                                propertyName: propKey
                            };
                        }
                        return properties;
                    }, ForceGraphSettings.createEnumTypeFromEnum = function(type) {
                        var even = !1;
                        return createEnumType(Object.keys(type).filter(function(key, i) {
                            return !!(i % 2) === even && type[key] === key && !void (even = !even) || !!(i % 2) !== even;
                        }).map(function(x) {
                            return {
                                value: x,
                                displayName: x
                            };
                        }));
                    }, ForceGraphSettings.getValueFnByType = function(type) {
                        switch (_.keys(type)[0]) {
                          case "fill":
                            return DataViewObjects.getFillColor;

                          default:
                            return DataViewObjects.getValue;
                        }
                    }, ForceGraphSettings.enumerateObjectInstances = function(settings, options, capabilities) {
                        var enumeration = new ObjectEnumerationBuilder(), object = settings && settings[options.objectName];
                        if (!object) return enumeration.complete();
                        var instance = {
                            objectName: options.objectName,
                            selector: null,
                            properties: {}
                        };
                        for (var key in object) _.has(object, key) && (instance.properties[key] = object[key]);
                        return enumeration.pushInstance(instance), enumeration.complete();
                    }, ForceGraphSettings;
                }();
                samples.ForceGraphSettings = ForceGraphSettings;
                var ForceGraphTooltipsFactory = function() {
                    function ForceGraphTooltipsFactory() {}
                    return ForceGraphTooltipsFactory.build = function(inputObject, dataViewMetadataColumns, formatStringProperties) {
                        var tooltips = [];
                        if (!inputObject) return tooltips;
                        for (var propertyName in inputObject) {
                            var column, value;
                            column = ForceGraphMetadataRoleHelper.getColumnByRoleName(dataViewMetadataColumns, propertyName), 
                            column && column.displayName && (value = inputObject[propertyName], formatStringProperties && !_.isNumber(value) && (value = valueFormatter.format(value, valueFormatter.getFormatString(column, formatStringProperties))), 
                            tooltips.push({
                                displayName: column.displayName,
                                value: value
                            }));
                        }
                        return tooltips;
                    }, ForceGraphTooltipsFactory;
                }();
                samples.ForceGraphTooltipsFactory = ForceGraphTooltipsFactory;
                var ForceGraphMetadataRoleHelper = function() {
                    function ForceGraphMetadataRoleHelper() {}
                    return ForceGraphMetadataRoleHelper.getColumnByRoleName = function(dataViewMetadataColumns, roleName) {
                        if (!_.isEmpty(dataViewMetadataColumns) && roleName) for (var i = 0, length = dataViewMetadataColumns.length; i < length; i++) {
                            var column = dataViewMetadataColumns[i];
                            if (column && hasRole(column, roleName)) return column;
                        }
                        return null;
                    }, ForceGraphMetadataRoleHelper;
                }();
                samples.ForceGraphMetadataRoleHelper = ForceGraphMetadataRoleHelper;
                var ForceGraphColumns = function() {
                    function ForceGraphColumns() {
                        this.Source = null, this.Target = null, this.Weight = null, this.LinkType = null, 
                        this.SourceType = null, this.TargetType = null;
                    }
                    return ForceGraphColumns.getMetadataColumns = function(dataView) {
                        var columns = dataView && dataView.metadata && dataView.metadata.columns;
                        return columns && _.mapValues(new ForceGraphColumns(), function(n, i) {
                            return columns.filter(function(x) {
                                return x.roles && x.roles[i];
                            })[0];
                        });
                    }, ForceGraphColumns.getTableValues = function(dataView) {
                        var table = dataView && dataView.table, columns = this.getMetadataColumns(dataView);
                        return columns && table && _.mapValues(columns, function(n, i) {
                            return n && table.rows.map(function(row) {
                                return row[n.index];
                            });
                        });
                    }, ForceGraphColumns.getTableRows = function(dataView) {
                        var table = dataView && dataView.table, columns = this.getMetadataColumns(dataView);
                        return columns && table && table.rows.map(function(row) {
                            return _.mapValues(columns, function(n, i) {
                                return n && row[n.index];
                            });
                        });
                    }, ForceGraphColumns.Roles = Object.freeze(_.mapValues(new ForceGraphColumns(), function(x, i) {
                        return i;
                    })), ForceGraphColumns;
                }();
                samples.ForceGraphColumns = ForceGraphColumns;
                var ForceGraph = function() {
                    function ForceGraph() {
                        this.uniqieId = "_" + ForceGraph.Count++ + "_";
                    }
                    return Object.defineProperty(ForceGraph, "Href", {
                        get: function() {
                            return window.location.href.replace(window.location.hash, "");
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(ForceGraph.prototype, "settings", {
                        get: function() {
                            return this.data && this.data.settings;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(ForceGraph.prototype, "margin", {
                        get: function() {
                            return this.marginValue || {
                                left: 0,
                                right: 0,
                                top: 0,
                                bottom: 0
                            };
                        },
                        set: function(value) {
                            this.marginValue = $.extend({}, value), this.viewportInValue = ForceGraph.substractMargin(this.viewport, this.margin);
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(ForceGraph.prototype, "viewport", {
                        get: function() {
                            return this.viewportValue || {
                                width: 0,
                                height: 0
                            };
                        },
                        set: function(value) {
                            this.viewportValue = $.extend({}, value), this.viewportInValue = ForceGraph.substractMargin(this.viewport, this.margin);
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(ForceGraph.prototype, "viewportIn", {
                        get: function() {
                            return this.viewportInValue || this.viewport;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), ForceGraph.substractMargin = function(viewport, margin) {
                        return {
                            width: Math.max(viewport.width - (margin.left + margin.right), 0),
                            height: Math.max(viewport.height - (margin.top + margin.bottom), 0)
                        };
                    }, ForceGraph.prototype.scale1to10 = function(d) {
                        var scale = d3.scale.linear().domain([ this.data.minFiles, this.data.maxFiles ]).rangeRound([ 1, 10 ]).clamp(!0);
                        return scale(d);
                    }, ForceGraph.prototype.getLinkColor = function(d) {
                        switch (this.settings.links.colorLink) {
                          case LinkColorType.ByWeight:
                            return this.colors.getColorByIndex(this.scale1to10(d.weight)).value;

                          case LinkColorType.ByLinkType:
                            return d.type && this.data.linkTypes[d.type] ? this.data.linkTypes[d.type].color : ForceGraph.DefaultValues.defaultLinkColor;
                        }
                        return ForceGraph.DefaultValues.defaultLinkColor;
                    }, ForceGraph.prototype.enumerateObjectInstances = function(options) {
                        return ForceGraphSettings.enumerateObjectInstances(this.settings, options, ForceGraph.capabilities);
                    }, ForceGraph.converter = function(dataView, colors) {
                        var settings = ForceGraph.parseSettings(dataView), nodes = {}, minFiles = Number.MAX_VALUE, maxFiles = 0, linkedByName = {}, links = [], linkDataPoints = {}, linkTypeCount = 0, tooltipInfo = [], metadata = ForceGraphColumns.getMetadataColumns(dataView);
                        if (!metadata || !metadata.Source || !metadata.Target) return null;
                        var tableRows = ForceGraphColumns.getTableRows(dataView), formatStringProp = ForceGraphSettings.getProperties(ForceGraph.capabilities).general.formatString, weightFormatter = metadata.Weight && valueFormatter.create({
                            format: valueFormatter.getFormatString(metadata.Weight, formatStringProp, !0),
                            precision: settings.links.decimalPlaces,
                            value: settings.links.displayUnits || _.max(tableRows, function(x) {
                                return x.Weight;
                            }).Weight
                        }), sourceFormatter = valueFormatter.create({
                            format: valueFormatter.getFormatString(metadata.Source, formatStringProp, !0)
                        }), targetFormatter = valueFormatter.create({
                            format: valueFormatter.getFormatString(metadata.Target, formatStringProp, !0)
                        });
                        return tableRows.forEach(function(tableRow) {
                            linkedByName[tableRow.Source + "," + tableRow.Target] = 1;
                            var source = nodes[tableRow.Source] || (nodes[tableRow.Source] = {
                                name: sourceFormatter.format(tableRow.Source),
                                image: tableRow.SourceType || "",
                                adj: {}
                            }), target = nodes[tableRow.Target] || (nodes[tableRow.Target] = {
                                name: targetFormatter.format(tableRow.Target),
                                image: tableRow.TargetType || "",
                                adj: {}
                            });
                            source.adj[target.name] = 1, target.adj[source.name] = 1, tooltipInfo = ForceGraphTooltipsFactory.build(tableRow, dataView.metadata.columns, formatStringProp);
                            var link = {
                                source: source,
                                target: target,
                                weight: Math.max(metadata.Weight ? tableRow.Weight || 0 : 1, 0),
                                formattedWeight: tableRow.Weight && weightFormatter.format(tableRow.Weight),
                                type: tableRow.LinkType || "",
                                tooltipInfo: tooltipInfo
                            };
                            metadata.LinkType && !linkDataPoints[tableRow.LinkType] && (linkDataPoints[tableRow.LinkType] = {
                                label: tableRow.LinkType,
                                color: colors.getColorByIndex(linkTypeCount++).value
                            }), link.weight < minFiles && (minFiles = link.weight), link.weight > maxFiles && (maxFiles = link.weight), 
                            links.push(link);
                        }), {
                            nodes: nodes,
                            links: links,
                            minFiles: minFiles,
                            maxFiles: maxFiles,
                            linkedByName: linkedByName,
                            linkTypes: linkDataPoints,
                            settings: settings
                        };
                    }, ForceGraph.parseSettings = function(dataView) {
                        var settings = ForceGraphSettings.parse(dataView, ForceGraph.capabilities);
                        return settings.size.charge = Math.min(Math.max(settings.size.charge, -100), -.1), 
                        settings.links.decimalPlaces = settings.links.decimalPlaces && Math.min(Math.max(settings.links.decimalPlaces, 0), 5), 
                        settings;
                    }, ForceGraph.prototype.init = function(options) {
                        var _this = this;
                        this.root = d3.select(options.element.get(0)), this.forceLayout = d3.layout.force(), 
                        this.forceLayout.drag().on("dragstart", function(d) {
                            d.isDrag = !0, _this.fadeNode(d);
                        }).on("dragend", function(d) {
                            d.isDrag = !1, _this.fadeNode(d);
                        }).on("drag", function(d) {
                            return _this.fadeNode(d);
                        }), this.colors = options.style.colorPalette.dataColors;
                    }, ForceGraph.prototype.update = function(options) {
                        var _this = this;
                        if (options.dataViews && !(options.dataViews.length < 1)) {
                            if (this.data = ForceGraph.converter(this.dataView = options.dataViews[0], this.colors), 
                            !this.data) return void this.removeElements();
                            this.viewport = options.viewport;
                            var k = Math.sqrt(Object.keys(this.data.nodes).length / (this.viewport.width * this.viewport.height));
                            this.removeElements();
                            var svg = this.root.append("svg").attr("width", this.viewport.width).attr("height", this.viewport.height).classed(ForceGraph.VisualClassName, !0);
                            if (this.forceLayout.gravity(100 * k).links(this.data.links).size([ this.viewport.width, this.viewport.height ]).linkDistance(100).charge(this.settings.size.charge / k).on("tick", this.tick()), 
                            this.updateNodes(), this.forceLayout.start(), this.paths = svg.selectAll(".link").data(this.forceLayout.links()).enter().append("path").attr("class", "link").attr("id", function(d, i) {
                                return "linkid_" + _this.uniqieId + i;
                            }).attr("stroke-width", function(d) {
                                return _this.settings.links.thickenLink ? _this.scale1to10(d.weight) : ForceGraph.DefaultValues.defaultLinkThickness;
                            }).style("stroke", function(d) {
                                return _this.getLinkColor(d);
                            }).style("fill", function(d) {
                                if (_this.settings.links.showArrow) return _this.getLinkColor(d);
                            }).on("mouseover", this.fadePath(.3, ForceGraph.DefaultValues.defaultLinkHighlightColor)).on("mouseout", this.fadePath(1, ForceGraph.DefaultValues.defaultLinkColor)), 
                            TooltipManager.addTooltip(this.paths, function(tooltipEvent) {
                                return tooltipEvent.data.tooltipInfo;
                            }), this.settings.links.showLabel) {
                                var linklabelholderUpdate = svg.selectAll(".linklabelholder").data(this.forceLayout.links());
                                linklabelholderUpdate.enter().append("g").attr("class", "linklabelholder").append("text").attr("class", "linklabel").attr("y", "-12").attr("text-anchor", "middle").style("fill", "#000").append("textPath").attr("xlink:href", function(d, i) {
                                    return ForceGraph.Href + "#linkid_" + _this.uniqieId + i;
                                }).attr("startOffset", "25%").text(function(d) {
                                    return _this.settings.links.colorLink === LinkColorType.ByLinkType ? d.type : d.formattedWeight;
                                }), linklabelholderUpdate.exit().remove();
                            }
                            this.nodes = svg.selectAll(".node").data(this.forceLayout.nodes()).enter().append("g").attr("class", "node").call(this.forceLayout.drag).on("mouseover", function(d) {
                                d.isOver = !0, _this.fadeNode(d);
                            }).on("mouseout", function(d) {
                                d.isOver = !1, _this.fadeNode(d);
                            }).on("mousedown", function() {
                                return d3.event.stopPropagation();
                            }).attr("drag-resize-disabled", !0), this.settings.nodes.displayImage ? this.nodes.append("image").attr("xlink:href", function(d) {
                                return d.image && "" !== d.image ? _this.settings.nodes.imageUrl + d.image + _this.settings.nodes.imageExt : _this.settings.nodes.defaultImage && "" !== _this.settings.nodes.defaultImage ? _this.settings.nodes.imageUrl + _this.settings.nodes.defaultImage + _this.settings.nodes.imageExt : "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABsAAAAbCAMAAAHNDTTxAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAACuUExURQAAAMbGxvLy8sfHx/Hx8fLy8vHx8cnJycrKyvHx8fHx8cvLy/Ly8szMzM3NzfHx8dDQ0PHx8fLy8vHx8e/v79LS0tPT0/Ly8tTU1NXV1dbW1vHx8fHx8fDw8NjY2PT09PLy8vLy8vHx8fLy8vHx8fHx8enp6fDw8PLy8uPj4+Tk5OXl5fHx8b+/v/Pz8+bm5vHx8ejo6PLy8vHx8fLy8sTExPLy8vLy8sXFxfHx8YCtMbUAAAA6dFJOUwD/k/+b7/f///+r/////0z/w1RcEP//ZP///4fj/v8Yj3yXn/unDEhQ////YP9Y/8//aIMU/9+L/+fzC4s1AAAACXBIWXMAABcRAAAXEQHKJvM/AAABQElEQVQoU5WS61LCMBCFFymlwSPKVdACIgWkuNyL+P4v5ibZ0jKjP/xm0uw5ySa7mRItAhnMoIC5TwQZdCZiZjcoC8WU6EVsmZgzoqGdxafgvJAvjUXCb2M+0cXNsd/GDarZqSf7av3M2P1E3xhfLkPUvLD5joEYwVVJQXM6+9McWUwLf4nDTCQZAy96UoDjNI/jhl3xPLbQamu8xD7iaIsPKw7GJ7KZEnWLY3Gi8EFj5nqibXnwD5VEGjJXk5sbpLppfvvo1RazQVrhSopPK4TODrtnjS3dY4ic8KurruWQYF+UG60BacexTMyT2jlNg41dOmKvTpkUd/Jevy7ZxQ61ULRUpoododx8GeDPvIrktbFVdUsK6f8Na5VlVpjZJtowTXVy7kfXF5wCaV1tqXAFuIdWJu+JviaQzNzfQvQDGKRXXEmy83cAAAAASUVORK5CYII=";
                            }).attr("x", "-12px").attr("y", "-12px").attr("width", "24px").attr("height", "24px") : this.nodes.append("circle").attr("r", function(d) {
                                return d.weight < 5 ? 5 : d.weight;
                            }), this.settings.labels.show && this.nodes.append("text").attr({
                                x: 12,
                                dy: ".35em"
                            }).style({
                                fill: this.settings.labels.color,
                                "font-size": PixelConverter.fromPoint(this.settings.labels.fontSize)
                            }).text(function(d) {
                                return d.name ? d.name.length > _this.settings.nodes.nameMaxLength ? d.name.substr(0, _this.settings.nodes.nameMaxLength) : d.name : "";
                            });
                        }
                    }, ForceGraph.prototype.removeElements = function() {
                        this.root && this.root.selectAll("svg").remove();
                    }, ForceGraph.prototype.updateNodes = function() {
                        var oldNodes = this.forceLayout.nodes();
                        this.forceLayout.nodes(d3.values(this.data.nodes)), this.forceLayout.nodes().forEach(function(node, i) {
                            oldNodes[i] && (node.x = oldNodes[i].x, node.y = oldNodes[i].y, node.px = oldNodes[i].px, 
                            node.py = oldNodes[i].py, node.weight = oldNodes[i].weight);
                        });
                    }, ForceGraph.prototype.tick = function() {
                        var _this = this, viewport = this.viewportIn, maxWidth = 20 * viewport.width, maxHeight = 20 * viewport.height, limitX = function(x) {
                            return Math.max((viewport.width - maxWidth) / 2, Math.min((viewport.width + maxWidth) / 2, x));
                        }, limitY = function(y) {
                            return Math.max((viewport.height - maxHeight) / 2, Math.min((viewport.height + maxHeight) / 2, y));
                        }, getPath = this.settings.links.showArrow ? function(d) {
                            d.source.x = limitX(d.source.x), d.source.y = limitY(d.source.y), d.target.x = limitX(d.target.x), 
                            d.target.y = limitY(d.target.y);
                            var dx = d.target.x - d.source.x, dy = d.target.y - d.source.y, dr = Math.sqrt(dx * dx + dy * dy), theta = Math.atan2(dy, dx) + Math.PI / 7.85, d90 = Math.PI / 2, dtxs = d.target.x - 6 * Math.cos(theta), dtys = d.target.y - 6 * Math.sin(theta);
                            return "M" + d.source.x + "," + d.source.y + "A" + dr + "," + dr + " 0 0 1," + d.target.x + "," + d.target.y + "A" + dr + "," + dr + " 0 0 0," + d.source.x + "," + d.source.y + "M" + dtxs + "," + dtys + "l" + (3.5 * Math.cos(d90 - theta) - 10 * Math.cos(theta)) + "," + (-3.5 * Math.sin(d90 - theta) - 10 * Math.sin(theta)) + "L" + (dtxs - 3.5 * Math.cos(d90 - theta) - 10 * Math.cos(theta)) + "," + (dtys + 3.5 * Math.sin(d90 - theta) - 10 * Math.sin(theta)) + "z";
                        } : function(d) {
                            d.source.x = limitX(d.source.x), d.source.y = limitY(d.source.y), d.target.x = limitX(d.target.x), 
                            d.target.y = limitY(d.target.y);
                            var dx = d.target.x - d.source.x, dy = d.target.y - d.source.y, dr = Math.sqrt(dx * dx + dy * dy);
                            return "M" + d.source.x + "," + d.source.y + "A" + dr + "," + dr + " 0 0,1 " + d.target.x + "," + d.target.y;
                        };
                        return function() {
                            _this.paths.each(function() {
                                this.parentNode.insertBefore(this, this);
                            }), _this.paths.attr("d", getPath), _this.nodes.attr("transform", function(d) {
                                return "translate(" + limitX(d.x) + "," + limitY(d.y) + ")";
                            });
                        };
                    }, ForceGraph.prototype.fadePath = function(opacity, highlight) {
                        var _this = this;
                        if (this.settings.links.colorLink === LinkColorType.Interactive) return function(d) {
                            _this.paths.style("stroke-opacity", function(o) {
                                return o.source === d.source && o.target === d.target ? 1 : opacity;
                            }), _this.paths.style("stroke", function(o) {
                                return o.source === d.source && o.target === d.target ? highlight : ForceGraph.DefaultValues.defaultLinkColor;
                            });
                        };
                    }, ForceGraph.prototype.isReachable = function(a, b) {
                        if (a.name === b.name) return !0;
                        if (this.data.linkedByName[a.name + "," + b.name]) return !0;
                        var visited = {};
                        for (var name in this.data.nodes) visited[name] = !1;
                        visited[a.name] = !0;
                        var stack = [];
                        for (stack.push(a.name); stack.length > 0; ) {
                            var cur = stack.pop(), node = this.data.nodes[cur];
                            for (var nb in node.adj) {
                                if (nb === b.name) return !0;
                                visited[nb] || (visited[nb] = !0, stack.push(nb));
                            }
                        }
                        return !1;
                    }, ForceGraph.prototype.fadeNode = function(node) {
                        var _this = this;
                        if (this.settings && this.settings.links.colorLink === LinkColorType.Interactive) {
                            var isConnected = function(a, b) {
                                return _this.data.linkedByName[a.name + "," + b.name] || _this.data.linkedByName[b.name + "," + a.name] || a.name === b.name;
                            }, isHighlight = node.isOver || node.isDrag, opacity = isHighlight ? .3 : 1, highlight = isHighlight ? ForceGraph.DefaultValues.defaultLinkHighlightColor : ForceGraph.DefaultValues.defaultLinkColor, that = this;
                            this.nodes.style("stroke-opacity", function(o) {
                                var thisOpacity = (that.settings.nodes.highlightReachableLinks ? that.isReachable(node, o) : isConnected(node, o)) ? 1 : opacity;
                                return this.setAttribute("fill-opacity", thisOpacity), thisOpacity;
                            }), this.paths.style("stroke-opacity", function(o) {
                                return (_this.settings.nodes.highlightReachableLinks ? _this.isReachable(node, o.source) : o.source === node || o.target === node) ? 1 : opacity;
                            }), this.paths.style("stroke", function(o) {
                                return (_this.settings.nodes.highlightReachableLinks ? _this.isReachable(node, o.source) : o.source === node || o.target === node) ? highlight : ForceGraph.DefaultValues.defaultLinkColor;
                            });
                        }
                    }, ForceGraph.prototype.destroy = function() {
                        this.root = null;
                    }, ForceGraph.VisualClassName = "forceGraph", ForceGraph.Count = 0, ForceGraph.DefaultValues = {
                        defaultLinkColor: "#bbb",
                        defaultLinkHighlightColor: "#f00",
                        defaultLinkThickness: "1.5px"
                    }, ForceGraph.capabilities = {
                        dataRoles: [ {
                            name: ForceGraphColumns.Roles.Source,
                            kind: VisualDataRoleKind.Grouping,
                            displayName: "Source"
                        }, {
                            name: ForceGraphColumns.Roles.Target,
                            kind: VisualDataRoleKind.Grouping,
                            displayName: "Target"
                        }, {
                            name: ForceGraphColumns.Roles.Weight,
                            kind: VisualDataRoleKind.Measure,
                            displayName: "Weight"
                        }, {
                            name: ForceGraphColumns.Roles.LinkType,
                            kind: VisualDataRoleKind.Grouping,
                            displayName: "Link Type",
                            description: "Links can be colored by link types"
                        }, {
                            name: ForceGraphColumns.Roles.SourceType,
                            kind: VisualDataRoleKind.Grouping,
                            displayName: "Source Type",
                            description: "Source type represents the image name for source entities"
                        }, {
                            name: ForceGraphColumns.Roles.TargetType,
                            kind: VisualDataRoleKind.Grouping,
                            displayName: "Target Type",
                            description: "Target type represents the image name for target entities"
                        } ],
                        objects: {
                            general: {
                                properties: {
                                    formatString: {
                                        type: {
                                            formatting: {
                                                formatString: !0
                                            }
                                        }
                                    }
                                }
                            },
                            labels: {
                                displayName: "Data labels",
                                properties: {
                                    show: {
                                        displayName: "Show",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    color: {
                                        displayName: "Fill",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    fontSize: {
                                        displayName: "Text Size",
                                        type: {
                                            formatting: {
                                                fontSize: !0
                                            }
                                        }
                                    }
                                }
                            },
                            links: {
                                displayName: "Links",
                                properties: {
                                    showArrow: {
                                        type: {
                                            bool: !0
                                        },
                                        displayName: "Arrow"
                                    },
                                    showLabel: {
                                        type: {
                                            bool: !0
                                        },
                                        displayName: "Label",
                                        description: "Displays weight on links"
                                    },
                                    colorLink: {
                                        type: {
                                            enumeration: ForceGraphSettings.createEnumTypeFromEnum(LinkColorType)
                                        },
                                        displayName: "Color"
                                    },
                                    thickenLink: {
                                        type: {
                                            bool: !0
                                        },
                                        displayName: "Thickness",
                                        description: "Thickenss of links represents weight"
                                    },
                                    displayUnits: {
                                        displayName: "Display Units",
                                        type: {
                                            formatting: {
                                                labelDisplayUnits: !0
                                            }
                                        }
                                    },
                                    decimalPlaces: {
                                        displayName: "Decimal Places",
                                        placeHolderText: "Auto",
                                        type: {
                                            numeric: !0
                                        }
                                    }
                                }
                            },
                            nodes: {
                                displayName: "Nodes",
                                properties: {
                                    displayImage: {
                                        type: {
                                            bool: !0
                                        },
                                        displayName: "Image",
                                        description: "Images are loaded from image url + source or target type + image extension"
                                    },
                                    defaultImage: {
                                        type: {
                                            text: !0
                                        },
                                        displayName: "Default image"
                                    },
                                    imageUrl: {
                                        type: {
                                            text: !0
                                        },
                                        displayName: "Image url"
                                    },
                                    imageExt: {
                                        type: {
                                            text: !0
                                        },
                                        displayName: "Image extension"
                                    },
                                    nameMaxLength: {
                                        type: {
                                            numeric: !0
                                        },
                                        displayName: "Max name length",
                                        description: "Max length of the name of entities displayed"
                                    },
                                    highlightReachableLinks: {
                                        type: {
                                            bool: !0
                                        },
                                        displayName: "Highlight all reachable links",
                                        description: "In interactive mode, whether a node's all reachable links will be highlighted"
                                    }
                                }
                            },
                            size: {
                                displayName: "Size",
                                properties: {
                                    charge: {
                                        type: {
                                            numeric: !0
                                        },
                                        displayName: "Charge",
                                        description: "The larger the negative charge the more apart the entities, must be negative but greater than -100"
                                    }
                                }
                            }
                        },
                        dataViewMappings: [ {
                            conditions: [ {
                                Source: {
                                    max: 1
                                },
                                Target: {
                                    max: 1
                                },
                                Weight: {
                                    max: 1
                                },
                                LinkType: {
                                    max: 1
                                },
                                SourceType: {
                                    max: 1
                                },
                                TargetType: {
                                    max: 1
                                }
                            } ],
                            categorical: {
                                categories: {
                                    for: {
                                        in: "Source"
                                    },
                                    dataReductionAlgorithm: {
                                        top: {
                                            count: 1e4
                                        }
                                    }
                                },
                                values: {
                                    select: [ {
                                        bind: {
                                            to: "Target"
                                        }
                                    }, {
                                        bind: {
                                            to: "Weight"
                                        }
                                    }, {
                                        bind: {
                                            to: "LinkType"
                                        }
                                    }, {
                                        bind: {
                                            to: "SourceType"
                                        }
                                    }, {
                                        bind: {
                                            to: "TargetType"
                                        }
                                    } ]
                                },
                                rowCount: {
                                    preferred: {
                                        min: 1
                                    }
                                }
                            }
                        } ],
                        suppressDefaultTitle: !0
                    }, ForceGraph;
                }();
                samples.ForceGraph = ForceGraph;
            }(samples = visuals.samples || (visuals.samples = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, jsCommon = window.jsCommon, powerbi = window.powerbi;
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var samples;
            !function(samples) {
                var PixelConverter = jsCommon.PixelConverter, CreateClassAndSelector = jsCommon.CssConstants.createClassAndSelector, SelectionManager = powerbi.visuals.utility.SelectionManager, createEnumType = powerbi.createEnumType, LegendData = powerbi.visuals.LegendData, legendPosition = powerbi.visuals.legendPosition, VisualDataRoleKind = powerbi.VisualDataRoleKind, createInteractivityService = powerbi.visuals.createInteractivityService, appendClearCatcher = powerbi.visuals.appendClearCatcher, createLegend = powerbi.visuals.createLegend, LegendPosition = powerbi.visuals.LegendPosition, valueFormatter = powerbi.visuals.valueFormatter, ColorHelper = powerbi.visuals.ColorHelper, SelectionId = powerbi.visuals.SelectionId, DataViewObjects = powerbi.DataViewObjects, LegendIcon = powerbi.visuals.LegendIcon, Legend = powerbi.visuals.Legend, ValueType = powerbi.ValueType, PrimitiveType = powerbi.PrimitiveType, AxisHelper = powerbi.visuals.AxisHelper, TextMeasurementService = powerbi.TextMeasurementService, TooltipManager = powerbi.visuals.TooltipManager, SVGUtil = powerbi.visuals.SVGUtil, ObjectEnumerationBuilder = powerbi.visuals.ObjectEnumerationBuilder, axisScale = powerbi.visuals.axisScale, PercentFormat = "0.00 %;-0.00 %;0.00 %", MillisecondsInADay = 864e5, MillisecondsInWeek = 6048e5, MillisecondsInAMonth = 2629746e3, MillisecondsInAYear = 31556952e3, ChartLineHeight = 40, PaddingTasks = 5;
                !function(GanttDateType) {
                    GanttDateType[GanttDateType.Day = "Day"] = "Day", GanttDateType[GanttDateType.Week = "Week"] = "Week", 
                    GanttDateType[GanttDateType.Month = "Month"] = "Month", GanttDateType[GanttDateType.Year = "Year"] = "Year";
                }(samples.GanttDateType || (samples.GanttDateType = {}));
                var Selectors, GanttDateType = samples.GanttDateType;
                !function(Selectors) {
                    Selectors.ClassName = CreateClassAndSelector("gantt"), Selectors.Chart = CreateClassAndSelector("chart"), 
                    Selectors.ChartLine = CreateClassAndSelector("chart-line"), Selectors.Body = CreateClassAndSelector("gantt-body"), 
                    Selectors.AxisGroup = CreateClassAndSelector("axis"), Selectors.Domain = CreateClassAndSelector("domain"), 
                    Selectors.AxisTick = CreateClassAndSelector("tick"), Selectors.Tasks = CreateClassAndSelector("tasks"), 
                    Selectors.TaskGroup = CreateClassAndSelector("task-group"), Selectors.SingleTask = CreateClassAndSelector("task"), 
                    Selectors.TaskRect = CreateClassAndSelector("task-rect"), Selectors.TaskProgress = CreateClassAndSelector("task-progress"), 
                    Selectors.TaskResource = CreateClassAndSelector("task-resource"), Selectors.SingleMilestone = CreateClassAndSelector("milestone"), 
                    Selectors.TaskLabels = CreateClassAndSelector("task-labels"), Selectors.TaskLines = CreateClassAndSelector("task-lines"), 
                    Selectors.SingleTaskLine = CreateClassAndSelector("task-line"), Selectors.Label = CreateClassAndSelector("label"), 
                    Selectors.LegendItems = CreateClassAndSelector("legendItem"), Selectors.LegendTitle = CreateClassAndSelector("legendTitle");
                }(Selectors || (Selectors = {}));
                var GanttSettings = function() {
                    function GanttSettings() {
                        this.general = {
                            groupTasks: !1
                        }, this.legend = {
                            show: !0,
                            position: legendPosition.right,
                            showTitle: !0,
                            titleText: "",
                            labelColor: "#000000",
                            fontSize: 8
                        }, this.taskLabels = {
                            show: !0,
                            fill: "#000000",
                            fontSize: 9,
                            width: 110
                        }, this.taskCompletion = {
                            show: !0,
                            fill: "#000000"
                        }, this.taskResource = {
                            show: !0,
                            fill: "#000000",
                            fontSize: 9
                        }, this.dateType = {
                            type: GanttDateType.Week
                        };
                    }
                    return Object.defineProperty(GanttSettings, "Default", {
                        get: function() {
                            return new this();
                        },
                        enumerable: !0,
                        configurable: !0
                    }), GanttSettings.parse = function(dataView, capabilities) {
                        var settings = new this();
                        if (!dataView || !dataView.metadata || !dataView.metadata.objects) return settings;
                        var properties = this.getProperties(capabilities);
                        for (var objectKey in capabilities.objects) for (var propKey in capabilities.objects[objectKey].properties) if (settings[objectKey] && _.has(settings[objectKey], propKey)) {
                            var type = capabilities.objects[objectKey].properties[propKey].type, getValueFn = this.getValueFnByType(type);
                            settings[objectKey][propKey] = getValueFn(dataView.metadata.objects, properties[objectKey][propKey], settings[objectKey][propKey]);
                        }
                        return settings;
                    }, GanttSettings.getProperties = function(capabilities) {
                        var objects = _.merge({
                            general: {
                                properties: {
                                    formatString: {}
                                }
                            }
                        }, capabilities.objects), properties = {};
                        for (var objectKey in objects) {
                            properties[objectKey] = {};
                            for (var propKey in objects[objectKey].properties) properties[objectKey][propKey] = {
                                objectName: objectKey,
                                propertyName: propKey
                            };
                        }
                        return properties;
                    }, GanttSettings.createEnumTypeFromEnum = function(type) {
                        var even = !1;
                        return createEnumType(Object.keys(type).filter(function(key, i) {
                            return !!(i % 2) === even && type[key] === key && !void (even = !even) || !!(i % 2) !== even;
                        }).map(function(x) {
                            return {
                                value: x,
                                displayName: x
                            };
                        }));
                    }, GanttSettings.getValueFnByType = function(type) {
                        switch (_.keys(type)[0]) {
                          case "fill":
                            return DataViewObjects.getFillColor;

                          default:
                            return DataViewObjects.getValue;
                        }
                    }, GanttSettings.enumerateObjectInstances = function(settings, options, capabilities) {
                        void 0 === settings && (settings = new this());
                        var enumeration = new ObjectEnumerationBuilder(), object = settings && settings[options.objectName];
                        if (!object) return enumeration;
                        var instance = {
                            objectName: options.objectName,
                            selector: null,
                            properties: {}
                        };
                        for (var key in object) _.has(object, key) && (instance.properties[key] = object[key]);
                        return enumeration.pushInstance(instance), enumeration;
                    }, GanttSettings.prototype.createOriginalSettings = function() {
                        this.originalSettings = _.cloneDeep(this);
                    }, GanttSettings;
                }();
                samples.GanttSettings = GanttSettings;
                var GanttColumns = function() {
                    function GanttColumns() {
                        this.Legend = null, this.Task = null, this.StartDate = null, this.Duration = null, 
                        this.Completion = null, this.Resource = null;
                    }
                    return GanttColumns.getColumnSources = function(dataView) {
                        return this.getColumnSourcesT(dataView);
                    }, GanttColumns.getTableValues = function(dataView) {
                        var table = dataView && dataView.table, columns = this.getColumnSourcesT(dataView);
                        return columns && table && _.mapValues(columns, function(n, i) {
                            return n && table.rows.map(function(row) {
                                return row[n.index];
                            });
                        });
                    }, GanttColumns.getTableRows = function(dataView) {
                        var table = dataView && dataView.table, columns = this.getColumnSourcesT(dataView);
                        return columns && table && table.rows.map(function(row) {
                            return _.mapValues(columns, function(n, i) {
                                return n && row[n.index];
                            });
                        });
                    }, GanttColumns.getCategoricalValues = function(dataView) {
                        var categorical = dataView && dataView.categorical, categories = categorical && categorical.categories || [], values = categorical && categorical.values || [], series = categorical && values.source && this.getSeriesValues(dataView);
                        return categorical && _.mapValues(new this(), function(n, i) {
                            return _.toArray(categories).concat(_.toArray(values)).filter(function(x) {
                                return x.source.roles && x.source.roles[i];
                            }).map(function(x) {
                                return x.values;
                            })[0] || values.source && values.source.roles && values.source.roles[i] && series;
                        });
                    }, GanttColumns.getSeriesValues = function(dataView) {
                        return dataView && dataView.categorical && dataView.categorical.values && dataView.categorical.values.map(function(x) {
                            return visuals.converterHelper.getSeriesName(x.source);
                        });
                    }, GanttColumns.getCategoricalColumns = function(dataView) {
                        var categorical = dataView && dataView.categorical, categories = categorical && categorical.categories || [], values = categorical && categorical.values || [];
                        return categorical && _.mapValues(new this(), function(n, i) {
                            return categories.filter(function(x) {
                                return x.source.roles && x.source.roles[i];
                            })[0] || values.source && values.source.roles && values.source.roles[i] && values || values.filter(function(x) {
                                return x.source.roles && x.source.roles[i];
                            });
                        });
                    }, GanttColumns.getColumnSourcesT = function(dataView) {
                        var columns = dataView && dataView.metadata && dataView.metadata.columns;
                        return columns && _.mapValues(new this(), function(n, i) {
                            return columns.filter(function(x) {
                                return x.roles && x.roles[i];
                            })[0];
                        });
                    }, GanttColumns.Roles = Object.freeze(_.mapValues(new GanttColumns(), function(x, i) {
                        return i;
                    })), GanttColumns;
                }();
                samples.GanttColumns = GanttColumns;
                var Gantt = function() {
                    function Gantt() {
                        this.textProperties = {
                            fontFamily: "wf_segoe-ui_normal",
                            fontSize: PixelConverter.toString(9)
                        }, this.margin = Gantt.DefaultMargin;
                    }
                    return Object.defineProperty(Gantt, "DefaultMargin", {
                        get: function() {
                            return {
                                top: 50,
                                right: 40,
                                bottom: 40,
                                left: 10
                            };
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Gantt.prototype.init = function(options) {
                        this.viewport = _.clone(options.viewport), this.style = options.style, this.body = d3.select(options.element.get(0)), 
                        this.hostServices = options.host, this.selectionManager = new SelectionManager({
                            hostServices: options.host
                        }), this.isInteractiveChart = options.interactivity && options.interactivity.isInteractiveLegend, 
                        this.interactivityService = createInteractivityService(this.hostServices), this.createViewport(options.element), 
                        this.updateChartSize(), this.behavior = new GanttChartBehavior(), this.colors = options.style.colorPalette.dataColors;
                    }, Gantt.prototype.createViewport = function(element) {
                        this.ganttDiv = this.body.append("div").classed(Selectors.Body.class, !0), this.ganttSvg = this.ganttDiv.append("svg").classed(Selectors.ClassName.class, !0), 
                        this.clearCatcher = appendClearCatcher(this.ganttSvg), this.axisGroup = this.ganttSvg.append("g").classed(Selectors.AxisGroup.class, !0), 
                        this.lineGroup = this.ganttSvg.append("g").classed(Selectors.TaskLines.class, !0), 
                        this.chartGroup = this.ganttSvg.append("g").classed(Selectors.Chart.class, !0), 
                        this.taskGroup = this.chartGroup.append("g").classed(Selectors.Tasks.class, !0), 
                        this.legend = createLegend(element, this.isInteractiveChart, this.interactivityService, !0, LegendPosition.Top);
                    }, Gantt.prototype.clearViewport = function() {
                        this.body.selectAll(Selectors.LegendItems.selector).remove(), this.body.selectAll(Selectors.LegendTitle.selector).remove(), 
                        this.axisGroup.selectAll(Selectors.AxisTick.selector).remove(), this.axisGroup.selectAll(Selectors.Domain.selector).remove(), 
                        this.lineGroup.selectAll("*").remove(), this.chartGroup.selectAll(Selectors.ChartLine.selector).remove(), 
                        this.chartGroup.selectAll(Selectors.TaskGroup.selector).remove(), this.chartGroup.selectAll(Selectors.SingleTask.selector).remove();
                    }, Gantt.prototype.updateChartSize = function() {
                        this.ganttDiv.style({
                            height: PixelConverter.toString(this.viewport.height),
                            width: PixelConverter.toString(this.viewport.width)
                        });
                    }, Gantt.getTaskProperty = function(columnSource, child, propertyName) {
                        if (!(child && columnSource && columnSource.length > 0 && columnSource[0].roles)) return null;
                        var index = columnSource.indexOf(columnSource.filter(function(x) {
                            return x.roles[propertyName];
                        })[0]);
                        return index !== -1 ? child[index] : null;
                    }, Gantt.hasRole = function(column, name) {
                        var roles = column.roles;
                        return roles && roles[name];
                    }, Gantt.getTooltipInfo = function(task, formatters, timeInterval) {
                        void 0 === timeInterval && (timeInterval = "Days");
                        var tooltipDataArray = [];
                        return task.taskType && tooltipDataArray.push({
                            displayName: Gantt.capabilities.dataRoles[0].name,
                            value: task.taskType
                        }), tooltipDataArray.push({
                            displayName: Gantt.capabilities.dataRoles[1].name,
                            value: task.name
                        }), isNaN(task.start.getDate()) || tooltipDataArray.push({
                            displayName: Gantt.capabilities.dataRoles[2].name,
                            value: formatters.startDateFormatter.format(task.start.toLocaleDateString())
                        }), tooltipDataArray.push({
                            displayName: Gantt.capabilities.dataRoles[3].name,
                            value: formatters.durationFormatter.format(task.duration) + " " + timeInterval
                        }), tooltipDataArray.push({
                            displayName: Gantt.capabilities.dataRoles[4].name,
                            value: formatters.completionFormatter.format(task.completion)
                        }), task.resource && tooltipDataArray.push({
                            displayName: Gantt.capabilities.dataRoles[5].name,
                            value: task.resource
                        }), tooltipDataArray;
                    }, Gantt.isChartHasTask = function(dataView) {
                        if (dataView.table && dataView.table.columns) for (var _i = 0, _a = dataView.table.columns; _i < _a.length; _i++) {
                            var column = _a[_i];
                            if (Gantt.hasRole(column, "Task")) return !0;
                        }
                        return !1;
                    }, Gantt.getFormatters = function(dataView) {
                        if (!dataView || !dataView.metadata || !dataView.metadata.columns) return null;
                        for (var dateFormat = "d", numberFormat = "#", _i = 0, _a = dataView.metadata.columns; _i < _a.length; _i++) {
                            var dvColumn = _a[_i];
                            if (dataView.categorical.categories) for (var _b = 0, _c = dataView.categorical.categories; _b < _c.length; _b++) {
                                var dvCategory = _c[_b];
                                Gantt.hasRole(dvCategory.source, "StartDate") && (dateFormat = dvColumn.format);
                            }
                        }
                        return {
                            startDateFormatter: valueFormatter.create({
                                format: dateFormat
                            }),
                            durationFormatter: valueFormatter.create({
                                format: numberFormat
                            }),
                            completionFormatter: valueFormatter.create({
                                format: PercentFormat,
                                value: 1,
                                allowFormatBeautification: !0
                            })
                        };
                    }, Gantt.createTasks = function(dataView, formatters, colors) {
                        var metadataColumns = GanttColumns.getColumnSources(dataView), columnSource = dataView.table.columns, colorHelper = new ColorHelper(colors, (void 0));
                        return dataView.table.rows.map(function(child, index) {
                            var dateString = Gantt.getTaskProperty(columnSource, child, "StartDate");
                            dateString = Gantt.isValidDate(dateString) ? dateString : new Date(Date.now());
                            var duration = Gantt.getTaskProperty(columnSource, child, "Duration"), completionValue = Gantt.getTaskProperty(columnSource, child, "Completion"), completion = Gantt.convertToDecimal(completionValue);
                            completion = completion <= 1 ? completion : 1;
                            var taskType = Gantt.getTaskProperty(columnSource, child, "Legend"), tasksTypeColor = colorHelper.getColorForMeasure(dataView.metadata.objects, taskType), identity = SelectionId.createWithIdAndMeasureAndCategory(dataView.categorical.categories[0].identity[index], taskType, metadataColumns.Task.queryName), task = {
                                id: index,
                                name: Gantt.getTaskProperty(columnSource, child, "Task"),
                                start: dateString ? dateString : new Date(Date.now()),
                                duration: duration > 0 ? duration : 1,
                                end: null,
                                completion: completion > 0 ? completion : 0,
                                resource: Gantt.getTaskProperty(columnSource, child, "Resource"),
                                taskType: taskType,
                                color: tasksTypeColor ? tasksTypeColor : Gantt.DefaultValues.TaskColor,
                                tooltipInfo: null,
                                description: "",
                                identity: identity,
                                selected: !1
                            };
                            return task.end = d3.time.day.offset(task.start, task.duration), task.tooltipInfo = Gantt.getTooltipInfo(task, formatters), 
                            task;
                        });
                    }, Gantt.createSeries = function(objects, tasks, dataView, colors) {
                        var colorHelper = new ColorHelper(colors, (void 0)), taskGroup = _.groupBy(tasks, function(t) {
                            return t.taskType;
                        }), taskTypes = Gantt.getAllTasksTypes(dataView), series = _.map(taskTypes.types, function(type) {
                            return {
                                tasks: taskGroup[type],
                                fill: colorHelper.getColorForMeasure(objects, type),
                                name: type,
                                identity: SelectionId.createWithMeasure(type),
                                selected: !1
                            };
                        });
                        return series;
                    }, Gantt.converter = function(dataView, colors) {
                        if (!dataView || !dataView.categorical || !Gantt.isChartHasTask(dataView) || 0 === dataView.table.rows.length) return null;
                        var settings = Gantt.parseSettings(dataView, colors), taskTypes = Gantt.getAllTasksTypes(dataView), legendData = {
                            fontSize: settings.legend.fontSize,
                            dataPoints: [],
                            title: taskTypes.typeName
                        }, colorHelper = new ColorHelper(colors, (void 0));
                        legendData.dataPoints = _.map(taskTypes.types, function(type) {
                            return {
                                label: type,
                                color: colorHelper.getColorForMeasure(dataView.metadata.objects, type),
                                icon: LegendIcon.Circle,
                                selected: !1,
                                identity: SelectionId.createWithMeasure(type)
                            };
                        });
                        var formatters = this.getFormatters(dataView), tasks = Gantt.createTasks(dataView, formatters, colors), series = Gantt.createSeries(dataView.metadata.objects, tasks, dataView, colors), viewModel = {
                            dataView: dataView,
                            settings: settings,
                            tasks: tasks,
                            series: series,
                            legendData: legendData,
                            taskTypes: taskTypes
                        };
                        return viewModel;
                    }, Gantt.parseSettings = function(dataView, colors) {
                        var settings = GanttSettings.parse(dataView, Gantt.capabilities);
                        return delete settings.taskCompletion.show, settings.createOriginalSettings(), settings;
                    }, Gantt.isValidDate = function(date) {
                        return "[object Date]" === Object.prototype.toString.call(date) && !isNaN(date.getTime());
                    }, Gantt.convertToDecimal = function(number) {
                        return number >= 0 && number <= 1 ? number : number / 100;
                    }, Gantt.getAllTasksTypes = function(dataView) {
                        var taskTypes, types = [], groupName = "", data = dataView.table.rows, index = _.findIndex(dataView.table.columns, function(col) {
                            return col.roles.hasOwnProperty("Legend");
                        });
                        return index !== -1 && (groupName = dataView.table.columns[index].displayName, types = _.unique(data, function(d) {
                            return d[index];
                        }).map(function(d) {
                            return d[index];
                        })), taskTypes = {
                            typeName: groupName,
                            types: types
                        };
                    }, Gantt.prototype.renderLegend = function() {
                        if (this.viewModel.legendData) {
                            LegendData.update(this.viewModel.legendData, DataViewObjects.getObject(this.viewModel.dataView.metadata.objects, "legend", {}));
                            var position = this.viewModel.settings.legend.show ? LegendPosition[this.viewModel.settings.legend.position] : LegendPosition.None;
                            switch (this.legend.changeOrientation(position), this.legend.drawLegend(this.viewModel.legendData, _.clone(this.viewport)), 
                            Legend.positionChartArea(this.ganttDiv, this.legend), this.legend.getOrientation()) {
                              case LegendPosition.Left:
                              case LegendPosition.LeftCenter:
                              case LegendPosition.Right:
                              case LegendPosition.RightCenter:
                                this.viewport.width -= this.legend.getMargins().width;
                                break;

                              case LegendPosition.Top:
                              case LegendPosition.TopCenter:
                              case LegendPosition.Bottom:
                              case LegendPosition.BottomCenter:
                                this.viewport.height -= this.legend.getMargins().height;
                            }
                        }
                    }, Gantt.prototype.update = function(options) {
                        if (options.dataViews && options.dataViews[0]) {
                            if (this.viewModel = Gantt.converter(options.dataViews[0], this.colors), !this.viewModel) return void this.clearViewport();
                            this.viewport = _.clone(options.viewport), this.margin = Gantt.DefaultMargin, this.renderLegend(), 
                            this.updateChartSize();
                            var tasks = this.viewModel.tasks;
                            if (this.interactivityService && (this.interactivityService.applySelectionStateToData(tasks), 
                            this.interactivityService.applySelectionStateToData(this.viewModel.series)), tasks.length > 0) {
                                var tasksSortedByStartDate = _.sortBy(tasks, function(t) {
                                    return t.start;
                                }), tasksSortedByEndDate = _.sortBy(tasks, function(t) {
                                    return t.end;
                                }), dateTypeMilliseconds = this.getDateType(), startDate = tasksSortedByStartDate[0].start, endDate = tasksSortedByEndDate[tasks.length - 1].end, ticks = Math.ceil(Math.round(endDate.valueOf() - startDate.valueOf()) / dateTypeMilliseconds), groupedTasks = this.groupTasks(tasks);
                                ticks = 0 === ticks || 1 === ticks ? 2 : ticks;
                                var axisLength = 50 * ticks;
                                this.ganttSvg.attr({
                                    height: PixelConverter.toString(groupedTasks.length * ChartLineHeight + this.margin.top),
                                    width: PixelConverter.toString(this.margin.left + this.viewModel.settings.taskLabels.width + axisLength + Gantt.DefaultValues.ResourceWidth)
                                });
                                var viewportIn = {
                                    height: this.viewport.height,
                                    width: axisLength
                                }, xAxisProperties = this.calculateAxes(viewportIn, this.textProperties, startDate, endDate, axisLength, ticks, !1);
                                if (this.timeScale = xAxisProperties.scale, this.renderAxis(xAxisProperties, 200), 
                                this.renderTasks(groupedTasks), this.createMilestoneLine(groupedTasks), this.updateTaskLabels(groupedTasks, this.viewModel.settings.taskLabels.width), 
                                this.updateElementsPositions(this.viewport, this.margin), this.interactivityService) {
                                    var behaviorOptions = {
                                        clearCatcher: this.clearCatcher,
                                        taskSelection: this.taskGroup.selectAll(Selectors.SingleTask.selector),
                                        legendSelection: this.body.selectAll(Selectors.LegendItems.selector),
                                        interactivityService: this.interactivityService
                                    };
                                    this.interactivityService.bind(tasks, this.behavior, behaviorOptions);
                                }
                            }
                        }
                    }, Gantt.prototype.getDateType = function() {
                        var milliSeconds = MillisecondsInWeek;
                        switch (this.viewModel.settings.dateType.type) {
                          case GanttDateType.Day:
                            milliSeconds = MillisecondsInADay;
                            break;

                          case GanttDateType.Week:
                            milliSeconds = MillisecondsInWeek;
                            break;

                          case GanttDateType.Month:
                            milliSeconds = MillisecondsInAMonth;
                            break;

                          case GanttDateType.Year:
                            milliSeconds = MillisecondsInAYear;
                        }
                        return milliSeconds;
                    }, Gantt.prototype.calculateAxes = function(viewportIn, textProperties, startDate, endDate, axisLength, ticksCount, scrollbarVisible) {
                        var dataTypeDatetime = ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Date), category = {
                            displayName: "StartDate",
                            queryName: "StartDate",
                            type: dataTypeDatetime,
                            index: 0
                        }, visualOptions = {
                            viewport: viewportIn,
                            margin: this.margin,
                            forcedXDomain: [ startDate, endDate ],
                            forceMerge: !1,
                            showCategoryAxisLabel: !1,
                            showValueAxisLabel: !1,
                            categoryAxisScaleType: axisScale.linear,
                            valueAxisScaleType: null,
                            valueAxisDisplayUnits: 0,
                            categoryAxisDisplayUnits: 0,
                            trimOrdinalDataOnOverflow: !1,
                            forcedTickCount: ticksCount
                        }, width = viewportIn.width, axes = this.calculateAxesProperties(viewportIn, visualOptions, axisLength, category);
                        return axes.willLabelsFit = AxisHelper.LabelLayoutStrategy.willLabelsFit(axes, width, TextMeasurementService.measureSvgTextWidth, textProperties), 
                        axes.willLabelsWordBreak = !axes.willLabelsFit && !scrollbarVisible && AxisHelper.LabelLayoutStrategy.willLabelsWordBreak(axes, this.margin, width, TextMeasurementService.measureSvgTextWidth, TextMeasurementService.estimateSvgTextHeight, TextMeasurementService.getTailoredTextOrDefault, textProperties), 
                        axes;
                    }, Gantt.prototype.calculateAxesProperties = function(viewportIn, options, axisLength, metaDataColumn) {
                        var _this = this, xAxisProperties = AxisHelper.createAxis({
                            pixelSpan: viewportIn.width,
                            dataDomain: options.forcedXDomain,
                            metaDataColumn: metaDataColumn,
                            formatString: Gantt.DefaultValues.DateFormatStrings[this.viewModel.settings.dateType.type],
                            outerPadding: 0,
                            isScalar: !0,
                            isVertical: !1,
                            forcedTickCount: options.forcedTickCount,
                            useTickIntervalForDisplayUnits: !0,
                            isCategoryAxis: !0,
                            getValueFn: function(index, type) {
                                return valueFormatter.format(new Date(index), Gantt.DefaultValues.DateFormatStrings[_this.viewModel.settings.dateType.type]);
                            },
                            scaleType: options.categoryAxisScaleType,
                            axisDisplayUnits: options.categoryAxisDisplayUnits
                        });
                        return xAxisProperties.axisLabel = metaDataColumn.displayName, xAxisProperties;
                    }, Gantt.prototype.groupTasks = function(tasks) {
                        if (this.viewModel.settings.general.groupTasks) {
                            var groupedTasks = _.groupBy(tasks, function(x) {
                                return x.name;
                            }), result = _.map(groupedTasks, function(x, i) {
                                return {
                                    name: i,
                                    tasks: groupedTasks[i]
                                };
                            });
                            return result.forEach(function(x, i) {
                                x.tasks.forEach(function(t) {
                                    return t.id = i;
                                }), x.id = i;
                            }), result;
                        }
                        return tasks.map(function(x) {
                            return {
                                name: x.name,
                                id: x.id,
                                tasks: [ x ]
                            };
                        });
                    }, Gantt.prototype.renderAxis = function(xAxisProperties, duration) {
                        var xAxis = xAxisProperties.axis;
                        xAxis.orient("bottom"), this.axisGroup.transition().duration(duration).call(xAxis);
                    }, Gantt.prototype.updateTaskLabels = function(tasks, width) {
                        var axisLabel, _this = this, taskLineCoordinateX = 15, taskLabelsShow = !this.viewModel || this.viewModel.settings.taskLabels.show, taskLabelsColor = this.viewModel ? this.viewModel.settings.taskLabels.fill : GanttSettings.Default.taskLabels.fill, taskLabelsFontSize = this.viewModel ? this.viewModel.settings.taskLabels.fontSize : GanttSettings.Default.taskLabels.fontSize;
                        taskLabelsShow ? (axisLabel = this.lineGroup.selectAll(Selectors.Label.selector).data(tasks), 
                        axisLabel.enter().append("text").classed(Selectors.Label.class, !0), axisLabel.attr({
                            x: taskLineCoordinateX,
                            y: function(task, i) {
                                return _this.getTaskLabelCoordinateY(task.id);
                            },
                            fill: taskLabelsColor,
                            "stroke-width": 1
                        }).style("font-size", PixelConverter.fromPoint(taskLabelsFontSize)).text(function(task) {
                            return task.name;
                        }), axisLabel.call(AxisHelper.LabelLayoutStrategy.clip, width - 20, TextMeasurementService.svgEllipsis), 
                        axisLabel.append("title").text(function(task) {
                            return task.name;
                        }), axisLabel.exit().remove()) : this.lineGroup.selectAll(Selectors.Label.selector).remove();
                    }, Gantt.prototype.renderTasks = function(groupedTasks) {
                        var _this = this, taskGroupSelection = this.taskGroup.selectAll(Selectors.TaskGroup.selector).data(groupedTasks), taskProgressColor = this.viewModel ? this.viewModel.settings.taskCompletion.fill : GanttSettings.Default.taskCompletion.fill, taskResourceShow = !this.viewModel || this.viewModel.settings.taskResource.show, padding = 4, taskResourceColor = this.viewModel ? this.viewModel.settings.taskResource.fill : GanttSettings.Default.taskResource.fill, taskResourceFontSize = this.viewModel ? this.viewModel.settings.taskResource.fontSize : GanttSettings.Default.taskResource.fontSize;
                        taskGroupSelection.enter().append("g").classed(Selectors.TaskGroup.class, !0);
                        var taskSelection = taskGroupSelection.selectAll(Selectors.SingleTask.selector).data(function(d) {
                            return d.tasks;
                        });
                        taskSelection.enter().append("g").classed(Selectors.SingleTask.class, !0);
                        var taskRect = taskSelection.selectAll(Selectors.TaskRect.selector).data(function(d) {
                            return [ d ];
                        });
                        taskRect.enter().append("rect").classed(Selectors.TaskRect.class, !0), taskRect.classed(Selectors.TaskRect.class, !0).attr({
                            x: function(task) {
                                return _this.timeScale(task.start);
                            },
                            y: function(task) {
                                return _this.getBarYCoordinate(task.id);
                            },
                            width: function(task) {
                                return _this.taskDurationToWidth(task);
                            },
                            height: function() {
                                return _this.getBarHeight();
                            }
                        }).style("fill", function(task) {
                            return task.color;
                        }), taskRect.exit().remove();
                        var taskProgress = taskSelection.selectAll(Selectors.TaskProgress.selector).data(function(d) {
                            return [ d ];
                        });
                        if (taskProgress.enter().append("rect").classed(Selectors.TaskProgress.class, !0), 
                        taskProgress.attr({
                            x: function(task) {
                                return _this.timeScale(task.start);
                            },
                            y: function(task) {
                                return _this.getBarYCoordinate(task.id) + _this.getBarHeight() / 2 - Gantt.DefaultValues.ProgressBarHeight / 2;
                            },
                            width: function(task) {
                                return _this.setTaskProgress(task);
                            },
                            height: Gantt.DefaultValues.ProgressBarHeight
                        }).style("fill", taskProgressColor), taskProgress.exit().remove(), taskResourceShow) {
                            var taskResource = taskSelection.selectAll(Selectors.TaskResource.selector).data(function(d) {
                                return [ d ];
                            });
                            taskResource.enter().append("text").classed(Selectors.TaskResource.class, !0), taskResource.attr({
                                x: function(task) {
                                    return _this.timeScale(task.end) + padding;
                                },
                                y: function(task) {
                                    return _this.getBarYCoordinate(task.id) + _this.getBarHeight() / 2 + padding;
                                }
                            }).text(function(task) {
                                return task.resource;
                            }).style({
                                fill: taskResourceColor,
                                "font-size": PixelConverter.fromPoint(taskResourceFontSize)
                            }).call(AxisHelper.LabelLayoutStrategy.clip, Gantt.DefaultValues.ResourceWidth - 10, TextMeasurementService.svgEllipsis), 
                            taskResource.exit().remove();
                        } else taskSelection.selectAll(Selectors.TaskResource.selector).remove();
                        TooltipManager.addTooltip(taskSelection, function(tooltipEvent) {
                            return tooltipEvent.data.tooltipInfo;
                        }), taskSelection.exit().remove(), taskGroupSelection.exit().remove();
                    }, Gantt.prototype.onClearSelection = function() {
                        this.selectionManager.clear();
                    }, Gantt.prototype.getTaskLabelCoordinateY = function(taskIndex) {
                        var fontSize = +this.viewModel.settings.taskLabels.fontSize;
                        return ChartLineHeight * taskIndex + (this.getBarHeight() + 5 - (40 - fontSize) / 4);
                    }, Gantt.prototype.setTaskProgress = function(task) {
                        var fraction = task.completion / 1, y = this.timeScale, progress = (y(task.end) - y(task.start)) * fraction;
                        return progress;
                    }, Gantt.prototype.getBarYCoordinate = function(lineNumber) {
                        return ChartLineHeight * lineNumber + PaddingTasks;
                    }, Gantt.prototype.getBarHeight = function() {
                        return ChartLineHeight / 1.5;
                    }, Gantt.prototype.taskDurationToWidth = function(task) {
                        return this.timeScale(task.end) - this.timeScale(task.start);
                    }, Gantt.prototype.getTooltipForMilstoneLine = function(timestamp, milestoneTitle) {
                        var stringDate = new Date(timestamp).toDateString(), tooltip = [ {
                            displayName: milestoneTitle,
                            value: stringDate
                        } ];
                        return tooltip;
                    }, Gantt.prototype.createMilestoneLine = function(tasks, milestoneTitle, timestamp) {
                        void 0 === milestoneTitle && (milestoneTitle = "Today"), void 0 === timestamp && (timestamp = Date.now());
                        var line = [ {
                            x1: this.timeScale(timestamp),
                            y1: 0,
                            x2: this.timeScale(timestamp),
                            y2: this.getMilestoneLineLength(tasks.length),
                            tooltipInfo: this.getTooltipForMilstoneLine(timestamp, milestoneTitle)
                        } ], chartLineSelection = this.chartGroup.selectAll(Selectors.ChartLine.selector).data(line);
                        chartLineSelection.enter().append("line").classed(Selectors.ChartLine.class, !0), 
                        chartLineSelection.attr({
                            x1: function(line) {
                                return line.x1;
                            },
                            y1: function(line) {
                                return line.y1;
                            },
                            x2: function(line) {
                                return line.x2;
                            },
                            y2: function(line) {
                                return line.y2;
                            },
                            tooltipInfo: function(line) {
                                return line.tooltipInfo;
                            }
                        }), TooltipManager.addTooltip(chartLineSelection, function(tooltipEvent) {
                            return tooltipEvent.data.tooltipInfo;
                        }), chartLineSelection.exit().remove();
                    }, Gantt.prototype.updateElementsPositions = function(viewport, margin) {
                        this.axisGroup.attr("transform", SVGUtil.translate(this.viewModel.settings.taskLabels.width + margin.left, 15)), 
                        this.chartGroup.attr("transform", SVGUtil.translate(this.viewModel.settings.taskLabels.width + margin.left, margin.top)), 
                        this.lineGroup.attr("transform", SVGUtil.translate(0, margin.top));
                    }, Gantt.prototype.getMilestoneLineLength = function(numOfTasks) {
                        return numOfTasks * ChartLineHeight;
                    }, Gantt.prototype.enumerateObjectInstances = function(options) {
                        var settings = this.viewModel && this.viewModel.settings;
                        if (_.isEmpty(settings)) return [];
                        var result = GanttSettings.enumerateObjectInstances(settings.originalSettings, options, Gantt.capabilities);
                        switch (options.objectName) {
                          case "general":
                            return [];
                        }
                        return result.complete();
                    }, Gantt.DefaultValues = {
                        AxisTickSize: 6,
                        MaxTaskOpacity: 1,
                        MinTaskOpacity: .4,
                        ProgressBarHeight: 4,
                        ResourceWidth: 100,
                        TaskColor: "#00B099",
                        TaskLineWidth: 15,
                        DefaultDateType: GanttDateType.Week,
                        DateFormatStrings: {
                            Day: "MMM dd",
                            Week: "MMM dd",
                            Month: "MMM yyyy",
                            Year: "yyyy"
                        }
                    }, Gantt.capabilities = {
                        dataRoles: [ {
                            name: "Legend",
                            kind: VisualDataRoleKind.Grouping,
                            displayName: "Legend"
                        }, {
                            name: "Task",
                            kind: VisualDataRoleKind.Grouping,
                            displayName: "Task"
                        }, {
                            name: "StartDate",
                            kind: VisualDataRoleKind.Grouping,
                            displayName: "Start Date"
                        }, {
                            name: "Duration",
                            kind: VisualDataRoleKind.Measure,
                            displayName: "Duration",
                            requiredTypes: [ {
                                numeric: !0
                            }, {
                                integer: !0
                            } ]
                        }, {
                            name: "Completion",
                            kind: VisualDataRoleKind.Measure,
                            displayName: "% Completion",
                            requiredTypes: [ {
                                numeric: !0
                            }, {
                                integer: !0
                            } ]
                        }, {
                            name: "Resource",
                            kind: VisualDataRoleKind.Grouping,
                            displayName: "Resource"
                        } ],
                        dataViewMappings: [ {
                            conditions: [ {
                                Legend: {
                                    min: 0,
                                    max: 1
                                },
                                Task: {
                                    min: 1,
                                    max: 1
                                },
                                StartDate: {
                                    min: 0,
                                    max: 0
                                },
                                Duration: {
                                    min: 0,
                                    max: 0
                                },
                                Completion: {
                                    min: 0,
                                    max: 0
                                },
                                Resource: {
                                    min: 0,
                                    max: 0
                                }
                            }, {
                                Legend: {
                                    min: 0,
                                    max: 1
                                },
                                Task: {
                                    min: 1,
                                    max: 1
                                },
                                StartDate: {
                                    min: 0,
                                    max: 1
                                },
                                Duration: {
                                    min: 0,
                                    max: 0
                                },
                                Completion: {
                                    min: 0,
                                    max: 0
                                },
                                Resource: {
                                    min: 0,
                                    max: 0
                                }
                            }, {
                                Legend: {
                                    min: 0,
                                    max: 1
                                },
                                Task: {
                                    min: 0,
                                    max: 1
                                },
                                StartDate: {
                                    min: 0,
                                    max: 1
                                },
                                Duration: {
                                    min: 0,
                                    max: 1
                                },
                                Completion: {
                                    min: 0,
                                    max: 1
                                },
                                Resource: {
                                    min: 0,
                                    max: 1
                                }
                            } ],
                            table: {
                                rows: {
                                    select: [ {
                                        for: {
                                            in: "Legend"
                                        }
                                    }, {
                                        for: {
                                            in: "Task"
                                        }
                                    }, {
                                        for: {
                                            in: "StartDate"
                                        }
                                    }, {
                                        for: {
                                            in: "Duration"
                                        }
                                    }, {
                                        for: {
                                            in: "Completion"
                                        }
                                    }, {
                                        for: {
                                            in: "Resource"
                                        }
                                    } ]
                                }
                            }
                        } ],
                        objects: {
                            general: {
                                displayName: "General",
                                properties: {
                                    groupTasks: {
                                        displayName: "Group Tasks",
                                        type: {
                                            bool: !0
                                        }
                                    }
                                }
                            },
                            legend: {
                                displayName: "Legend",
                                description: "Display legend options",
                                properties: {
                                    show: {
                                        displayName: "Show",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    position: {
                                        displayName: "Position",
                                        description: "Select the location for the legend",
                                        type: {
                                            enumeration: legendPosition.type
                                        }
                                    },
                                    showTitle: {
                                        displayName: "Title",
                                        description: "Display a title for legend symbols",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    titleText: {
                                        displayName: "Legend Name",
                                        description: "Title text",
                                        type: {
                                            text: !0
                                        },
                                        suppressFormatPainterCopy: !0
                                    },
                                    labelColor: {
                                        displayName: "Color",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    fontSize: {
                                        displayName: "Text Size",
                                        type: {
                                            formatting: {
                                                fontSize: !0
                                            }
                                        }
                                    }
                                }
                            },
                            taskLabels: {
                                displayName: "Category Labels",
                                properties: {
                                    show: {
                                        displayName: "Show",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    fill: {
                                        displayName: "Fill",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    fontSize: {
                                        displayName: "Font Size",
                                        type: {
                                            formatting: {
                                                fontSize: !0
                                            }
                                        }
                                    },
                                    width: {
                                        displayName: "Width",
                                        type: {
                                            numeric: !0
                                        }
                                    }
                                }
                            },
                            taskCompletion: {
                                displayName: "Task Completion",
                                properties: {
                                    show: {
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    fill: {
                                        displayName: "Completion Color",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    }
                                }
                            },
                            taskResource: {
                                displayName: "Data Labels",
                                properties: {
                                    show: {
                                        displayName: "Show",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    fill: {
                                        displayName: "Color",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    fontSize: {
                                        displayName: "Font Size",
                                        type: {
                                            formatting: {
                                                fontSize: !0
                                            }
                                        }
                                    }
                                }
                            },
                            dateType: {
                                displayName: "Gantt Date Type",
                                properties: {
                                    type: {
                                        displayName: "Type",
                                        type: {
                                            enumeration: GanttSettings.createEnumTypeFromEnum(GanttDateType)
                                        }
                                    }
                                }
                            }
                        },
                        sorting: {
                            default: {}
                        }
                    }, Gantt;
                }();
                samples.Gantt = Gantt;
                var GanttChartBehavior = function() {
                    function GanttChartBehavior() {}
                    return GanttChartBehavior.prototype.bindEvents = function(options, selectionHandler) {
                        this.options = options;
                        var clearCatcher = options.clearCatcher;
                        options.taskSelection.on("click", function(d) {
                            selectionHandler.handleSelection(d, d3.event.ctrlKey), d3.event.stopPropagation();
                        }), clearCatcher.on("click", function() {
                            selectionHandler.handleClearSelection();
                        });
                    }, GanttChartBehavior.prototype.renderSelection = function(hasSelection) {
                        this.options.taskSelection.style("opacity", function(d) {
                            return hasSelection && !d.selected ? Gantt.DefaultValues.MinTaskOpacity : Gantt.DefaultValues.MaxTaskOpacity;
                        });
                    }, GanttChartBehavior;
                }();
                samples.GanttChartBehavior = GanttChartBehavior;
                var GanttChartWarning = function() {
                    function GanttChartWarning() {}
                    return Object.defineProperty(GanttChartWarning.prototype, "code", {
                        get: function() {
                            return "GanttChartWarning";
                        },
                        enumerable: !0,
                        configurable: !0
                    }), GanttChartWarning.prototype.getMessages = function(resourceProvider) {
                        var visualMessage, message = "This visual requires task value", titleKey = "", detailKey = "";
                        return visualMessage = {
                            message: message,
                            title: resourceProvider.get(titleKey),
                            detail: resourceProvider.get(detailKey)
                        };
                    }, GanttChartWarning;
                }();
                samples.GanttChartWarning = GanttChartWarning;
            }(samples = visuals.samples || (visuals.samples = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, jsCommon = window.jsCommon, powerbi = window.powerbi, __extends = (window.powerbitests, 
    window.InJs, window.debug, window.jasmine, window.Microsoft, this && this.__extends || function(d, b) {
        function __() {
            this.constructor = d;
        }
        for (var p in b) b.hasOwnProperty(p) && (d[p] = b[p]);
        d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, new __());
    });
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var samples;
            !function(samples) {
                var createClassAndSelector = jsCommon.CssConstants.createClassAndSelector, convertToPx = jsCommon.PixelConverter.toString, convertToPt = jsCommon.PixelConverter.fromPoint, fromPointToPixel = jsCommon.PixelConverter.fromPointToPixel, createEnumType = powerbi.createEnumType, DataViewObjects = powerbi.DataViewObjects, TextMeasurementService = powerbi.TextMeasurementService, VisualDataRoleKind = powerbi.VisualDataRoleKind, SQExprBuilder = powerbi.data.SQExprBuilder, SemanticFilter = powerbi.data.SemanticFilter, appendClearCatcher = powerbi.visuals.appendClearCatcher, SVGUtil = powerbi.visuals.SVGUtil, getLabelFormattedText = powerbi.visuals.dataLabelUtils.getLabelFormattedText, ObjectEnumerationBuilder = powerbi.visuals.ObjectEnumerationBuilder, SelectionManager = powerbi.visuals.utility.SelectionManager;
                samples.Months = createEnumType([ {
                    value: 1,
                    displayName: "January"
                }, {
                    value: 2,
                    displayName: "February"
                }, {
                    value: 3,
                    displayName: "March"
                }, {
                    value: 4,
                    displayName: "April"
                }, {
                    value: 5,
                    displayName: "May"
                }, {
                    value: 6,
                    displayName: "June"
                }, {
                    value: 7,
                    displayName: "July"
                }, {
                    value: 8,
                    displayName: "August"
                }, {
                    value: 9,
                    displayName: "September"
                }, {
                    value: 10,
                    displayName: "October"
                }, {
                    value: 11,
                    displayName: "November"
                }, {
                    value: 12,
                    displayName: "December"
                } ]), samples.WeekDays = createEnumType([ {
                    value: 0,
                    displayName: "Sunday"
                }, {
                    value: 1,
                    displayName: "Monday"
                }, {
                    value: 2,
                    displayName: "Tuesday"
                }, {
                    value: 3,
                    displayName: "Wednesday"
                }, {
                    value: 4,
                    displayName: "Thursday"
                }, {
                    value: 5,
                    displayName: "Friday"
                }, {
                    value: 6,
                    displayName: "Saturday"
                } ]), samples.Granularities = createEnumType([ {
                    value: 0,
                    displayName: "Year"
                }, {
                    value: 1,
                    displayName: "Quarter"
                }, {
                    value: 2,
                    displayName: "Month"
                }, {
                    value: 3,
                    displayName: "Week"
                }, {
                    value: 4,
                    displayName: "Day"
                } ]), function(GranularityType) {
                    GranularityType[GranularityType.year = 0] = "year", GranularityType[GranularityType.quarter = 1] = "quarter", 
                    GranularityType[GranularityType.month = 2] = "month", GranularityType[GranularityType.week = 3] = "week", 
                    GranularityType[GranularityType.day = 4] = "day";
                }(samples.GranularityType || (samples.GranularityType = {}));
                var GranularityType = samples.GranularityType, SelectedCellColorProp = {
                    objectName: "cells",
                    propertyName: "fillSelected"
                }, UnselectedCellColorProp = {
                    objectName: "cells",
                    propertyName: "fillUnselected"
                }, GranularityProp = {
                    objectName: "granularity",
                    propertyName: "granularity"
                }, ScaleColorProp = {
                    objectName: "granularity",
                    propertyName: "scaleColor"
                }, SliderColorProp = {
                    objectName: "granularity",
                    propertyName: "sliderColor"
                }, TimeRangeColorProp = {
                    objectName: "rangeHeader",
                    propertyName: "fontColor"
                }, TimeRangeSizeProp = {
                    objectName: "rangeHeader",
                    propertyName: "textSize"
                }, TimeRangeShowProp = {
                    objectName: "rangeHeader",
                    propertyName: "show"
                }, LabelsColorProp = {
                    objectName: "labels",
                    propertyName: "fontColor"
                }, LabelsSizeProp = {
                    objectName: "labels",
                    propertyName: "textSize"
                }, LabelsShowProp = {
                    objectName: "labels",
                    propertyName: "show"
                }, CalendarMonthProp = {
                    objectName: "calendar",
                    propertyName: "month"
                }, CalendarDayProp = {
                    objectName: "calendar",
                    propertyName: "day"
                }, WeekDayProp = {
                    objectName: "weekDay",
                    propertyName: "day"
                }, GranularityNames = [ {
                    granularityType: GranularityType.year,
                    name: "year"
                }, {
                    granularityType: GranularityType.quarter,
                    name: "quarter"
                }, {
                    granularityType: GranularityType.month,
                    name: "month"
                }, {
                    granularityType: GranularityType.week,
                    name: "week"
                }, {
                    granularityType: GranularityType.day,
                    name: "day"
                } ], TimelineGranularity = function() {
                    function TimelineGranularity() {
                        this.datePeriods = [];
                    }
                    return TimelineGranularity.prototype.shortMonthName = function(date) {
                        return date.toString().split(" ")[1];
                    }, TimelineGranularity.prototype.resetDatePeriods = function() {
                        this.datePeriods = [];
                    }, TimelineGranularity.prototype.getDatePeriods = function() {
                        return this.datePeriods;
                    }, TimelineGranularity.prototype.getExtendedLabel = function() {
                        return this.extendedLabel;
                    }, TimelineGranularity.prototype.setExtendedLabel = function(extendedLabel) {
                        this.extendedLabel = extendedLabel;
                    }, TimelineGranularity.prototype.createLabels = function(granularity) {
                        var lastDatePeriod, labels = [];
                        return this.datePeriods.forEach(function(x) {
                            !_.isEmpty(labels) && granularity.sameLabel(x, lastDatePeriod) || (lastDatePeriod = x, 
                            labels.push(granularity.generateLabel(x)));
                        }), labels;
                    }, TimelineGranularity.prototype.addDate = function(date, identifierArray) {
                        var datePeriods = this.getDatePeriods(), lastDatePeriod = datePeriods[datePeriods.length - 1];
                        0 !== datePeriods.length && _.isEqual(lastDatePeriod.identifierArray, identifierArray) ? lastDatePeriod.endDate = date : (datePeriods.length > 0 && (lastDatePeriod.endDate = date), 
                        datePeriods.push({
                            identifierArray: identifierArray,
                            startDate: date,
                            endDate: date,
                            week: this.determineWeek(date),
                            year: this.determineYear(date),
                            fraction: 1,
                            index: datePeriods.length
                        }));
                    }, TimelineGranularity.prototype.setNewEndDate = function(date) {
                        _.last(this.datePeriods).endDate = date;
                    }, TimelineGranularity.prototype.splitPeriod = function(index, newFraction, newDate) {
                        var oldDatePeriod = this.datePeriods[index];
                        oldDatePeriod.fraction -= newFraction;
                        var newDateObject = {
                            identifierArray: oldDatePeriod.identifierArray,
                            startDate: newDate,
                            endDate: oldDatePeriod.endDate,
                            week: this.determineWeek(newDate),
                            year: this.determineYear(newDate),
                            fraction: newFraction,
                            index: oldDatePeriod.index + oldDatePeriod.fraction
                        };
                        oldDatePeriod.endDate = newDate, this.datePeriods.splice(index + 1, 0, newDateObject);
                    }, TimelineGranularity.prototype.previousMonth = function(month) {
                        return month > 0 ? month - 1 : 11;
                    }, TimelineGranularity.prototype.nextMonth = function(month) {
                        return month < 11 ? month + 1 : 0;
                    }, TimelineGranularity.prototype.countWeeks = function(startDate, endDate) {
                        var totalDays;
                        if (endDate.getFullYear() === startDate.getFullYear() && endDate.getMonth() === startDate.getMonth() && endDate.getDate() >= startDate.getDate()) totalDays = endDate.getDate() - startDate.getDate(); else {
                            totalDays = endDate.getDate() - 1;
                            for (var lastMonth = this.nextMonth(startDate.getMonth()), month = endDate.getMonth(); month !== lastMonth; ) totalDays += new Date(endDate.getFullYear(), month, 0).getDate(), 
                            month = this.previousMonth(month);
                            totalDays += new Date(endDate.getFullYear(), lastMonth, 0).getDate() - startDate.getDate();
                        }
                        return 1 + Math.floor(totalDays / 7);
                    }, TimelineGranularity.prototype.determineWeek = function(date) {
                        var year = date.getFullYear();
                        this.inPreviousYear(date) && year--;
                        var dateOfFirstWeek = Timeline.calendar.getDateOfFirstWeek(year), weeks = this.countWeeks(dateOfFirstWeek, date);
                        return [ weeks, year ];
                    }, TimelineGranularity.prototype.inPreviousYear = function(date) {
                        var dateOfFirstWeek = Timeline.calendar.getDateOfFirstWeek(date.getFullYear());
                        return date < dateOfFirstWeek;
                    }, TimelineGranularity.prototype.determineYear = function(date) {
                        var firstDay = new Date(date.getFullYear(), Timeline.calendar.getFirstMonthOfYear(), Timeline.calendar.getFirstDayOfYear());
                        return date.getFullYear() - (firstDay <= date ? 0 : 1);
                    }, TimelineGranularity;
                }();
                samples.TimelineGranularity = TimelineGranularity;
                var DayGranularity = function(_super) {
                    function DayGranularity() {
                        _super.apply(this, arguments);
                    }
                    return __extends(DayGranularity, _super), DayGranularity.prototype.getType = function() {
                        return GranularityType.day;
                    }, DayGranularity.prototype.splitDate = function(date) {
                        return [ this.shortMonthName(date), date.getDate(), date.getFullYear() ];
                    }, DayGranularity.prototype.sameLabel = function(firstDatePeriod, secondDatePeriod) {
                        return firstDatePeriod.startDate.getTime() === secondDatePeriod.startDate.getTime();
                    }, DayGranularity.prototype.generateLabel = function(datePeriod) {
                        return {
                            title: this.shortMonthName(datePeriod.startDate) + " " + datePeriod.startDate.getDate() + " - " + datePeriod.year,
                            text: datePeriod.startDate.getDate().toString(),
                            id: datePeriod.index
                        };
                    }, DayGranularity;
                }(TimelineGranularity);
                samples.DayGranularity = DayGranularity;
                var MonthGranularity = function(_super) {
                    function MonthGranularity() {
                        _super.apply(this, arguments);
                    }
                    return __extends(MonthGranularity, _super), MonthGranularity.prototype.getType = function() {
                        return GranularityType.month;
                    }, MonthGranularity.prototype.splitDate = function(date) {
                        return [ this.shortMonthName(date), date.getFullYear() ];
                    }, MonthGranularity.prototype.sameLabel = function(firstDatePeriod, secondDatePeriod) {
                        return this.shortMonthName(firstDatePeriod.startDate) === this.shortMonthName(secondDatePeriod.startDate);
                    }, MonthGranularity.prototype.generateLabel = function(datePeriod) {
                        var shortMonthName = this.shortMonthName(datePeriod.startDate);
                        return {
                            title: shortMonthName,
                            text: shortMonthName,
                            id: datePeriod.index
                        };
                    }, MonthGranularity;
                }(TimelineGranularity);
                samples.MonthGranularity = MonthGranularity;
                var WeekGranularity = function(_super) {
                    function WeekGranularity() {
                        _super.apply(this, arguments);
                    }
                    return __extends(WeekGranularity, _super), WeekGranularity.prototype.getType = function() {
                        return GranularityType.week;
                    }, WeekGranularity.prototype.splitDate = function(date) {
                        return this.determineWeek(date);
                    }, WeekGranularity.prototype.sameLabel = function(firstDatePeriod, secondDatePeriod) {
                        return _.isEqual(firstDatePeriod.week, secondDatePeriod.week);
                    }, WeekGranularity.prototype.generateLabel = function(datePeriod) {
                        return {
                            title: "Week " + datePeriod.week[0] + " - " + datePeriod.week[1],
                            text: "W" + datePeriod.week[0],
                            id: datePeriod.index
                        };
                    }, WeekGranularity;
                }(TimelineGranularity);
                samples.WeekGranularity = WeekGranularity;
                var QuarterGranularity = function(_super) {
                    function QuarterGranularity() {
                        _super.apply(this, arguments);
                    }
                    return __extends(QuarterGranularity, _super), QuarterGranularity.prototype.quarterText = function(date) {
                        for (var quarter = 3, year = date.getFullYear(); date < Timeline.calendar.getQuarterStartDate(year, quarter); ) quarter > 0 ? quarter-- : (quarter = 3, 
                        year--);
                        return quarter++, "Q" + quarter;
                    }, QuarterGranularity.prototype.getType = function() {
                        return GranularityType.quarter;
                    }, QuarterGranularity.prototype.splitDate = function(date) {
                        return [ this.quarterText(date), date.getFullYear() ];
                    }, QuarterGranularity.prototype.sameLabel = function(firstDatePeriod, secondDatePeriod) {
                        return this.quarterText(firstDatePeriod.startDate) === this.quarterText(secondDatePeriod.startDate) && firstDatePeriod.year === secondDatePeriod.year;
                    }, QuarterGranularity.prototype.generateLabel = function(datePeriod) {
                        var quarter = this.quarterText(datePeriod.startDate);
                        return {
                            title: quarter + " " + datePeriod.year,
                            text: quarter,
                            id: datePeriod.index
                        };
                    }, QuarterGranularity;
                }(TimelineGranularity);
                samples.QuarterGranularity = QuarterGranularity;
                var YearGranularity = function(_super) {
                    function YearGranularity() {
                        _super.apply(this, arguments);
                    }
                    return __extends(YearGranularity, _super), YearGranularity.prototype.getType = function() {
                        return GranularityType.year;
                    }, YearGranularity.prototype.splitDate = function(date) {
                        return [ date.getFullYear() ];
                    }, YearGranularity.prototype.sameLabel = function(firstDatePeriod, secondDatePeriod) {
                        return firstDatePeriod.year === secondDatePeriod.year;
                    }, YearGranularity.prototype.generateLabel = function(datePeriod) {
                        return {
                            title: "Year " + datePeriod.year,
                            text: datePeriod.year.toString(),
                            id: datePeriod.index
                        };
                    }, YearGranularity;
                }(TimelineGranularity);
                samples.YearGranularity = YearGranularity;
                var TimelineGranularityData = function() {
                    function TimelineGranularityData(startDate, endDate) {
                        this.granularities = [], this.setDatesRange(startDate, endDate);
                        var lastDate = this.dates[this.dates.length - 1];
                        this.endingDate = TimelineGranularityData.nextDay(lastDate);
                    }
                    return TimelineGranularityData.previousDay = function(date) {
                        var prevDay = new Date(date.getTime());
                        return prevDay.setDate(prevDay.getDate() - 1), prevDay;
                    }, TimelineGranularityData.nextDay = function(date) {
                        var nextDay = new Date(date.getTime());
                        return nextDay.setDate(nextDay.getDate() + 1), nextDay;
                    }, TimelineGranularityData.prototype.setDatesRange = function(startDate, endDate) {
                        var date = startDate;
                        for (this.dates = []; date <= endDate; ) this.dates.push(date), date = TimelineGranularityData.nextDay(date);
                    }, TimelineGranularityData.prototype.addGranularity = function(granularity) {
                        granularity.resetDatePeriods();
                        for (var _i = 0, _a = this.dates; _i < _a.length; _i++) {
                            var date = _a[_i], identifierArray = granularity.splitDate(date);
                            granularity.addDate(date, identifierArray);
                        }
                        granularity.setNewEndDate(this.endingDate), this.granularities.push(granularity);
                    }, TimelineGranularityData.prototype.getGranularity = function(index) {
                        return this.granularities[index];
                    }, TimelineGranularityData.prototype.createGranularities = function() {
                        this.granularities = [], this.addGranularity(new YearGranularity()), this.addGranularity(new QuarterGranularity()), 
                        this.addGranularity(new MonthGranularity()), this.addGranularity(new WeekGranularity()), 
                        this.addGranularity(new DayGranularity());
                    }, TimelineGranularityData.prototype.createLabels = function() {
                        var _this = this;
                        this.granularities.forEach(function(x) {
                            x.setExtendedLabel({
                                dayLabels: x.getType() >= GranularityType.day ? x.createLabels(_this.granularities[GranularityType.day]) : [],
                                weekLabels: x.getType() >= GranularityType.week ? x.createLabels(_this.granularities[GranularityType.week]) : [],
                                monthLabels: x.getType() >= GranularityType.month ? x.createLabels(_this.granularities[GranularityType.month]) : [],
                                quarterLabels: x.getType() >= GranularityType.quarter ? x.createLabels(_this.granularities[GranularityType.quarter]) : [],
                                yearLabels: x.getType() >= GranularityType.year ? x.createLabels(_this.granularities[GranularityType.year]) : []
                            });
                        });
                    }, TimelineGranularityData;
                }();
                samples.TimelineGranularityData = TimelineGranularityData;
                var Utils = function() {
                    function Utils() {}
                    return Utils.isValueEmpty = function(value) {
                        return void 0 === value || null === value || isNaN(value);
                    }, Utils.getStartSelectionDate = function(timelineData) {
                        return timelineData.currentGranularity.getDatePeriods()[timelineData.selectionStartIndex].startDate;
                    }, Utils.getEndSelectionDate = function(timelineData) {
                        return timelineData.currentGranularity.getDatePeriods()[timelineData.selectionEndIndex].endDate;
                    }, Utils.getEndSelectionPeriod = function(timelineData) {
                        return timelineData.currentGranularity.getDatePeriods()[timelineData.selectionEndIndex];
                    }, Utils.getCellColor = function(d, timelineData, cellFormat) {
                        var inSelectedPeriods = d.datePeriod.startDate >= Utils.getStartSelectionDate(timelineData) && d.datePeriod.endDate <= Utils.getEndSelectionDate(timelineData);
                        return inSelectedPeriods ? cellFormat.colorInProperty : cellFormat.colorOutProperty || "transparent";
                    }, Utils.getGranularityType = function(granularityName) {
                        var index = _.findIndex(GranularityNames, function(x) {
                            return x.name === granularityName;
                        });
                        return GranularityNames[index].granularityType;
                    }, Utils.getGranularityName = function(granularity) {
                        var index = _.findIndex(GranularityNames, function(x) {
                            return x.granularityType === granularity;
                        });
                        return GranularityNames[index].name;
                    }, Utils.separateSelection = function(timelineData, startDate, endDate) {
                        var datePeriods = timelineData.currentGranularity.getDatePeriods(), startDateIndex = _.findIndex(datePeriods, function(x) {
                            return startDate < x.endDate;
                        }), endDateIndex = _.findIndex(datePeriods, function(x) {
                            return endDate <= x.endDate;
                        });
                        timelineData.selectionStartIndex = startDateIndex, timelineData.selectionEndIndex = endDateIndex;
                        var startRatio = Utils.getDateRatio(datePeriods[startDateIndex], startDate, !0), endRatio = Utils.getDateRatio(datePeriods[endDateIndex], endDate, !1);
                        if (endRatio > 0 && timelineData.currentGranularity.splitPeriod(endDateIndex, endRatio, endDate), 
                        startRatio > 0) {
                            var startFration = datePeriods[startDateIndex].fraction - startRatio;
                            timelineData.currentGranularity.splitPeriod(startDateIndex, startFration, startDate), 
                            timelineData.selectionStartIndex++, timelineData.selectionEndIndex++;
                        }
                    }, Utils.getDateRatio = function(datePeriod, date, fromStart) {
                        var dateDifference = fromStart ? date.getTime() - datePeriod.startDate.getTime() : datePeriod.endDate.getTime() - date.getTime(), periodDifference = datePeriod.endDate.getTime() - datePeriod.startDate.getTime();
                        return 0 === periodDifference ? 0 : dateDifference / periodDifference;
                    }, Utils.timeRangeText = function(timelineData) {
                        var startSelectionDateArray = timelineData.currentGranularity.splitDate(Utils.getStartSelectionDate(timelineData)), endSelectionDateArray = timelineData.currentGranularity.splitDate(Utils.getEndSelectionPeriod(timelineData).startDate);
                        return startSelectionDateArray.join(" ") + " - " + endSelectionDateArray.join(" ");
                    }, Utils.dateRangeText = function(datePeriod) {
                        return datePeriod.startDate.toDateString() + " - " + TimelineGranularityData.previousDay(datePeriod.endDate).toDateString();
                    }, Utils.unseparateSelection = function(datePeriods) {
                        var separationIndex = _.findIndex(datePeriods, function(x) {
                            return x.fraction < 1;
                        });
                        return separationIndex >= 0 && (datePeriods[separationIndex].endDate = datePeriods[separationIndex + 1].endDate, 
                        datePeriods[separationIndex].fraction += datePeriods[separationIndex + 1].fraction, 
                        datePeriods.splice(separationIndex + 1, 1), !0);
                    }, Utils;
                }();
                samples.Utils = Utils;
                var Calendar = function() {
                    function Calendar(calendarFormat) {
                        var _this = this;
                        this.firstDayOfWeek = calendarFormat.weekDayProperty, this.firstMonthOfYear = calendarFormat.firstMonthProperty - 1, 
                        this.firstDayOfYear = calendarFormat.firstDayProperty, this.dateOfFirstWeek = {}, 
                        this.quarterFirstMonths = [ 0, 3, 6, 9 ].map(function(x) {
                            return x + _this.firstMonthOfYear;
                        });
                    }
                    return Calendar.prototype.getFirstDayOfWeek = function() {
                        return this.firstDayOfWeek;
                    }, Calendar.prototype.getFirstMonthOfYear = function() {
                        return this.firstMonthOfYear;
                    }, Calendar.prototype.getFirstDayOfYear = function() {
                        return this.firstDayOfYear;
                    }, Calendar.prototype.getQuarterStartDate = function(year, quarterIndex) {
                        return new Date(year, this.quarterFirstMonths[quarterIndex], this.firstDayOfYear);
                    }, Calendar.prototype.isChanged = function(calendarFormat) {
                        return this.firstMonthOfYear !== calendarFormat.firstMonthProperty - 1 || this.firstDayOfYear !== calendarFormat.firstDayProperty || this.firstDayOfWeek !== calendarFormat.weekDayProperty;
                    }, Calendar.prototype.calculateDateOfFirstWeek = function(year) {
                        for (var date = new Date(year, this.firstMonthOfYear, this.firstDayOfYear); date.getDay() !== this.firstDayOfWeek; ) date = TimelineGranularityData.nextDay(date);
                        return date;
                    }, Calendar.prototype.getDateOfFirstWeek = function(year) {
                        return this.dateOfFirstWeek[year] || (this.dateOfFirstWeek[year] = this.calculateDateOfFirstWeek(year)), 
                        this.dateOfFirstWeek[year];
                    }, Calendar;
                }();
                samples.Calendar = Calendar;
                var Timeline = function() {
                    function Timeline() {
                        var _this = this;
                        this.datasetsChangedState = !1, this.granularitySelectors = [ "Y", "Q", "M", "W", "D" ], 
                        this.requiresNoUpdate = !1, this.timelineMargins = {
                            LeftMargin: 15,
                            RightMargin: 15,
                            TopMargin: 15,
                            BottomMargin: 10,
                            CellWidth: 40,
                            CellHeight: 25,
                            StartXpoint: 10,
                            StartYpoint: 20,
                            ElementWidth: 30,
                            MinCellWidth: 30,
                            MaxCellHeight: 60,
                            PeriodSlicerRectWidth: 15,
                            PeriodSlicerRectHeight: 23
                        }, this.defaultTimelineProperties = {
                            DefaultLabelsShow: !0,
                            TimelineDefaultTextSize: 9,
                            TimelineDefaultCellColor: "#ADD8E6",
                            TimelineDefaultCellColorOut: "",
                            TimelineDefaultTimeRangeShow: !0,
                            DefaultTimeRangeColor: "#777777",
                            DefaultLabelColor: "#777777",
                            DefaultScaleColor: "#000000",
                            DefaultSliderColor: "#AAAAAA",
                            DefaultGranularity: GranularityType.month,
                            DefaultFirstMonth: 1,
                            DefaultFirstDay: 1,
                            DefaultFirstWeekDay: 0
                        }, this.timelineSelectors = {
                            TimelineVisual: createClassAndSelector("timeline"),
                            SelectionRangeContainer: createClassAndSelector("selectionRangeContainer"),
                            textLabel: createClassAndSelector("label"),
                            LowerTextCell: createClassAndSelector("lowerTextCell"),
                            UpperTextCell: createClassAndSelector("upperTextCell"),
                            UpperTextArea: createClassAndSelector("upperTextArea"),
                            LowerTextArea: createClassAndSelector("lowerTextArea"),
                            RangeTextArea: createClassAndSelector("rangeTextArea"),
                            CellsArea: createClassAndSelector("cellsArea"),
                            CursorsArea: createClassAndSelector("cursorsArea"),
                            MainArea: createClassAndSelector("mainArea"),
                            SelectionCursor: createClassAndSelector("selectionCursor"),
                            Cell: createClassAndSelector("cell"),
                            CellRect: createClassAndSelector("cellRect"),
                            VertLine: createClassAndSelector("timelineVertLine"),
                            TimelineSlicer: createClassAndSelector("timelineSlicer"),
                            PeriodSlicerGranularities: createClassAndSelector("periodSlicerGranularities"),
                            PeriodSlicerSelection: createClassAndSelector("periodSlicerSelection"),
                            PeriodSlicerSelectionRect: createClassAndSelector("periodSlicerSelectionRect"),
                            PeriodSlicerRect: createClassAndSelector("periodSlicerRect")
                        }, this.drag = d3.behavior.drag().origin(function(cursorDataPoint) {
                            return cursorDataPoint.x = cursorDataPoint.selectionIndex * _this.timelineProperties.cellWidth, 
                            cursorDataPoint;
                        }).on("drag", function(cursorDataPoint) {
                            _this.dragged(cursorDataPoint);
                        }).on("dragend", function() {
                            _this.dragended();
                        });
                    }
                    return Timeline.getIndexByPosition = function(elements, widthOfElement, position) {
                        elements = elements || [];
                        var length = elements.length;
                        if (!Utils.isValueEmpty(elements[0]) && !Utils.isValueEmpty(elements[1]) && position <= elements[1] * widthOfElement) return 0;
                        if (!Utils.isValueEmpty(elements[length - 1]) && position >= elements[length - 1] * widthOfElement) return length - 1;
                        for (var i = 1; i < length; i++) {
                            var left = elements[i] * widthOfElement, right = elements[i + 1] * widthOfElement;
                            if (position >= left && position <= right) return i;
                        }
                        return 0;
                    }, Timeline.prototype.changeGranularity = function(granularity, startDate, endDate) {
                        Utils.unseparateSelection(this.timelineData.currentGranularity.getDatePeriods()) && Utils.unseparateSelection(this.timelineData.currentGranularity.getDatePeriods()), 
                        this.timelineData.currentGranularity = this.timelineGranularityData.getGranularity(granularity), 
                        Utils.separateSelection(this.timelineData, startDate, endDate);
                    }, Timeline.prototype.init = function(options) {
                        var element = options.element;
                        this.hostServices = options.host, this.initialized = !1, this.selectionManager = new SelectionManager({
                            hostServices: options.host
                        }), this.timelineProperties = {
                            element: element,
                            textYPosition: 50,
                            cellsYPosition: 3 * this.timelineMargins.TopMargin + 65,
                            topMargin: this.timelineMargins.TopMargin,
                            bottomMargin: this.timelineMargins.BottomMargin,
                            leftMargin: this.timelineMargins.LeftMargin,
                            startXpoint: this.timelineMargins.StartXpoint,
                            startYpoint: this.timelineMargins.StartYpoint,
                            cellWidth: this.timelineMargins.CellWidth,
                            cellHeight: this.timelineMargins.CellHeight,
                            elementWidth: this.timelineMargins.ElementWidth,
                            rightMargin: this.timelineMargins.RightMargin
                        }, this.body = d3.select(element.get(0)), this.timelineDiv = this.body.append("div"), 
                        this.svg = this.timelineDiv.append("svg").attr("width", convertToPx(options.viewport.width)).classed(this.timelineSelectors.TimelineVisual.class, !0), 
                        this.addWrappElements();
                    }, Timeline.prototype.addWrappElements = function() {
                        this.clearCatcher = appendClearCatcher(this.svg), this.clearCatcher.data([ this ]).on("click", function(timeline) {
                            return timeline.clear();
                        }).on("touchstart", function(timeline) {
                            return timeline.clear();
                        }), this.rangeText = this.svg.append("g").classed(this.timelineSelectors.RangeTextArea.class, !0).append("text"), 
                        this.mainGroupElement = this.svg.append("g").classed(this.timelineSelectors.MainArea.class, !0), 
                        this.yearLabelsElement = this.mainGroupElement.append("g"), this.quarterLabelsElement = this.mainGroupElement.append("g"), 
                        this.monthLabelsElement = this.mainGroupElement.append("g"), this.weekLabelsElement = this.mainGroupElement.append("g"), 
                        this.dayLabelsElement = this.mainGroupElement.append("g"), this.cellsElement = this.mainGroupElement.append("g").classed(this.timelineSelectors.CellsArea.class, !0), 
                        this.cursorGroupElement = this.svg.append("g").classed(this.timelineSelectors.CursorsArea.class, !0);
                    }, Timeline.prototype.clear = function() {
                        this.initialized && (this.selectionManager.clear(), this.timelineData && (this.timelineData.selectionStartIndex = 0, 
                        this.timelineData.selectionEndIndex = this.timelineData.currentGranularity.getDatePeriods().length - 1, 
                        _.any(this.timelineData.timelineDatapoints, function(x) {
                            return x.index % 1 !== 0;
                        }) ? this.selectPeriod(this.timelineData.currentGranularity.getType()) : (Timeline.updateCursors(this.timelineData, this.timelineProperties.cellWidth), 
                        this.fillCells(this.timelineFormat.cellFormat), this.renderCursors(this.timelineData, this.timelineFormat, this.timelineProperties.cellHeight, this.timelineProperties.cellsYPosition), 
                        this.renderTimeRangeText(this.timelineData, this.timelineFormat.rangeTextFormat), 
                        this.fillColorGranularity(this.timelineFormat.granularityFormat)), this.setSelection(this.timelineData)));
                    }, Timeline.prototype.drawGranular = function(timelineProperties, type) {
                        var _this = this, startXpoint = timelineProperties.startXpoint, startYpoint = timelineProperties.startYpoint, elementWidth = timelineProperties.elementWidth, selectorPeriods = this.granularitySelectors;
                        this.selectorContainer = this.svg.append("g").classed(this.timelineSelectors.TimelineSlicer.class, !0);
                        var dragPeriodRect = d3.behavior.drag().on("drag", function() {
                            _this.selectPeriod(_this.getGranularityIndexByPosition(d3.event.x));
                        });
                        this.selectorContainer.call(dragPeriodRect), this.horizLine = this.selectorContainer.append("rect"), 
                        this.horizLine.attr({
                            x: convertToPx(startXpoint),
                            y: convertToPx(startYpoint + 2),
                            height: convertToPx(1),
                            width: convertToPx((selectorPeriods.length - 1) * elementWidth)
                        }), this.vertLine = this.selectorContainer.selectAll("vertLines").data(selectorPeriods).enter().append("rect"), 
                        this.vertLine.classed(this.timelineSelectors.VertLine.class, !0).attr({
                            x: function(d, index) {
                                return convertToPx(startXpoint + index * elementWidth);
                            },
                            y: convertToPx(startYpoint),
                            width: convertToPx(2),
                            height: convertToPx(3)
                        });
                        var text = this.selectorContainer.selectAll(this.timelineSelectors.PeriodSlicerGranularities.selector).data(selectorPeriods).enter().append("text").classed(this.timelineSelectors.PeriodSlicerGranularities.class, !0);
                        this.textLabels = text.text(function(value) {
                            return value;
                        }).attr({
                            x: function(d, index) {
                                return convertToPx(startXpoint - 3 + index * elementWidth);
                            },
                            y: convertToPx(startYpoint - 3),
                            dx: "0.5em"
                        }), this.selectedText = this.selectorContainer.append("text").classed(this.timelineSelectors.PeriodSlicerSelection.class, !0), 
                        this.selectedText.text(Utils.getGranularityName(type)).attr({
                            x: convertToPx(startXpoint + 2 * elementWidth),
                            y: convertToPx(startYpoint + 17)
                        });
                        var selRects = this.selectorContainer.selectAll(this.timelineSelectors.PeriodSlicerSelectionRect.selector).data(selectorPeriods).enter().append("rect").classed(this.timelineSelectors.PeriodSlicerSelectionRect.class, !0), clickHandler = function(d, index) {
                            _this.selectPeriod(index);
                        };
                        selRects.attr({
                            x: function(d, index) {
                                return convertToPx(startXpoint - elementWidth / 2 + index * elementWidth);
                            },
                            y: convertToPx(3),
                            width: convertToPx(elementWidth),
                            height: convertToPx(23)
                        }).on("mousedown", clickHandler).on("touchstart", clickHandler), this.periodSlicerRect = this.selectorContainer.append("rect").classed(this.timelineSelectors.PeriodSlicerRect.class, !0).attr({
                            y: convertToPx(timelineProperties.startYpoint - 16),
                            rx: convertToPx(4),
                            width: convertToPx(15),
                            height: convertToPx(23)
                        }), this.setPeriodSlicerRectPosition(type);
                    }, Timeline.prototype.getGranularityIndexByPosition = function(position) {
                        var selectorIndexes = this.granularitySelectors.map(function(selector, index) {
                            return index;
                        });
                        return Timeline.getIndexByPosition(selectorIndexes, this.timelineProperties.elementWidth, position);
                    }, Timeline.prototype.setPeriodSlicerRectPosition = function(granularity) {
                        return this.periodSlicerRect.datum() !== granularity && (this.periodSlicerRect.data([ granularity ]), 
                        this.periodSlicerRect.transition().attr({
                            x: convertToPx(this.timelineProperties.startXpoint - 6 + granularity * this.timelineProperties.elementWidth)
                        }), this.selectedText.text(Utils.getGranularityName(granularity)), !0);
                    }, Timeline.prototype.fillColorGranularity = function(granularityFormat) {
                        this.periodSlicerRect.style("stroke", granularityFormat.sliderColorProperty), this.selectedText.attr("fill", granularityFormat.scaleColorProperty), 
                        this.textLabels.attr("fill", granularityFormat.scaleColorProperty), this.vertLine.attr("fill", granularityFormat.scaleColorProperty), 
                        this.horizLine.attr("fill", granularityFormat.scaleColorProperty);
                    }, Timeline.prototype.redrawPeriod = function(granularity) {
                        if (this.setPeriodSlicerRectPosition(granularity)) {
                            var startDate = Utils.getStartSelectionDate(this.timelineData), endDate = Utils.getEndSelectionDate(this.timelineData);
                            this.changeGranularity(granularity, startDate, endDate);
                        }
                    }, Timeline.setMeasures = function(labelFormat, granularityType, datePeriodsCount, viewport, timelineProperties, timelineMargins) {
                        timelineProperties.cellsYPosition = timelineProperties.textYPosition;
                        var labelSize = fromPointToPixel(labelFormat.sizeProperty);
                        labelFormat.showProperty && (timelineProperties.cellsYPosition += 1.5 * labelSize * (granularityType + 1));
                        var svgHeight = Math.max(0, viewport.height - timelineMargins.TopMargin), maxHeight = viewport.width - timelineMargins.RightMargin - timelineMargins.MinCellWidth * datePeriodsCount, height = Math.max(timelineMargins.MinCellWidth, Math.min(timelineMargins.MaxCellHeight, maxHeight, svgHeight - timelineProperties.cellsYPosition - 20)), width = Math.max(timelineMargins.MinCellWidth, (viewport.width - height - timelineMargins.RightMargin) / datePeriodsCount);
                        timelineProperties.cellHeight = height, timelineProperties.cellWidth = width;
                    }, Timeline.prototype.visualChangeOnly = function(options) {
                        if (options && options.dataViews && options.dataViews[0] && options.dataViews[0].metadata && this.options && this.options.dataViews && this.options.dataViews[0] && this.options.dataViews[0].metadata) {
                            var newObjects_1 = options.dataViews[0].metadata.objects, oldObjects_1 = this.options.dataViews[0].metadata.objects, properties = [ "rangeHeader", "cells", "labels", "granularity" ], metadataChanged = !properties.every(function(x) {
                                return _.isEqual(newObjects_1 ? newObjects_1[x] : void 0, oldObjects_1 ? oldObjects_1[x] : void 0);
                            });
                            return options.suppressAnimations || metadataChanged;
                        }
                        return !1;
                    }, Timeline.prototype.datasetsChanged = function(options) {
                        if (options && options.dataViews && options.dataViews[0] && options.dataViews[0].categorical && options.dataViews[0].categorical.categories && options.dataViews[0].categorical.categories[0] && options.dataViews[0].categorical.categories[0].source && this.options && this.options.dataViews && this.options.dataViews[0] && this.options.dataViews[0].categorical && this.options.dataViews[0].categorical.categories && this.options.dataViews[0].categorical.categories[0] && this.options.dataViews[0].categorical.categories[0].source) {
                            var newObjects = options.dataViews[0].categorical.categories[0].source.displayName, oldObjects = this.options.dataViews[0].categorical.categories[0].source.displayName;
                            if (!_.isEqual(newObjects, oldObjects)) return !0;
                        }
                        return !1;
                    }, Timeline.prototype.unavailableType = function(dataViewCategorical) {
                        return !(dataViewCategorical.categories && 1 === dataViewCategorical.categories.length && dataViewCategorical.categories[0].values && 0 !== dataViewCategorical.categories[0].values.length && dataViewCategorical.categories[0].source && dataViewCategorical.categories[0].source.type);
                    }, Timeline.prototype.createTimelineOptions = function(dataView) {
                        if (this.dataView = dataView, !dataView.categorical || !dataView.metadata || this.unavailableType(dataView.categorical)) return !1;
                        var columnExp = dataView.categorical.categories[0].source.expr;
                        return this.valueType = columnExp ? columnExp.level : null, !(!dataView.categorical.categories[0].source.type.dateTime && (!dataView.categorical.categories[0].source.type.numeric || "Year" !== this.valueType && "Date" !== this.valueType)) && (this.values = this.prepareDates(this.dataView.categorical.categories[0].values, this.valueType), 
                        !0);
                    }, Timeline.prototype.prepareDates = function(values, valueType) {
                        var dates = [];
                        return values.forEach(function(value) {
                            if (value) {
                                var typeOfValue = typeof value;
                                if ("string" === typeOfValue || "number" === typeOfValue) {
                                    var date = void 0;
                                    date = "Year" === valueType ? new Date(value, 0) : new Date(value), date && "Invalid Date" !== date.toString() && dates.push(date);
                                } else _.isDate(value) && dates.push(value);
                            }
                        }), dates;
                    }, Timeline.prototype.createTimelineData = function(dataView) {
                        var startDate, endDate;
                        if (startDate = _.min(this.values), endDate = _.max(this.values), this.timelineFormat = Timeline.fillTimelineFormat(this.options.dataViews[0].metadata.objects, this.defaultTimelineProperties), 
                        this.initialized || (this.drawGranular(this.timelineProperties, this.newGranularity), 
                        this.fillColorGranularity(this.timelineFormat.granularityFormat)), this.initialized) {
                            var actualEndDate = TimelineGranularityData.nextDay(endDate), daysPeriods = this.timelineGranularityData.getGranularity(GranularityType.day).getDatePeriods(), prevStartDate = daysPeriods[0].startDate, prevEndDate = daysPeriods[daysPeriods.length - 1].endDate, changedSelection = startDate.getTime() >= prevStartDate.getTime() && actualEndDate.getTime() <= prevEndDate.getTime();
                            changedSelection ? this.changeGranularity(this.newGranularity, startDate, actualEndDate) : (actualEndDate < prevEndDate && (endDate = daysPeriods[daysPeriods.length - 1].startDate), 
                            startDate > prevStartDate && (startDate = prevStartDate), this.initialized = !1);
                        }
                        this.initialized || (this.timelineGranularityData = new TimelineGranularityData(startDate, endDate), 
                        this.timelineData = {
                            elementsCount: 0,
                            timelineDatapoints: [],
                            cursorDataPoints: new Array()
                        });
                    }, Timeline.prototype.update = function(options) {
                        var visualChange = this.visualChangeOnly(options);
                        if (this.datasetsChangedState = this.datasetsChanged(options), this.requiresNoUpdate = this.requiresNoUpdate && !this.datasetsChangedState && !visualChange, 
                        this.requiresNoUpdate) return void (this.requiresNoUpdate = !1);
                        if (this.options = options, options.dataViews && options.dataViews[0]) {
                            var validOptions = this.createTimelineOptions(options.dataViews[0]);
                            if (!validOptions) return void this.clearData();
                            this.newGranularity = DataViewObjects.getValue(options.dataViews[0].metadata.objects, GranularityProp, this.defaultTimelineProperties.DefaultGranularity), 
                            visualChange || this.createTimelineData(options.dataViews[0]), this.initialized && this.redrawPeriod(this.newGranularity), 
                            this.timelineFormat = Timeline.converter(this.timelineData, this.timelineProperties, this.defaultTimelineProperties, this.timelineGranularityData, options.dataViews[0], this.initialized, this.newGranularity, options.viewport, this.timelineMargins), 
                            this.render(this.timelineData, this.timelineFormat, this.timelineProperties, options), 
                            this.initialized = !0;
                        }
                    }, Timeline.prototype.selectPeriod = function(periodNameIndex) {
                        this.timelineData.currentGranularity.getType() !== periodNameIndex && this.hostServices.persistProperties({
                            merge: [ {
                                objectName: "granularity",
                                selector: null,
                                properties: {
                                    granularity: periodNameIndex
                                }
                            } ]
                        }), this.redrawPeriod(periodNameIndex), this.timelineFormat = Timeline.converter(this.timelineData, this.timelineProperties, this.defaultTimelineProperties, this.timelineGranularityData, this.options.dataViews[0], this.initialized, this.timelineData.currentGranularity.getType(), this.options.viewport, this.timelineMargins), 
                        this.render(this.timelineData, this.timelineFormat, this.timelineProperties, this.options);
                    }, Timeline.isDataNotMatch = function(dataView) {
                        return dataView.categorical.categories.length <= 0 || void 0 === dataView.categorical.categories[0] || void 0 === dataView.categorical.categories[0].identityFields || dataView.categorical.categories[0].identityFields.length <= 0;
                    }, Timeline.converter = function(timelineData, timelineProperties, defaultTimelineProperties, timelineGranularityData, dataView, initialized, granularityType, viewport, timelineMargins) {
                        var timelineFormat = Timeline.fillTimelineFormat(dataView.metadata.objects, defaultTimelineProperties);
                        if (initialized || (timelineData.cursorDataPoints.push({
                            x: 0,
                            selectionIndex: 0,
                            cursorIndex: 0
                        }), timelineData.cursorDataPoints.push({
                            x: 0,
                            selectionIndex: 0,
                            cursorIndex: 1
                        })), initialized && !Timeline.calendar.isChanged(timelineFormat.calendarFormat) || (Timeline.calendar = new Calendar(timelineFormat.calendarFormat), 
                        timelineGranularityData.createGranularities(), timelineGranularityData.createLabels(), 
                        timelineData.currentGranularity = timelineGranularityData.getGranularity(granularityType), 
                        timelineData.selectionStartIndex = 0, timelineData.selectionEndIndex = timelineData.currentGranularity.getDatePeriods().length - 1), 
                        timelineData.categorySourceName = dataView.categorical.categories[0].source.displayName, 
                        timelineData.columnIdentity = dataView.categorical.categories[0].identityFields[0], 
                        dataView.categorical.categories[0].source.type.numeric && (timelineData.columnIdentity.ref = "Date"), 
                        !this.isDataNotMatch(dataView)) {
                            var timelineElements = timelineData.currentGranularity.getDatePeriods();
                            timelineData.elementsCount = timelineElements.length, timelineData.timelineDatapoints = [];
                            for (var _i = 0, timelineElements_1 = timelineElements; _i < timelineElements_1.length; _i++) {
                                var currentTimePeriod = timelineElements_1[_i], datapoint = {
                                    index: currentTimePeriod.index,
                                    datePeriod: currentTimePeriod
                                };
                                timelineData.timelineDatapoints.push(datapoint);
                            }
                            var countFullCells = timelineData.currentGranularity.getDatePeriods().filter(function(x) {
                                return x.index % 1 === 0;
                            }).length;
                            return Timeline.setMeasures(timelineFormat.labelFormat, timelineData.currentGranularity.getType(), countFullCells, viewport, timelineProperties, timelineMargins), 
                            Timeline.updateCursors(timelineData, timelineProperties.cellWidth), timelineFormat;
                        }
                    }, Timeline.prototype.render = function(timelineData, timelineFormat, timelineProperties, options) {
                        var timelineDatapointsCount = this.timelineData.timelineDatapoints.filter(function(x) {
                            return x.index % 1 === 0;
                        }).length;
                        this.svgWidth = 1 + this.timelineProperties.cellHeight + timelineProperties.cellWidth * timelineDatapointsCount, 
                        this.renderTimeRangeText(timelineData, timelineFormat.rangeTextFormat), this.fillColorGranularity(this.timelineFormat.granularityFormat), 
                        this.timelineDiv.attr({
                            height: convertToPx(options.viewport.height),
                            width: convertToPx(options.viewport.width),
                            "drag-resize-disabled": !0
                        }).style({
                            "overflow-x": "auto",
                            "overflow-y": "auto"
                        }), this.svg.attr({
                            height: convertToPx(Math.max(Timeline.MinSizeOfViewport, options.viewport.height - this.timelineMargins.TopMargin)),
                            width: convertToPx(Math.max(Timeline.MinSizeOfViewport, this.svgWidth))
                        });
                        var fixedTranslateString = SVGUtil.translate(timelineProperties.leftMargin, timelineProperties.topMargin), translateString = SVGUtil.translate(timelineProperties.cellHeight / 2, timelineProperties.topMargin);
                        this.mainGroupElement.attr("transform", translateString), this.selectorContainer.attr("transform", fixedTranslateString), 
                        this.cursorGroupElement.attr("transform", translateString);
                        var extendedLabels = this.timelineData.currentGranularity.getExtendedLabel(), granularityType = this.timelineData.currentGranularity.getType(), yPos = 0, yDiff = 1.5;
                        this.renderLabels(extendedLabels.yearLabels, this.yearLabelsElement, yPos, 0 === granularityType), 
                        yPos += yDiff, this.renderLabels(extendedLabels.quarterLabels, this.quarterLabelsElement, yPos, 1 === granularityType), 
                        yPos += yDiff, this.renderLabels(extendedLabels.monthLabels, this.monthLabelsElement, yPos, 2 === granularityType), 
                        yPos += yDiff, this.renderLabels(extendedLabels.weekLabels, this.weekLabelsElement, yPos, 3 === granularityType), 
                        yPos += yDiff, this.renderLabels(extendedLabels.dayLabels, this.dayLabelsElement, yPos, 4 === granularityType), 
                        this.renderCells(timelineData, timelineFormat, timelineProperties, options.suppressAnimations), 
                        this.renderCursors(timelineData, timelineFormat, timelineProperties.cellHeight, timelineProperties.cellsYPosition);
                    }, Timeline.prototype.renderLabels = function(labels, labelsElement, index, isLast) {
                        var _this = this, labelTextSelection = labelsElement.selectAll(this.timelineSelectors.textLabel.selector);
                        if (!this.timelineFormat.labelFormat.showProperty) return void labelTextSelection.remove();
                        var labelsGroupSelection = labelTextSelection.data(labels);
                        labelsGroupSelection.enter().append("text").classed(this.timelineSelectors.textLabel.class, !0), 
                        labelsGroupSelection.text(function(x, id) {
                            if (!isLast && 0 === id && labels.length > 1) {
                                var fontSize = convertToPt(_this.timelineFormat.labelFormat.sizeProperty), textProperties = {
                                    text: labels[0].text,
                                    fontFamily: "arial",
                                    fontSize: fontSize
                                }, halfFirstTextWidth = TextMeasurementService.measureSvgTextWidth(textProperties) / 2;
                                textProperties = {
                                    text: labels[1].text,
                                    fontFamily: "arial",
                                    fontSize: fontSize
                                };
                                var halfSecondTextWidth = TextMeasurementService.measureSvgTextWidth(textProperties) / 2, diff = _this.timelineProperties.cellWidth * (labels[1].id - labels[0].id);
                                if (diff < halfFirstTextWidth + halfSecondTextWidth) return "";
                            }
                            var labelFormattedTextOptions = {
                                label: x.text,
                                maxWidth: _this.timelineProperties.cellWidth * (isLast ? .9 : 3),
                                fontSize: _this.timelineFormat.labelFormat.sizeProperty
                            };
                            return getLabelFormattedText(labelFormattedTextOptions);
                        }).style("font-size", convertToPt(this.timelineFormat.labelFormat.sizeProperty)).attr({
                            x: function(x) {
                                return (x.id + .5) * _this.timelineProperties.cellWidth;
                            },
                            y: this.timelineProperties.textYPosition + (1 + index) * fromPointToPixel(this.timelineFormat.labelFormat.sizeProperty),
                            fill: this.timelineFormat.labelFormat.colorProperty
                        }).append("title").text(function(x) {
                            return x.title;
                        }), labelsGroupSelection.exit().remove();
                    }, Timeline.prototype.clearData = function() {
                        this.initialized = !1, this.mainGroupElement.selectAll(this.timelineSelectors.CellRect.selector).remove(), 
                        this.mainGroupElement.selectAll(this.timelineSelectors.textLabel.selector).remove(), 
                        this.rangeText.text(""), this.cursorGroupElement.selectAll(this.timelineSelectors.SelectionCursor.selector).remove(), 
                        this.svg.attr("width", 0).selectAll(this.timelineSelectors.TimelineSlicer.selector).remove(), 
                        this.mainGroupElement.selectAll(this.timelineSelectors.textLabel.selector).remove();
                    }, Timeline.updateCursors = function(timelineData, cellWidth) {
                        var startDate = timelineData.timelineDatapoints[timelineData.selectionStartIndex].datePeriod, endDate = timelineData.timelineDatapoints[timelineData.selectionEndIndex].datePeriod;
                        timelineData.cursorDataPoints[0].selectionIndex = startDate.index, timelineData.cursorDataPoints[1].selectionIndex = endDate.index + endDate.fraction;
                    }, Timeline.fillTimelineFormat = function(objects, timelineProperties) {
                        var timelineFormat = {
                            rangeTextFormat: {
                                showProperty: DataViewObjects.getValue(objects, TimeRangeShowProp, timelineProperties.TimelineDefaultTimeRangeShow),
                                colorProperty: DataViewObjects.getFillColor(objects, TimeRangeColorProp, timelineProperties.DefaultTimeRangeColor),
                                sizeProperty: DataViewObjects.getValue(objects, TimeRangeSizeProp, timelineProperties.TimelineDefaultTextSize)
                            },
                            cellFormat: {
                                colorInProperty: DataViewObjects.getFillColor(objects, SelectedCellColorProp, timelineProperties.TimelineDefaultCellColor),
                                colorOutProperty: DataViewObjects.getFillColor(objects, UnselectedCellColorProp, timelineProperties.TimelineDefaultCellColorOut)
                            },
                            granularityFormat: {
                                scaleColorProperty: DataViewObjects.getFillColor(objects, ScaleColorProp, timelineProperties.DefaultScaleColor),
                                sliderColorProperty: DataViewObjects.getFillColor(objects, SliderColorProp, timelineProperties.DefaultSliderColor)
                            },
                            labelFormat: {
                                showProperty: DataViewObjects.getValue(objects, LabelsShowProp, timelineProperties.DefaultLabelsShow),
                                colorProperty: DataViewObjects.getFillColor(objects, LabelsColorProp, timelineProperties.DefaultLabelColor),
                                sizeProperty: DataViewObjects.getValue(objects, LabelsSizeProp, timelineProperties.TimelineDefaultTextSize)
                            },
                            calendarFormat: {
                                firstMonthProperty: DataViewObjects.getValue(objects, CalendarMonthProp, 1),
                                firstDayProperty: Math.max(1, Math.min(31, DataViewObjects.getValue(objects, CalendarDayProp, timelineProperties.DefaultFirstDay))),
                                weekDayProperty: Math.max(0, Math.min(6, DataViewObjects.getValue(objects, WeekDayProp, timelineProperties.DefaultFirstWeekDay)))
                            }
                        };
                        return timelineFormat;
                    }, Timeline.prototype.fillCells = function(cellFormat) {
                        var _this = this, dataPoints = this.timelineData.timelineDatapoints, cellSelection = this.mainGroupElement.selectAll(this.timelineSelectors.CellRect.selector).data(dataPoints);
                        cellSelection.attr("fill", function(d) {
                            return Utils.getCellColor(d, _this.timelineData, cellFormat);
                        });
                    }, Timeline.prototype.renderCells = function(timelineData, timelineFormat, timelineProperties, suppressAnimations) {
                        var _this = this, allDataPoints = timelineData.timelineDatapoints, totalX = 0, cellsSelection = this.cellsElement.selectAll(this.timelineSelectors.CellRect.selector).data(allDataPoints);
                        cellsSelection.enter().append("rect").classed(this.timelineSelectors.CellRect.class, !0), 
                        cellsSelection.attr({
                            height: convertToPx(timelineProperties.cellHeight),
                            width: function(d) {
                                return convertToPx(d.datePeriod.fraction * timelineProperties.cellWidth);
                            },
                            x: function(d) {
                                var value = totalX;
                                return totalX += d.datePeriod.fraction * timelineProperties.cellWidth, convertToPx(value);
                            },
                            y: convertToPx(timelineProperties.cellsYPosition),
                            id: function(d) {
                                return d.index;
                            }
                        });
                        var clickHandler = function(d, index) {
                            d3.event.preventDefault();
                            var cursorDataPoints = _this.timelineData.cursorDataPoints, keyEvent = d3.event;
                            keyEvent.altKey || keyEvent.shiftKey ? _this.timelineData.selectionEndIndex < index ? (cursorDataPoints[1].selectionIndex = d.datePeriod.index + d.datePeriod.fraction, 
                            timelineData.selectionEndIndex = index) : (cursorDataPoints[0].selectionIndex = d.datePeriod.index, 
                            timelineData.selectionStartIndex = index) : (timelineData.selectionStartIndex = index, 
                            timelineData.selectionEndIndex = index, cursorDataPoints[0].selectionIndex = d.datePeriod.index, 
                            cursorDataPoints[1].selectionIndex = d.datePeriod.index + d.datePeriod.fraction), 
                            _this.fillCells(timelineFormat.cellFormat), _this.renderCursors(timelineData, timelineFormat, timelineProperties.cellHeight, timelineProperties.cellsYPosition), 
                            _this.renderTimeRangeText(timelineData, timelineFormat.rangeTextFormat), _this.fillColorGranularity(_this.timelineFormat.granularityFormat), 
                            _this.setSelection(timelineData);
                        };
                        cellsSelection.on("click", clickHandler).on("touchstart", clickHandler), this.fillCells(timelineFormat.cellFormat), 
                        cellsSelection.exit().remove();
                    }, Timeline.prototype.dragged = function(currentCursor) {
                        var xScale = 1, container = d3.select(this.timelineSelectors.TimelineVisual.selector);
                        if (container) {
                            var transform = container.style("transform");
                            if (void 0 !== transform && "none" !== transform) {
                                var str = transform.split("(")[1];
                                xScale = Number(str.split(", ")[0]);
                            }
                        }
                        var cursorOverElement = this.findCursorOverElement(d3.event.x);
                        if (cursorOverElement) {
                            var currentlyMouseOverElement = cursorOverElement.datapoint, currentlyMouseOverElementIndex = cursorOverElement.index;
                            0 === currentCursor.cursorIndex && currentlyMouseOverElementIndex <= this.timelineData.selectionEndIndex && (this.timelineData.selectionStartIndex = currentlyMouseOverElementIndex, 
                            this.timelineData.cursorDataPoints[0].selectionIndex = currentlyMouseOverElement.datePeriod.index), 
                            1 === currentCursor.cursorIndex && currentlyMouseOverElementIndex >= this.timelineData.selectionStartIndex && (this.timelineData.selectionEndIndex = currentlyMouseOverElementIndex, 
                            this.timelineData.cursorDataPoints[1].selectionIndex = currentlyMouseOverElement.datePeriod.index + currentlyMouseOverElement.datePeriod.fraction), 
                            this.fillCells(this.timelineFormat.cellFormat), this.renderCursors(this.timelineData, this.timelineFormat, this.timelineProperties.cellHeight, this.timelineProperties.cellsYPosition), 
                            this.renderTimeRangeText(this.timelineData, this.timelineFormat.rangeTextFormat), 
                            this.fillColorGranularity(this.timelineFormat.granularityFormat);
                        }
                    }, Timeline.prototype.findCursorOverElement = function(position) {
                        var timelineDatapointIndexes, index, timelineDatapoints = this.timelineData.timelineDatapoints || [], cellWidth = this.timelineProperties.cellWidth;
                        return timelineDatapointIndexes = timelineDatapoints.map(function(datapoint) {
                            return datapoint.index;
                        }), index = Timeline.getIndexByPosition(timelineDatapointIndexes, cellWidth, position), 
                        timelineDatapoints[index] ? {
                            index: index,
                            datapoint: timelineDatapoints[index]
                        } : null;
                    }, Timeline.prototype.dragended = function() {
                        this.setSelection(this.timelineData);
                    }, Timeline.prototype.renderCursors = function(timelineData, timelineFormat, cellHeight, cellsYPosition) {
                        var _this = this, cursorSelection = this.cursorGroupElement.selectAll(this.timelineSelectors.SelectionCursor.selector).data(timelineData.cursorDataPoints);
                        return cursorSelection.enter().append("path").classed(this.timelineSelectors.SelectionCursor.class, !0), 
                        cursorSelection.attr("transform", function(cursorDataPoint) {
                            var dx, dy;
                            return dx = cursorDataPoint.selectionIndex * _this.timelineProperties.cellWidth, 
                            dy = cellHeight / 2 + cellsYPosition, SVGUtil.translate(dx, dy);
                        }).attr({
                            d: d3.svg.arc().innerRadius(0).outerRadius(cellHeight / 2).startAngle(function(cursorDataPoint) {
                                return cursorDataPoint.cursorIndex * Math.PI + Math.PI;
                            }).endAngle(function(cursorDataPoint) {
                                return cursorDataPoint.cursorIndex * Math.PI + 2 * Math.PI;
                            })
                        }).call(this.drag), cursorSelection.exit().remove(), cursorSelection;
                    }, Timeline.prototype.renderTimeRangeText = function(timelineData, timeRangeFormat) {
                        var leftMargin = (GranularityNames.length + 2) * this.timelineProperties.elementWidth, maxWidth = this.svgWidth - leftMargin - this.timelineProperties.leftMargin - timeRangeFormat.sizeProperty;
                        if (timeRangeFormat.showProperty && maxWidth > 0) {
                            var timeRangeText = Utils.timeRangeText(timelineData), labelFormattedTextOptions = {
                                label: timeRangeText,
                                maxWidth: maxWidth,
                                fontSize: timeRangeFormat.sizeProperty
                            }, actualText = getLabelFormattedText(labelFormattedTextOptions);
                            this.rangeText.classed(this.timelineSelectors.SelectionRangeContainer.class, !0).attr({
                                x: GranularityNames.length * (this.timelineProperties.elementWidth + this.timelineProperties.leftMargin),
                                y: 40,
                                fill: timeRangeFormat.colorProperty
                            }).style({
                                "font-size": convertToPt(timeRangeFormat.sizeProperty)
                            }).text(actualText).append("title").text(timeRangeText);
                        } else this.rangeText.text("");
                    }, Timeline.prototype.setSelection = function(timelineData) {
                        this.requiresNoUpdate = !0;
                        var lower = SQExprBuilder.dateTime(Utils.getStartSelectionDate(timelineData)), upper = SQExprBuilder.dateTime(new Date(Utils.getEndSelectionDate(timelineData).getTime() - 1)), filterExpr = SQExprBuilder.between(timelineData.columnIdentity, lower, upper), filter = SemanticFilter.fromSQExpr(filterExpr), objects = {
                            merge: [ {
                                objectName: "general",
                                selector: void 0,
                                properties: {
                                    filter: filter
                                }
                            } ]
                        };
                        this.hostServices.persistProperties(objects), this.hostServices.onSelect({
                            visualObjects: []
                        });
                    }, Timeline.prototype.enumerateObjectInstances = function(options) {
                        var enumeration = new ObjectEnumerationBuilder(), objects = this.dataView && this.dataView.metadata ? this.dataView.metadata.objects : void 0;
                        switch (options.objectName) {
                          case "rangeHeader":
                            this.enumerateRangeHeader(enumeration, objects);
                            break;

                          case "cells":
                            this.enumerateCells(enumeration, objects);
                            break;

                          case "granularity":
                            this.enumerateGranularity(enumeration, objects);
                            break;

                          case "labels":
                            this.enumerateLabels(enumeration, objects);
                            break;

                          case "calendar":
                            this.enumerateCalendar(enumeration, objects);
                            break;

                          case "weekDay":
                            this.enumerateWeekDay(enumeration, objects);
                        }
                        return enumeration.complete();
                    }, Timeline.prototype.enumerateRangeHeader = function(enumeration, objects) {
                        enumeration.pushInstance({
                            objectName: "rangeHeader",
                            displayName: "Selection Color",
                            selector: null,
                            properties: {
                                show: DataViewObjects.getValue(objects, TimeRangeShowProp, this.defaultTimelineProperties.TimelineDefaultTimeRangeShow),
                                fontColor: DataViewObjects.getFillColor(objects, TimeRangeColorProp, this.defaultTimelineProperties.DefaultTimeRangeColor),
                                textSize: DataViewObjects.getValue(objects, TimeRangeSizeProp, this.defaultTimelineProperties.TimelineDefaultTextSize)
                            }
                        });
                    }, Timeline.prototype.enumerateCells = function(enumeration, objects) {
                        enumeration.pushInstance({
                            objectName: "cells",
                            selector: null,
                            properties: {
                                fillSelected: DataViewObjects.getFillColor(objects, SelectedCellColorProp, this.defaultTimelineProperties.TimelineDefaultCellColor),
                                fillUnselected: DataViewObjects.getFillColor(objects, UnselectedCellColorProp, this.defaultTimelineProperties.TimelineDefaultCellColorOut)
                            }
                        });
                    }, Timeline.prototype.enumerateGranularity = function(enumeration, objects) {
                        enumeration.pushInstance({
                            objectName: "granularity",
                            selector: null,
                            properties: {
                                granularity: DataViewObjects.getValue(objects, GranularityProp, this.defaultTimelineProperties.DefaultGranularity),
                                scaleColor: DataViewObjects.getFillColor(objects, ScaleColorProp, this.defaultTimelineProperties.DefaultScaleColor),
                                sliderColor: DataViewObjects.getFillColor(objects, SliderColorProp, this.defaultTimelineProperties.DefaultSliderColor)
                            }
                        });
                    }, Timeline.prototype.enumerateLabels = function(enumeration, objects) {
                        enumeration.pushInstance({
                            objectName: "labels",
                            selector: null,
                            properties: {
                                show: DataViewObjects.getValue(objects, LabelsShowProp, this.defaultTimelineProperties.DefaultLabelsShow),
                                fontColor: DataViewObjects.getFillColor(objects, LabelsColorProp, this.defaultTimelineProperties.DefaultLabelColor),
                                textSize: DataViewObjects.getValue(objects, LabelsSizeProp, this.defaultTimelineProperties.TimelineDefaultTextSize)
                            }
                        });
                    }, Timeline.prototype.enumerateCalendar = function(enumeration, objects) {
                        enumeration.pushInstance({
                            objectName: "calendar",
                            selector: null,
                            properties: {
                                month: Math.max(1, Math.min(12, DataViewObjects.getValue(objects, CalendarMonthProp, 1))),
                                day: Math.max(1, Math.min(31, DataViewObjects.getValue(objects, CalendarDayProp, 1)))
                            }
                        });
                    }, Timeline.prototype.enumerateWeekDay = function(enumeration, objects) {
                        enumeration.pushInstance({
                            objectName: "weekDay",
                            selector: null,
                            properties: {
                                day: Math.max(0, Math.min(6, DataViewObjects.getValue(objects, WeekDayProp, 0)))
                            }
                        });
                    }, Timeline.MinSizeOfViewport = 0, Timeline.capabilities = {
                        dataRoles: [ {
                            name: "Time",
                            kind: VisualDataRoleKind.Grouping,
                            displayName: "Time"
                        } ],
                        dataViewMappings: [ {
                            conditions: [ {
                                Time: {
                                    max: 1
                                }
                            } ],
                            categorical: {
                                categories: {
                                    for: {
                                        in: "Time"
                                    },
                                    dataReductionAlgorithm: {
                                        sample: {}
                                    }
                                },
                                values: {
                                    select: [ {
                                        bind: {
                                            to: "Time"
                                        }
                                    } ]
                                }
                            }
                        } ],
                        objects: {
                            general: {
                                displayName: "General",
                                properties: {
                                    formatString: {
                                        type: {
                                            formatting: {
                                                formatString: !0
                                            }
                                        }
                                    },
                                    selected: {
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    filter: {
                                        type: {
                                            filter: {}
                                        },
                                        rule: {
                                            output: {
                                                property: "selected",
                                                selector: [ "Time" ]
                                            }
                                        }
                                    }
                                }
                            },
                            calendar: {
                                displayName: "Fiscal Year Start",
                                properties: {
                                    month: {
                                        displayName: "Month",
                                        type: {
                                            enumeration: samples.Months
                                        }
                                    },
                                    day: {
                                        displayName: "Day",
                                        type: {
                                            numeric: !0
                                        }
                                    }
                                }
                            },
                            weekDay: {
                                displayName: "First Day of Week",
                                properties: {
                                    day: {
                                        displayName: "Day",
                                        type: {
                                            enumeration: samples.WeekDays
                                        }
                                    }
                                }
                            },
                            rangeHeader: {
                                displayName: "Range Header",
                                properties: {
                                    show: {
                                        displayName: "Show",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    fontColor: {
                                        displayName: "Font color",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    textSize: {
                                        displayName: "Text Size",
                                        type: {
                                            numeric: !0
                                        }
                                    }
                                }
                            },
                            cells: {
                                displayName: "Cells",
                                properties: {
                                    fillSelected: {
                                        displayName: "Selected cell color",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    fillUnselected: {
                                        displayName: "Unselected cell color",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: {
                                                        nullable: !0
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            },
                            granularity: {
                                displayName: "Granularity",
                                properties: {
                                    scaleColor: {
                                        displayName: "Scale color",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    sliderColor: {
                                        displayName: "Slider color",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    granularity: {
                                        displayName: "Granularity",
                                        type: {
                                            enumeration: samples.Granularities
                                        }
                                    }
                                }
                            },
                            labels: {
                                displayName: "Labels",
                                properties: {
                                    show: {
                                        displayName: "Show",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    fontColor: {
                                        displayName: "Font color",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    textSize: {
                                        displayName: "Text Size",
                                        type: {
                                            numeric: !0
                                        }
                                    }
                                }
                            }
                        }
                    }, Timeline;
                }();
                samples.Timeline = Timeline;
            }(samples = visuals.samples || (visuals.samples = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, jsCommon = window.jsCommon, powerbi = window.powerbi;
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var samples;
            !function(samples) {
                var PixelConverter = jsCommon.PixelConverter, ValueFormatter = powerbi.visuals.valueFormatter, LegendData = powerbi.visuals.LegendData, VisualDataRoleKind = powerbi.VisualDataRoleKind, createDisplayNameGetter = powerbi.data.createDisplayNameGetter, legendPosition = powerbi.visuals.legendPosition, SelectionId = powerbi.visuals.SelectionId, LegendIcon = powerbi.visuals.LegendIcon, TooltipBuilder = powerbi.visuals.TooltipBuilder, TextMeasurementService = powerbi.TextMeasurementService, DataViewObjects = powerbi.DataViewObjects, appendClearCatcher = powerbi.visuals.appendClearCatcher, createInteractivityService = powerbi.visuals.createInteractivityService, createLegend = powerbi.visuals.createLegend, TooltipManager = powerbi.visuals.TooltipManager, dataLabelUtils = powerbi.visuals.dataLabelUtils, SVGUtil = powerbi.visuals.SVGUtil, AxisHelper = powerbi.visuals.AxisHelper, valueFormatter = powerbi.visuals.valueFormatter, legendProps = powerbi.visuals.legendProps, LegendPosition = powerbi.visuals.LegendPosition, Legend = powerbi.visuals.Legend, ObjectEnumerationBuilder = powerbi.visuals.ObjectEnumerationBuilder, StreamGraphAxisGraphicsContextClassName = "axisGraphicsContext", DataPointsContainer = "dataPointsContainer", StreamGraphXAxisClassName = "x axis", StreamGraphYAxisClassName = "y axis", StreamGraphDefaultColor = "#777", StreamGraphDefaultFontSizeInPoints = 8, DefaultDataLabelsOffset = 4, DefaultLabelTickWidth = 10, DefaultLegendLabelFillColor = "#666666", StreamGraphDefaultFontFamily = "wf_segoe-ui_normal", StreamGraphDefaultFontWeight = "normal", XAxisOnSize = 20, XAxisOffSize = 10, XAxisLabelSize = 20, YAxisOnSize = 45, YAxisOffSize = 10, YAxisLabelSize = 20, StreamGraphDefaultSettings = {
                    legendSettings: {
                        show: !0,
                        showTitle: !0,
                        labelColor: DefaultLegendLabelFillColor,
                        titleText: "",
                        fontSize: StreamGraphDefaultFontSizeInPoints
                    },
                    categoryAxisSettings: {
                        show: !0,
                        labelColor: StreamGraphDefaultColor,
                        showAxisTitle: !1
                    },
                    valueAxisSettings: {
                        show: !0,
                        labelColor: StreamGraphDefaultColor,
                        showAxisTitle: !1
                    },
                    dataLabelsSettings: dataLabelUtils.getDefaultPointLabelSettings()
                }, StreamGraphWebBehavior = function() {
                    function StreamGraphWebBehavior() {}
                    return StreamGraphWebBehavior.prototype.bindEvents = function(options, selectionHandler) {
                        this.selection = options.selection, this.clearCatcher = options.clearCatcher, this.interactivityService = options.interactivityService, 
                        this.selection.on("click", function(d, i) {
                            selectionHandler.handleSelection(d, d3.event.ctrlKey);
                        }), this.clearCatcher.on("click", function() {
                            selectionHandler.handleClearSelection();
                        });
                    }, StreamGraphWebBehavior.prototype.renderSelection = function(hasSelection) {
                        var hasHighlights = this.interactivityService.hasSelection();
                        this.selection.style("fill-opacity", function(d) {
                            return streamGraphUtils.getFillOpacity(d.selected, d.highlight, !d.highlight && hasSelection, !d.selected && hasHighlights);
                        });
                    }, StreamGraphWebBehavior;
                }(), StreamGraph = function() {
                    function StreamGraph() {
                        this.margin = {
                            left: YAxisOnSize,
                            right: 15,
                            bottom: XAxisOnSize,
                            top: 10
                        };
                    }
                    return StreamGraph.prototype.converter = function(dataView, colors, interactivityService) {
                        if (!(dataView && dataView.categorical && dataView.categorical.values && dataView.categorical.categories && colors)) return null;
                        for (var valueFormatter, categoryFormatter, catDv = dataView.categorical, categories = catDv.categories, values = catDv.values, series = [], legendData = {
                            dataPoints: [],
                            title: values.source ? values.source.displayName : "",
                            fontSize: StreamGraphDefaultFontSizeInPoints
                        }, value = 0, category = categories && categories.length > 0 ? categories[0] : null, formatString = StreamGraph.Properties.general.formatString, hasHighlights = !!(values.length > 0 && values[0].highlights), streamGraphSettings = this.parseSettings(dataView), fontSizeInPx = PixelConverter.fromPoint(streamGraphSettings.dataLabelsSettings.fontSize), i = 0; i < values.length; i++) {
                            var label = values[i].source.groupName, identity = values[i].identity ? SelectionId.createWithId(values[i].identity) : SelectionId.createWithMeasure(values[i].source.queryName);
                            label ? legendData.dataPoints.push({
                                label: label,
                                color: colors.getColorByIndex(i).value,
                                icon: LegendIcon.Box,
                                selected: !1,
                                identity: identity
                            }) : label = values[i].source.displayName;
                            var tooltipInfo = TooltipBuilder.createTooltipInfo(formatString, {
                                categories: null,
                                values: values
                            }, null, null, null, null, i);
                            series[i] = {
                                dataPoints: [],
                                tooltipInfo: tooltipInfo,
                                highlight: hasHighlights,
                                identity: identity,
                                selected: !1
                            };
                            var dataPointsValues = values[i].values;
                            if (0 !== dataPointsValues.length) for (var k = 0; k < dataPointsValues.length; k++) {
                                var y = hasHighlights ? values[i].highlights[k] : dataPointsValues[k];
                                y > value && (value = y), series[i].dataPoints.push({
                                    x: k,
                                    y: isNaN(y) ? 0 : y,
                                    text: label,
                                    labelFontSize: fontSizeInPx
                                });
                            }
                        }
                        interactivityService && interactivityService.applySelectionStateToData(series), 
                        valueFormatter = ValueFormatter.create({
                            format: "g",
                            value: value
                        }), categoryFormatter = ValueFormatter.create({
                            format: ValueFormatter.getFormatString(category.source, StreamGraph.Properties.general.formatString),
                            value: category.values
                        });
                        for (var categoriesText = [], getTextPropertiesFunction = this.getTextPropertiesFunction, index = 0; index < category.values.length; index++) {
                            var formattedValue = void 0;
                            if (null != category.values[index]) {
                                formattedValue = categoryFormatter.format(category.values[index]);
                                var textLength = TextMeasurementService.measureSvgTextWidth(getTextPropertiesFunction(formattedValue));
                                textLength > StreamGraph.MaxNumberOfAxisXValues && (StreamGraph.MaxNumberOfAxisXValues = textLength);
                            }
                            categoriesText.push(formattedValue);
                        }
                        return {
                            series: series,
                            legendData: legendData,
                            valueFormatter: valueFormatter,
                            categoryFormatter: categoryFormatter,
                            streamGraphSettings: streamGraphSettings,
                            categoriesText: categoriesText
                        };
                    }, StreamGraph.prototype.parseSettings = function(dataView) {
                        if (!dataView || !dataView.metadata) return StreamGraphDefaultSettings;
                        var objects = dataView.metadata.objects, streamGraphSettings = _.cloneDeep(StreamGraphDefaultSettings), categoryAxisSettings = streamGraphSettings.categoryAxisSettings;
                        categoryAxisSettings.show = DataViewObjects.getValue(objects, StreamGraph.Properties.categoryAxis.show, categoryAxisSettings.show), 
                        categoryAxisSettings.labelColor = DataViewObjects.getFillColor(objects, StreamGraph.Properties.categoryAxis.labelColor, categoryAxisSettings.labelColor), 
                        categoryAxisSettings.showAxisTitle = DataViewObjects.getValue(objects, StreamGraph.Properties.categoryAxis.showAxisTitle, categoryAxisSettings.showAxisTitle);
                        var valueAxisSettings = streamGraphSettings.valueAxisSettings;
                        valueAxisSettings.show = DataViewObjects.getValue(objects, StreamGraph.Properties.valueAxis.show, valueAxisSettings.show), 
                        valueAxisSettings.labelColor = DataViewObjects.getFillColor(objects, StreamGraph.Properties.valueAxis.labelColor, valueAxisSettings.labelColor), 
                        valueAxisSettings.showAxisTitle = DataViewObjects.getValue(objects, StreamGraph.Properties.valueAxis.showAxisTitle, valueAxisSettings.showAxisTitle);
                        var dataLabelsSettings = streamGraphSettings.dataLabelsSettings;
                        dataLabelsSettings.show = DataViewObjects.getValue(objects, StreamGraph.Properties.labels.show, dataLabelsSettings.show), 
                        dataLabelsSettings.labelColor = DataViewObjects.getFillColor(objects, StreamGraph.Properties.labels.color, dataLabelsSettings.labelColor), 
                        dataLabelsSettings.fontSize = DataViewObjects.getValue(objects, StreamGraph.Properties.labels.fontSize, dataLabelsSettings.fontSize);
                        var legendSettings = streamGraphSettings.legendSettings, valuesSource = dataView.categorical.values.source, titleTextDefault = valuesSource && _.isEmpty(legendSettings.titleText) ? valuesSource.displayName : legendSettings.titleText;
                        return legendSettings.show = DataViewObjects.getValue(objects, StreamGraph.Properties.legend.show, legendSettings.show), 
                        legendSettings.showTitle = DataViewObjects.getValue(objects, StreamGraph.Properties.legend.showTitle, legendSettings.showTitle), 
                        legendSettings.titleText = DataViewObjects.getValue(objects, StreamGraph.Properties.legend.titleText, titleTextDefault), 
                        legendSettings.labelColor = DataViewObjects.getValue(objects, StreamGraph.Properties.legend.labelColor, legendSettings.labelColor), 
                        legendSettings.fontSize = DataViewObjects.getValue(objects, StreamGraph.Properties.legend.fontSize, legendSettings.fontSize), 
                        _.isEmpty(legendSettings.titleText) && (legendSettings.titleText = titleTextDefault), 
                        streamGraphSettings;
                    }, StreamGraph.prototype.init = function(options) {
                        var element = options.element, svg = this.svg = d3.select(element.get(0)).append("svg").classed(StreamGraph.VisualClassName, !0).style("position", "absolute");
                        this.clearCatcher = appendClearCatcher(svg), this.axisGraphicsContext = svg.append("g").classed(StreamGraphAxisGraphicsContextClassName, !0), 
                        this.xAxis = this.axisGraphicsContext.append("g").classed(StreamGraphXAxisClassName, !0), 
                        this.yAxis = this.axisGraphicsContext.append("g").classed(StreamGraphYAxisClassName, !0), 
                        this.dataPointsContainer = svg.append("g").classed(DataPointsContainer, !0), this.viewport = options.viewport, 
                        this.colors = options.style.colorPalette.dataColors, this.behavior = new StreamGraphWebBehavior();
                        var interactivity = options.interactivity;
                        this.interactivityService = createInteractivityService(options.host), this.legend = createLegend(element, interactivity && interactivity.isInteractiveLegend, this.interactivityService, !0);
                    }, StreamGraph.prototype.update = function(options) {
                        if (!options.dataViews || !options.dataViews[0] || !options.dataViews[0].categorical) return void this.clearData();
                        this.viewport = {
                            width: Math.max(0, options.viewport.width),
                            height: Math.max(0, options.viewport.height)
                        };
                        var duration = options.suppressAnimations ? 0 : 250, dataView = this.dataView = options.dataViews[0], data = this.data = this.converter(dataView, this.colors, this.interactivityService);
                        if (!data || !data.series || !data.series.length) return void this.clearData();
                        this.renderLegend(data), this.renderXAxisLabels(), this.renderYAxisLabels(), this.svg.attr({
                            width: this.viewport.width + "px",
                            height: this.viewport.height + "px"
                        });
                        var selection = this.renderChart(data.series, duration);
                        TooltipManager.addTooltip(selection, function(tooltipEvent) {
                            return tooltipEvent.data.tooltipInfo;
                        });
                        var interactivityService = this.interactivityService;
                        if (interactivityService) {
                            var behaviorOptions = {
                                selection: selection,
                                clearCatcher: this.clearCatcher,
                                interactivityService: interactivityService
                            };
                            interactivityService.bind(data.series, this.behavior, behaviorOptions);
                        }
                    }, StreamGraph.prototype.getStreamGraphLabelLayout = function(xScale, yScale) {
                        var dataLabelsSettings = this.data.streamGraphSettings.dataLabelsSettings, fontSize = PixelConverter.fromPoint(dataLabelsSettings.fontSize);
                        return {
                            labelText: function(d) {
                                return d.text;
                            },
                            labelLayout: {
                                x: function(d) {
                                    return xScale(d.x);
                                },
                                y: function(d) {
                                    return yScale(d.y0);
                                }
                            },
                            filter: function(d) {
                                return null != d && null != d.text;
                            },
                            style: {
                                fill: dataLabelsSettings.labelColor,
                                "font-size": fontSize
                            }
                        };
                    }, StreamGraph.prototype.renderChart = function(series, duration) {
                        var _this = this, stack = d3.layout.stack().values(function(d) {
                            return d.dataPoints;
                        }), width = this.viewport.width, height = this.viewport.height;
                        this.getWiggle(this.dataView) && stack.offset("wiggle");
                        var layers = stack(series), margin = this.margin, xScale = d3.scale.linear().domain([ 0, series[0].dataPoints.length - 1 ]).range([ margin.left, width - margin.right ]), yMax = d3.max(layers, function(layer) {
                            return d3.max(layer.dataPoints, function(d) {
                                return d.y0 + d.y;
                            });
                        }), yMin = d3.min(layers, function(layer) {
                            return d3.min(layer.dataPoints, function(d) {
                                return d.y0 + d.y;
                            });
                        }), yScale = d3.scale.linear().domain([ Math.min(yMin, 0), yMax ]).range([ height - margin.bottom, margin.top ]).nice(), area = d3.svg.area().interpolate("monotone").x(function(d) {
                            return xScale(d.x);
                        }).y0(function(d) {
                            return yScale(d.y0);
                        }).y1(function(d) {
                            return yScale(d.y0 + d.y);
                        }).defined(function(d) {
                            return !isNaN(d.y0) && !isNaN(d.y);
                        }), selection = this.dataPointsContainer.selectAll(StreamGraph.Layer.selector).data(layers);
                        if (selection.enter().append("path").classed(StreamGraph.Layer.class, !0), selection.style("fill", function(d, i) {
                            return _this.colors.getColorByIndex(i).value;
                        }).style("fill-opacity", streamGraphUtils.DefaultOpacity).transition().duration(duration).attr("d", function(d) {
                            return area(d.dataPoints);
                        }), selection.selectAll("path").append("g").classed(DataPointsContainer, !0), selection.exit().remove(), 
                        this.data.streamGraphSettings.dataLabelsSettings.show) {
                            var labelsXScale = d3.scale.linear().domain([ 0, series[0].dataPoints.length - 1 ]).range([ 0, width - margin.left - margin.right ]), layout = this.getStreamGraphLabelLayout(labelsXScale, yScale), dataPointsArray_1 = [];
                            series.forEach(function(seriesItem) {
                                var filteredDataPoints;
                                filteredDataPoints = seriesItem.dataPoints.filter(function(dataPoint) {
                                    return dataPoint && null !== dataPoint.y && void 0 !== dataPoint.y;
                                }), filteredDataPoints.length > 0 && (dataPointsArray_1 = dataPointsArray_1.concat(filteredDataPoints));
                            });
                            var viewport = {
                                height: height - margin.top - margin.bottom,
                                width: width - margin.right - margin.left
                            }, labels = dataLabelUtils.drawDefaultLabelsForDataPointChart(dataPointsArray_1, this.svg, layout, viewport);
                            if (labels) {
                                var offset_1 = DefaultDataLabelsOffset + margin.left;
                                labels.attr("transform", function(d) {
                                    return SVGUtil.translate(offset_1 + d.size.width / 2, d.size.height / 2);
                                });
                            }
                        } else dataLabelUtils.cleanDataLabels(this.svg);
                        return this.drawAxis(this.data, xScale, yScale), selection;
                    }, StreamGraph.prototype.drawAxis = function(data, xScale, yScale) {
                        for (var margin = this.margin, shiftY = this.viewport.height - margin.bottom, shiftX = this.viewport.width - margin.left - margin.right, categoriesText = this.data.categoriesText, xAxis = d3.svg.axis(), maxNumberOfAxisXValues = StreamGraph.MaxNumberOfAxisXValues, getTextPropertiesFunction = this.getTextPropertiesFunction, index = 0; index < categoriesText.length; index++) if (null != categoriesText[index]) {
                            var str = categoriesText[index].toString(), textLength = TextMeasurementService.measureSvgTextWidth(getTextPropertiesFunction(str));
                            textLength > maxNumberOfAxisXValues && (maxNumberOfAxisXValues = textLength);
                        }
                        xAxis.scale(xScale).orient("bottom").ticks(categoriesText.length).tickFormat(function(index) {
                            var item = categoriesText[index];
                            return data.categoryFormatter && (item = data.categoryFormatter.format(item)), null === index || void 0 === index || 0 !== index && index !== categoriesText.length - 1 || (item = TextMeasurementService.getTailoredTextOrDefault(getTextPropertiesFunction(item), 2 * (index ? margin.right : margin.left))), 
                            item;
                        });
                        var yAxis = d3.svg.axis().scale(yScale).orient("left").tickFormat(function(item) {
                            var tempItem = item;
                            return data.valueFormatter && (tempItem = data.valueFormatter.format(tempItem)), 
                            tempItem = TextMeasurementService.getTailoredTextOrDefault(getTextPropertiesFunction(tempItem.toString()), YAxisOnSize - DefaultLabelTickWidth);
                        });
                        this.setMaxTicks(xAxis, shiftX, Math.max(2, Math.round(shiftX / maxNumberOfAxisXValues))), 
                        this.setMaxTicks(yAxis, shiftY);
                        var valueAxisSettings = this.data.streamGraphSettings.valueAxisSettings;
                        if (valueAxisSettings.show) {
                            var axisColor = valueAxisSettings.labelColor;
                            this.yAxis.attr("transform", SVGUtil.translate(margin.left, 0)).call(yAxis), this.yAxis.selectAll("text").style("fill", axisColor);
                        } else this.yAxis.selectAll("*").remove();
                        var categoryAxisSettings = this.data.streamGraphSettings.categoryAxisSettings;
                        if (categoryAxisSettings.show) {
                            var axisColor = categoryAxisSettings.labelColor;
                            this.xAxis.attr("transform", SVGUtil.translate(0, shiftY)).call(xAxis), this.xAxis.selectAll("text").style("fill", axisColor);
                        } else this.xAxis.selectAll("*").remove();
                    }, StreamGraph.prototype.renderYAxisLabels = function() {
                        this.axisGraphicsContext.selectAll(StreamGraph.YAxisLabel.selector).remove();
                        var valueAxisSettings = this.data.streamGraphSettings.valueAxisSettings;
                        if (this.margin.left = valueAxisSettings.show ? YAxisOnSize : YAxisOffSize, valueAxisSettings.showAxisTitle) {
                            this.margin.left += YAxisLabelSize;
                            var categoryAxisSettings = this.data.streamGraphSettings.categoryAxisSettings, isXAxisOn = categoryAxisSettings.show === !0, isXTitleOn = categoryAxisSettings.showAxisTitle === !0, marginTop_1 = this.margin.top, height_1 = this.viewport.height - marginTop_1 - (isXAxisOn ? XAxisOnSize : XAxisOffSize) - (isXTitleOn ? XAxisLabelSize : 0), values = this.dataView.categorical.values, yAxisText = values.source ? values.source.displayName : this.getYAxisTitleFromValues(values), textSettings = this.getTextPropertiesFunction(yAxisText);
                            yAxisText = TextMeasurementService.getTailoredTextOrDefault(textSettings, height_1);
                            var yAxisClass_1 = StreamGraph.YAxisLabel.class, yAxisLabel = this.axisGraphicsContext.append("text").style("text-anchor", "middle").style("font-family", textSettings.fontFamily).style("font-size", textSettings.fontSize).style("font-style", textSettings.fontStyle).style("font-weight", textSettings.fontWeight).text(yAxisText).call(function(text) {
                                text.each(function() {
                                    var text = d3.select(this);
                                    text.attr({
                                        class: yAxisClass_1,
                                        transform: "rotate(-90)",
                                        fill: valueAxisSettings.labelColor,
                                        x: -(marginTop_1 + height_1 / 2),
                                        dy: "1em"
                                    });
                                });
                            });
                            yAxisLabel.call(AxisHelper.LabelLayoutStrategy.clip, height_1, TextMeasurementService.svgEllipsis);
                        }
                    }, StreamGraph.prototype.getYAxisTitleFromValues = function(values) {
                        for (var valuesMetadataArray = [], i = 0; i < values.length; i++) values[i] && values[i].source && values[i].source.displayName && valuesMetadataArray.push({
                            displayName: values[i].source.displayName
                        });
                        var valuesNames = valuesMetadataArray.map(function(v) {
                            return v ? v.displayName : "";
                        }).filter(function(value, index, self) {
                            return "" !== value && self.indexOf(value) === index;
                        });
                        return valueFormatter.formatListAnd(valuesNames);
                    }, StreamGraph.prototype.renderXAxisLabels = function() {
                        this.axisGraphicsContext.selectAll(StreamGraph.XAxisLabel.selector).remove();
                        var categoryAxisSettings = this.data.streamGraphSettings.categoryAxisSettings;
                        if (this.margin.bottom = categoryAxisSettings.show ? XAxisOnSize : XAxisOffSize, 
                        categoryAxisSettings.showAxisTitle && this.dataView.categorical.categories[0].source) {
                            this.margin.bottom += XAxisLabelSize;
                            var valueAxisSettings = this.data.streamGraphSettings.valueAxisSettings, isYAxisOn = valueAxisSettings.show === !0, isYTitleOn = valueAxisSettings.showAxisTitle === !0, leftMargin_1 = (isYAxisOn ? YAxisOnSize : YAxisOffSize) + (isYTitleOn ? YAxisLabelSize : 0), width_1 = this.viewport.width - this.margin.right - leftMargin_1, height_2 = this.viewport.height, xAxisText = this.dataView.categorical.categories[0].source.displayName, textSettings = this.getTextPropertiesFunction(xAxisText);
                            xAxisText = TextMeasurementService.getTailoredTextOrDefault(textSettings, width_1);
                            var xAxisClass_1 = StreamGraph.XAxisLabel.class, xAxisLabel = this.axisGraphicsContext.append("text").style("text-anchor", "middle").style("font-family", textSettings.fontFamily).style("font-size", textSettings.fontSize).style("font-weight", textSettings.fontWeight).text(xAxisText).call(function(text) {
                                text.each(function() {
                                    var text = d3.select(this);
                                    text.attr({
                                        class: xAxisClass_1,
                                        transform: SVGUtil.translate(leftMargin_1 + width_1 / 2, height_2),
                                        fill: categoryAxisSettings.labelColor,
                                        dy: "-0.5em"
                                    });
                                });
                            });
                            xAxisLabel.call(AxisHelper.LabelLayoutStrategy.clip, width_1, TextMeasurementService.svgEllipsis);
                        }
                    }, StreamGraph.prototype.renderLegend = function(streamGraphData) {
                        var legendSettings = streamGraphData.streamGraphSettings.legendSettings, legendData = streamGraphData.legendData;
                        if (this.dataView && this.dataView.metadata) {
                            var legendObjectProperties = DataViewObjects.getObject(this.dataView.metadata.objects, "legend", {});
                            legendObjectProperties.titleText = legendSettings.titleText, LegendData.update(legendData, legendObjectProperties);
                            var position = legendObjectProperties[legendProps.position];
                            position && this.legend.changeOrientation(LegendPosition[position]), this.legend.drawLegend(legendData, _.clone(this.viewport)), 
                            Legend.positionChartArea(this.svg, this.legend), this.updateViewPort();
                        }
                    }, StreamGraph.prototype.updateViewPort = function() {
                        var legendMargins = this.legend.getMargins(), legendPosition = this.legend.getOrientation();
                        switch (legendPosition) {
                          case LegendPosition.Top:
                          case LegendPosition.TopCenter:
                          case LegendPosition.Bottom:
                          case LegendPosition.BottomCenter:
                            this.viewport.height = Math.max(0, this.viewport.height - legendMargins.height);
                            break;

                          case LegendPosition.Left:
                          case LegendPosition.LeftCenter:
                          case LegendPosition.Right:
                          case LegendPosition.RightCenter:
                            this.viewport.width = Math.max(0, this.viewport.width - legendMargins.width);
                        }
                    }, StreamGraph.prototype.setMaxTicks = function(axis, maxSize, maxValue) {
                        var maxTicks = void 0 === maxValue ? this.getTicksByAxis(axis).length : Math.min(maxValue, this.getTicksByAxis(axis).length);
                        axis.scale().domain.toString() === d3.scale.linear().domain.toString() ? axis.ticks(this.getFittedTickLength(axis, maxSize, maxTicks)) : axis.tickValues(this.getFittedTickValues(axis, maxSize, maxTicks));
                    }, StreamGraph.prototype.getFittedTickLength = function(axis, maxSize, maxTicks) {
                        for (var ticks = this.getTicksByAxis(axis), measureTickFunction = this.getMeasureTickFunction(axis, ticks); maxTicks > 0 && maxSize > 0 && (this.measureTicks(ticks, measureTickFunction) > maxSize || axis.scale().ticks([ maxTicks ]).length > maxTicks); maxTicks--, 
                        ticks = this.getTicksByAxis(axis)) axis.ticks(maxTicks);
                        return maxTicks;
                    }, StreamGraph.prototype.getFittedTickValues = function(axis, maxSize, maxTicks) {
                        for (var maxWidthOf2Ticks, ticks = this.getTicksByAxis(axis), tickPairsWidths = [], measureTickFunction = this.getMeasureTickFunction(axis, ticks), currentMaxTicks = maxTicks, indexes = []; maxTicks > 0 && maxSize > 0; currentMaxTicks--, 
                        indexes = []) {
                            switch (currentMaxTicks) {
                              case 0:
                                return [];

                              case 1:
                                indexes = [ 0 ];
                                break;

                              case 2:
                                indexes = [ 0, ticks.length - 1 ];
                                break;

                              default:
                                for (var takeEvery = ticks.length / (currentMaxTicks - 1), i = 0; i < currentMaxTicks - 1; i++) indexes.push(Math.round(takeEvery * i));
                                indexes.push(ticks.length - 1);
                            }
                            var ticksIndexes = indexes.map(function(x) {
                                return [ ticks[x], x ];
                            });
                            if (maxWidthOf2Ticks = maxSize / ticks.length * 2, ticksIndexes.reduce(function(a, b) {
                                return tickPairsWidths.push([ measureTickFunction(a[0]) + measureTickFunction(b[0]), (b[1] - a[1]) * maxWidthOf2Ticks ]), 
                                b;
                            }), !tickPairsWidths.some(function(x) {
                                return x[0] > x[1];
                            })) return ticksIndexes.map(function(x) {
                                return x[0];
                            });
                        }
                        return [];
                    }, StreamGraph.prototype.measureTicks = function(ticks, measureTickFunction) {
                        return ticks.map(function(x) {
                            return measureTickFunction(x);
                        }).reduce(function(a, b) {
                            return a + b;
                        });
                    }, StreamGraph.prototype.getTicksByAxis = function(axis) {
                        var scale = axis.scale(), result = null === axis.tickValues() ? scale.ticks ? scale.ticks.apply(scale, axis.ticks()) : scale.domain() : axis.tickValues();
                        return void 0 === result.length ? [ result ] : result;
                    }, StreamGraph.prototype.getMeasureTickFunction = function(axis, ticks) {
                        var measureFunction = "top" === axis.orient() || "bottom" === axis.orient() ? TextMeasurementService.measureSvgTextWidth : TextMeasurementService.measureSvgTextHeight, getTextPropertiesFunction = this.getTextPropertiesFunction, cache = {};
                        return function(x) {
                            return cache[x] ? cache[x] : cache[x] = measureFunction(getTextPropertiesFunction(axis.tickFormat()(x))) + axis.tickPadding();
                        };
                    }, StreamGraph.prototype.getTextPropertiesFunction = function(text) {
                        var fontFamily = StreamGraphDefaultFontFamily, fontSize = PixelConverter.fromPoint(StreamGraphDefaultFontSizeInPoints), fontWeight = StreamGraphDefaultFontWeight;
                        return {
                            text: text,
                            fontFamily: fontFamily,
                            fontSize: fontSize,
                            fontWeight: fontWeight
                        };
                    }, StreamGraph.prototype.getWiggle = function(dataView) {
                        if (dataView && dataView.metadata) {
                            var objects = dataView.metadata.objects;
                            if (objects) {
                                var general = DataViewObjects.getObject(objects, "general", void 0);
                                if (general) return general.wiggle;
                            }
                        }
                        return !0;
                    }, StreamGraph.prototype.enumerateValueAxisValues = function(enumeration) {
                        var valueAxisSettings = this.data && this.data.streamGraphSettings ? this.data.streamGraphSettings.valueAxisSettings : StreamGraphDefaultSettings.valueAxisSettings;
                        enumeration.pushInstance({
                            selector: null,
                            objectName: "valueAxis",
                            displayName: "Y-Axis",
                            properties: {
                                show: valueAxisSettings.show,
                                showAxisTitle: valueAxisSettings.showAxisTitle,
                                labelColor: valueAxisSettings.labelColor
                            }
                        });
                    }, StreamGraph.prototype.enumerateCategoryAxisValues = function(enumeration) {
                        var categoryAxisSettings = this.data && this.data.streamGraphSettings ? this.data.streamGraphSettings.categoryAxisSettings : StreamGraphDefaultSettings.categoryAxisSettings;
                        enumeration.pushInstance({
                            selector: null,
                            objectName: "categoryAxis",
                            displayName: "X-Axis",
                            properties: {
                                show: categoryAxisSettings.show,
                                showAxisTitle: categoryAxisSettings.showAxisTitle,
                                labelColor: categoryAxisSettings.labelColor
                            }
                        });
                    }, StreamGraph.prototype.enumerateLegend = function(enumeration) {
                        var legendSettings = this.data && this.data.streamGraphSettings ? this.data.streamGraphSettings.legendSettings : StreamGraphDefaultSettings.legendSettings;
                        enumeration.pushInstance({
                            selector: null,
                            objectName: "legend",
                            displayName: "Legend",
                            properties: {
                                show: legendSettings.show,
                                position: LegendPosition[this.legend.getOrientation()],
                                showTitle: legendSettings.showTitle,
                                titleText: legendSettings.titleText,
                                labelColor: legendSettings.labelColor,
                                fontSize: legendSettings.fontSize
                            }
                        });
                    }, StreamGraph.prototype.clearData = function() {
                        this.svg.selectAll(StreamGraph.Layer.selector).remove(), this.legend.drawLegend({
                            dataPoints: []
                        }, this.viewport), this.yAxis.selectAll("*").remove(), this.axisGraphicsContext.selectAll(StreamGraph.YAxisLabel.selector).remove(), 
                        this.xAxis.selectAll("*").remove(), this.axisGraphicsContext.selectAll(StreamGraph.XAxisLabel.selector).remove(), 
                        this.svg.select(".labels").remove();
                    }, StreamGraph.prototype.onClearSelection = function() {
                        this.interactivityService && this.interactivityService.clearSelection();
                    }, StreamGraph.prototype.enumerateObjectInstances = function(options) {
                        var dataLabelsSettings, enumeration = new ObjectEnumerationBuilder(), dataView = this.dataView;
                        switch (this.data && (dataLabelsSettings = this.data.streamGraphSettings.dataLabelsSettings ? this.data.streamGraphSettings.dataLabelsSettings : StreamGraphDefaultSettings.dataLabelsSettings), 
                        options.objectName) {
                          case "legend":
                            dataView && dataView.categorical && dataView.categorical.values && dataView.categorical.values.source && this.enumerateLegend(enumeration);
                            break;

                          case "categoryAxis":
                            this.enumerateCategoryAxisValues(enumeration);
                            break;

                          case "valueAxis":
                            this.enumerateValueAxisValues(enumeration);
                            break;

                          case "labels":
                            var labelSettingOptions = {
                                enumeration: enumeration,
                                dataLabelsSettings: dataLabelsSettings,
                                show: !0,
                                fontSize: !0
                            };
                            dataLabelUtils.enumerateDataLabels(labelSettingOptions);
                            break;

                          case "general":
                            var general = {
                                objectName: "general",
                                displayName: "General",
                                selector: null,
                                properties: {
                                    wiggle: this.getWiggle(dataView)
                                }
                            };
                            enumeration.pushInstance(general);
                        }
                        return enumeration.complete();
                    }, StreamGraph.VisualClassName = "streamGraph", StreamGraph.Properties = {
                        general: {
                            formatString: {
                                objectName: "general",
                                propertyName: "formatString"
                            }
                        },
                        legend: {
                            show: {
                                objectName: "legend",
                                propertyName: "show"
                            },
                            showTitle: {
                                objectName: "legend",
                                propertyName: "showTitle"
                            },
                            titleText: {
                                objectName: "legend",
                                propertyName: "titleText"
                            },
                            labelColor: {
                                objectName: "legend",
                                propertyName: "labelColor"
                            },
                            fontSize: {
                                objectName: "legend",
                                propertyName: "fontSize"
                            }
                        },
                        categoryAxis: {
                            show: {
                                objectName: "categoryAxis",
                                propertyName: "show"
                            },
                            labelColor: {
                                objectName: "categoryAxis",
                                propertyName: "labelColor"
                            },
                            showAxisTitle: {
                                objectName: "categoryAxis",
                                propertyName: "showAxisTitle"
                            }
                        },
                        valueAxis: {
                            show: {
                                objectName: "valueAxis",
                                propertyName: "show"
                            },
                            labelColor: {
                                objectName: "valueAxis",
                                propertyName: "labelColor"
                            },
                            showAxisTitle: {
                                objectName: "valueAxis",
                                propertyName: "showAxisTitle"
                            }
                        },
                        labels: {
                            show: {
                                objectName: "labels",
                                propertyName: "show"
                            },
                            color: {
                                objectName: "labels",
                                propertyName: "color"
                            },
                            fontSize: {
                                objectName: "labels",
                                propertyName: "fontSize"
                            }
                        }
                    }, StreamGraph.Layer = {
                        class: "layer",
                        selector: ".layer"
                    }, StreamGraph.XAxisLabel = {
                        class: "xAxisLabel",
                        selector: ".xAxisLabel"
                    }, StreamGraph.YAxisLabel = {
                        class: "yAxisLabel",
                        selector: ".yAxisLabel"
                    }, StreamGraph.MaxNumberOfAxisXValues = 5, StreamGraph.capabilities = {
                        dataRoles: [ {
                            name: "Category",
                            kind: VisualDataRoleKind.Grouping,
                            displayName: "Category"
                        }, {
                            name: "Series",
                            kind: VisualDataRoleKind.Grouping,
                            displayName: "Series"
                        }, {
                            name: "Y",
                            kind: VisualDataRoleKind.Measure,
                            displayName: createDisplayNameGetter("Role_DisplayName_Values")
                        } ],
                        dataViewMappings: [ {
                            conditions: [ {
                                Category: {
                                    max: 1
                                },
                                Series: {
                                    max: 0
                                }
                            }, {
                                Category: {
                                    max: 1
                                },
                                Series: {
                                    min: 1,
                                    max: 1
                                },
                                Y: {
                                    max: 1
                                }
                            } ],
                            categorical: {
                                categories: {
                                    for: {
                                        in: "Category"
                                    },
                                    dataReductionAlgorithm: {
                                        bottom: {}
                                    }
                                },
                                values: {
                                    group: {
                                        by: "Series",
                                        select: [ {
                                            for: {
                                                in: "Y"
                                            }
                                        } ],
                                        dataReductionAlgorithm: {
                                            bottom: {}
                                        }
                                    }
                                }
                            }
                        } ],
                        objects: {
                            general: {
                                displayName: "General",
                                properties: {
                                    formatString: {
                                        type: {
                                            formatting: {
                                                formatString: !0
                                            }
                                        }
                                    },
                                    wiggle: {
                                        type: {
                                            bool: !0
                                        },
                                        displayName: "Wiggle"
                                    }
                                }
                            },
                            categoryAxis: {
                                displayName: "X-Axis",
                                properties: {
                                    show: {
                                        displayName: "show",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    showAxisTitle: {
                                        displayName: "Title",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    labelColor: {
                                        displayName: "Color",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    }
                                }
                            },
                            valueAxis: {
                                displayName: "Y-Axis",
                                properties: {
                                    show: {
                                        displayName: "show",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    showAxisTitle: {
                                        displayName: "Title",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    labelColor: {
                                        displayName: "Color",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    }
                                }
                            },
                            legend: {
                                displayName: "Legend",
                                properties: {
                                    show: {
                                        displayName: "show",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    position: {
                                        displayName: "Position",
                                        type: {
                                            enumeration: legendPosition.type
                                        }
                                    },
                                    showTitle: {
                                        displayName: "Title",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    titleText: {
                                        displayName: "Legend Name",
                                        type: {
                                            text: !0
                                        },
                                        suppressFormatPainterCopy: !0
                                    },
                                    labelColor: {
                                        displayName: "Color",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    fontSize: {
                                        displayName: "Text Size",
                                        type: {
                                            formatting: {
                                                fontSize: !0
                                            }
                                        }
                                    }
                                }
                            },
                            labels: {
                                displayName: "Data Labels",
                                properties: {
                                    show: {
                                        displayName: "Show",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    color: {
                                        displayName: "Color",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    fontSize: {
                                        displayName: "Text Size",
                                        type: {
                                            formatting: {
                                                fontSize: !0
                                            }
                                        }
                                    }
                                }
                            }
                        },
                        supportsHighlight: !0
                    }, StreamGraph;
                }();
                samples.StreamGraph = StreamGraph;
                var streamGraphUtils;
                !function(streamGraphUtils) {
                    function getFillOpacity(selected, highlight, hasSelection, hasPartialHighlights) {
                        return hasPartialHighlights && !highlight || hasSelection && !selected ? streamGraphUtils.DimmedOpacity : streamGraphUtils.DefaultOpacity;
                    }
                    streamGraphUtils.DimmedOpacity = .4, streamGraphUtils.DefaultOpacity = 1, streamGraphUtils.getFillOpacity = getFillOpacity;
                }(streamGraphUtils = samples.streamGraphUtils || (samples.streamGraphUtils = {}));
            }(samples = visuals.samples || (visuals.samples = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, jsCommon = window.jsCommon, powerbi = window.powerbi;
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var samples;
            !function(samples) {
                function createEnumTypeFromEnum(type) {
                    var even = !1;
                    return powerbi.createEnumType(Object.keys(type).filter(function(key, i) {
                        return !!(i % 2) === even && type[key] === key && !void (even === !even) || !!(i % 2) !== even;
                    }).map(function(x) {
                        return {
                            value: x,
                            displayName: x
                        };
                    }));
                }
                var SelectionManager = visuals.utility.SelectionManager, ValueFormatter = powerbi.visuals.valueFormatter, createClassAndSelector = jsCommon.CssConstants.createClassAndSelector, TextMeasurementService = powerbi.TextMeasurementService, defaultLabelPrecision = visuals.dataLabelUtils.defaultLabelPrecision, defaultLabelColor = visuals.dataLabelUtils.defaultLabelColor, DefaultFontSizeInPt = visuals.dataLabelUtils.DefaultFontSizeInPt, defaultLabelDensity = visuals.dataLabelUtils.defaultLabelDensity;
                samples.createEnumTypeFromEnum = createEnumTypeFromEnum, function(PulseChartXAxisDateFormat) {
                    PulseChartXAxisDateFormat[PulseChartXAxisDateFormat.DateOnly = "Date only"] = "DateOnly", 
                    PulseChartXAxisDateFormat[PulseChartXAxisDateFormat.TimeOnly = "Time only"] = "TimeOnly";
                }(samples.PulseChartXAxisDateFormat || (samples.PulseChartXAxisDateFormat = {}));
                var PulseChartXAxisDateFormat = samples.PulseChartXAxisDateFormat;
                !function(XAxisPosition) {
                    XAxisPosition[XAxisPosition.Center = "Center"] = "Center", XAxisPosition[XAxisPosition.Bottom = "Bottom"] = "Bottom";
                }(samples.XAxisPosition || (samples.XAxisPosition = {}));
                var XAxisPosition = samples.XAxisPosition;
                !function(RunnerCounterPosition) {
                    RunnerCounterPosition[RunnerCounterPosition.TopLeft = "Top Left"] = "TopLeft", RunnerCounterPosition[RunnerCounterPosition.TopRight = "Top Right"] = "TopRight";
                }(samples.RunnerCounterPosition || (samples.RunnerCounterPosition = {}));
                var RunnerCounterPosition = samples.RunnerCounterPosition, PulseChart = function() {
                    function PulseChart(options) {
                        options && options.svg && (this.svg = options.svg), this.margin = PulseChart.DefaultMargin;
                    }
                    return PulseChart.getProperties = function(capabilities) {
                        var result = {};
                        for (var objectKey in capabilities.objects) {
                            result[objectKey] = {};
                            for (var propKey in capabilities.objects[objectKey].properties) result[objectKey][propKey] = {
                                objectName: objectKey,
                                propertyName: propKey
                            };
                        }
                        return result;
                    }, PulseChart.GetPopupValueTextProperties = function(text, fontSizeValue) {
                        return void 0 === fontSizeValue && (fontSizeValue = 12), {
                            text: text || "",
                            fontFamily: "sans-serif",
                            fontSize: fontSizeValue + "px"
                        };
                    }, PulseChart.GetPopupTitleTextProperties = function(text, fontSizeValue) {
                        return void 0 === fontSizeValue && (fontSizeValue = 12), {
                            text: text || "",
                            fontFamily: "sans-serif",
                            fontWeight: "bold",
                            fontSize: fontSizeValue + "px"
                        };
                    }, PulseChart.GetPopupDescriptionTextProperties = function(text, fontSizeValue) {
                        return void 0 === fontSizeValue && (fontSizeValue = 12), {
                            text: text || "",
                            fontFamily: "sans-serif",
                            fontSize: fontSizeValue + "px"
                        };
                    }, PulseChart.GetRunnerCounterTextProperties = function(text, fontSizeValue) {
                        return void 0 === fontSizeValue && (fontSizeValue = 12), {
                            text: text || "",
                            fontFamily: "sans-serif",
                            fontSize: fontSizeValue + "px"
                        };
                    }, PulseChart.ConvertTextPropertiesToStyle = function(textProperties) {
                        return {
                            "font-family": textProperties.fontFamily,
                            "font-weight": textProperties.fontWeight,
                            "font-size": textProperties.fontSize
                        };
                    }, PulseChart.GetDateTimeFormatString = function(dateFormatType, dateFormat) {
                        switch (dateFormatType) {
                          case PulseChartXAxisDateFormat.DateOnly:
                            return dateFormat;

                          case PulseChartXAxisDateFormat.TimeOnly:
                            return "H:mm";

                          default:
                            return "";
                        }
                    }, PulseChart.GetFullWidthOfDateFormat = function(dateFormat, textProperties) {
                        return textProperties.text = visuals.valueFormatter.create({
                            format: dateFormat
                        }).format(new Date(2e3, 10, 20, 20, 20, 20)), TextMeasurementService.measureSvgTextWidth(textProperties);
                    }, PulseChart.AddOnTouchClick = function(selection, callback) {
                        var preventDefaultCallback = function(data, index) {
                            d3.event.preventDefault(), callback(data, index);
                        };
                        return selection.on("click", preventDefaultCallback).on("touchstart", preventDefaultCallback);
                    }, PulseChart.getCategoricalColumnOfRole = function(dataView, roleName) {
                        var filterFunc = function(cols) {
                            return cols.filter(function(x) {
                                return x.source && x.source.roles && x.source.roles[roleName];
                            })[0];
                        };
                        return filterFunc(dataView.categorical.categories) || filterFunc(dataView.categorical.values);
                    }, PulseChart.converter = function(dataView, colors, interactivityService) {
                        if (!(dataView && dataView.categorical && dataView.categorical.values && dataView.categorical.values[0] && dataView.categorical.values[0].values && dataView.categorical.categories)) return null;
                        var columns = _.mapValues(PulseChart.RoleNames, function(x, i) {
                            return PulseChart.getCategoricalColumnOfRole(dataView, i);
                        }), timeStampColumn = columns.Timestamp;
                        if (!timeStampColumn) return null;
                        var isScalar = !(timeStampColumn.source && timeStampColumn.source.type && timeStampColumn.source.type.dateTime), settings = PulseChart.parseSettings(dataView, colors, columns), categoryValues = timeStampColumn.values;
                        if (!categoryValues || _.isEmpty(dataView.categorical.values) || !columns.Value || _.isEmpty(columns.Value.values)) return null;
                        var minValuesValue = Math.min.apply(null, columns.Value.values), maxValuesValue = Math.max.apply(null, columns.Value.values), minCategoryValue = Math.min.apply(null, categoryValues), maxCategoryValue = Math.max.apply(null, categoryValues);
                        settings.xAxis.dateFormat = maxCategoryValue - minCategoryValue < 864e5 && new Date(maxCategoryValue).getDate() === new Date(minCategoryValue).getDate() ? PulseChartXAxisDateFormat.TimeOnly : PulseChartXAxisDateFormat.DateOnly, 
                        settings.xAxis.formatterOptions = {
                            value: isScalar ? minCategoryValue : new Date(minCategoryValue),
                            value2: isScalar ? maxCategoryValue : new Date(maxCategoryValue)
                        }, settings.yAxis.formatterOptions = {
                            value: minValuesValue,
                            value2: maxValuesValue,
                            format: ValueFormatter.getFormatString(columns.Value.source, PulseChart.DefaultSettings.formatStringProperty)
                        }, isScalar ? settings.xAxis.formatterOptions.format = ValueFormatter.getFormatString(timeStampColumn.source, PulseChart.DefaultSettings.formatStringProperty) : settings.xAxis.formatterOptions.format = PulseChart.GetDateTimeFormatString(settings.xAxis.dateFormat, timeStampColumn.source.format);
                        var widthOfXAxisLabel = 70, widthOfTooltipValueLabel = isScalar ? 60 : PulseChart.GetFullWidthOfDateFormat(timeStampColumn.source.format, PulseChart.GetPopupValueTextProperties()) + 5, heightOfTooltipDescriptionTextLine = TextMeasurementService.measureSvgTextHeight(PulseChart.GetPopupDescriptionTextProperties("lj", settings.popup.fontSize)), runnerCounterFormatString = columns.RunnerCounter && visuals.valueFormatter.getFormatString(columns.RunnerCounter.source, settings.formatStringProperty);
                        settings.popup.width = Math.max(widthOfTooltipValueLabel + 20, settings.popup.width);
                        var minSize = PulseChart.DefaultSettings.dots.minSize, maxSize = PulseChart.DefaultSettings.dots.maxSize;
                        settings.dots && (minSize = settings.dots.minSize, maxSize = settings.dots.maxSize);
                        for (var eventSizeScale = PulseChart.createScale(!0, columns.EventSize ? [ d3.min(columns.EventSize.values), d3.max(columns.EventSize.values) ] : [ 0, 0 ], minSize, maxSize), xAxisCardProperties = PulseChartAxisPropertiesHelper.getCategoryAxisProperties(dataView.metadata), hasDynamicSeries = !(!timeStampColumn.values || !timeStampColumn.source), dataPointLabelSettings = PulseChartDataLabelUtils.getDefaultPulseChartLabelSettings(), gapWidths = PulseChart.getGapWidths(categoryValues), maxGapWidth = Math.max.apply(null, gapWidths), firstValueMeasureIndex = 0, firstGroupIndex = 0, secondGroupIndex = 1, grouped = dataView.categorical.values && dataView.categorical.values.grouped(), y_group0Values = grouped[firstGroupIndex] && grouped[firstGroupIndex].values[firstValueMeasureIndex] && grouped[firstGroupIndex].values[firstValueMeasureIndex].values, y_group1Values = grouped[secondGroupIndex] && grouped[secondGroupIndex].values[firstValueMeasureIndex] && grouped[secondGroupIndex].values[firstValueMeasureIndex].values, series = [], dataPoints = [], categoryIndex = 0, seriesCategoryIndex = 0, len = timeStampColumn.values.length; categoryIndex < len; categoryIndex++, 
                        seriesCategoryIndex++) {
                            var categoryValue = categoryValues[categoryIndex], value = visuals.AxisHelper.normalizeNonFiniteNumber(timeStampColumn.values[categoryIndex]), runnerCounterValue = columns.RunnerCounter && columns.RunnerCounter.values && columns.RunnerCounter.values[categoryIndex], identity = visuals.SelectionIdBuilder.builder().withCategory(timeStampColumn, categoryIndex).createSelectionId(), minGapWidth = Math.max((maxCategoryValue - minCategoryValue) / PulseChart.MaxGapCount, PulseChart.MinGapWidth[settings.xAxis.dateFormat]), gapWidth = gapWidths[categoryIndex], isGap = settings.gaps.show && gapWidth > 0 && gapWidth > minGapWidth + (100 - settings.gaps.visibleGapsPercentage) * (maxGapWidth - minGapWidth) / 100;
                            if (isGap && dataPoints.length > 0 && (series.push({
                                displayName: grouped[firstGroupIndex].name,
                                key: identity.getKey(),
                                lineIndex: series.length,
                                color: settings.series.fill,
                                xCol: timeStampColumn.source,
                                yCol: timeStampColumn.source,
                                data: dataPoints,
                                identity: identity,
                                selected: !1,
                                labelSettings: dataPointLabelSettings,
                                width: settings.series.width,
                                widthOfGap: gapWidth
                            }), seriesCategoryIndex = 0, dataPoints = []), !isScalar || null !== categoryValue && null !== value) {
                                var popupInfo = null, eventSize = columns.EventSize && columns.EventSize.values && columns.EventSize.values[categoryIndex] || 0;
                                if (columns.EventTitle && columns.EventTitle.values && columns.EventTitle.values[categoryIndex] || columns.EventDescription && columns.EventDescription.values && columns.EventDescription.values[categoryIndex]) {
                                    var formattedValue = categoryValue;
                                    !isScalar && categoryValue && (formattedValue = visuals.valueFormatter.create({
                                        format: timeStampColumn.source.format
                                    }).format(categoryValue)), popupInfo = {
                                        value: formattedValue,
                                        title: columns.EventTitle && columns.EventTitle.values && columns.EventTitle.values[categoryIndex],
                                        description: columns.EventDescription && columns.EventDescription.values && columns.EventDescription.values[categoryIndex]
                                    };
                                }
                                var dataPoint = {
                                    categoryValue: categoryValue,
                                    value: value,
                                    categoryIndex: categoryIndex,
                                    seriesIndex: series.length,
                                    tooltipInfo: null,
                                    popupInfo: popupInfo,
                                    selected: !1,
                                    identity: identity,
                                    key: JSON.stringify({
                                        ser: identity.getKey(),
                                        catIdx: categoryIndex
                                    }),
                                    labelFill: dataPointLabelSettings.labelColor,
                                    labelSettings: dataPointLabelSettings,
                                    x: categoryValue,
                                    y: y_group0Values && y_group0Values[categoryIndex] || y_group1Values && y_group1Values[categoryIndex] || 0,
                                    pointColor: settings.series.fill,
                                    groupIndex: PulseChart.getGroupIndex(categoryIndex, grouped),
                                    eventSize: columns.EventSize ? eventSizeScale(eventSize) : 0,
                                    runnerCounterValue: runnerCounterValue,
                                    runnerCounterFormatString: runnerCounterFormatString,
                                    specificIdentity: void 0
                                };
                                dataPoints.push(dataPoint);
                            }
                        }
                        interactivityService && interactivityService.applySelectionStateToData(dataPoints), 
                        dataPoints.length > 0 && series.push({
                            displayName: grouped[firstGroupIndex].name,
                            key: identity.getKey(),
                            lineIndex: series.length,
                            color: settings.series.fill,
                            xCol: timeStampColumn.source,
                            yCol: timeStampColumn.source,
                            data: dataPoints,
                            identity: identity,
                            selected: !1,
                            labelSettings: dataPointLabelSettings,
                            width: settings.series.width,
                            widthOfGap: 0
                        }), xAxisCardProperties = PulseChartAxisPropertiesHelper.getCategoryAxisProperties(dataView.metadata);
                        var valueAxisProperties = PulseChartAxisPropertiesHelper.getValueAxisProperties(dataView.metadata), values = dataView.categorical.categories, valuesMetadataArray = [];
                        if (values) for (var i = 0; i < values.length; i++) values[i] && values[i].source && values[i].source.displayName && valuesMetadataArray.push({
                            displayName: values[i].source.displayName
                        });
                        var axesLabels = visuals.converterHelper.createAxesLabels(xAxisCardProperties, valueAxisProperties, timeStampColumn.source, valuesMetadataArray);
                        return interactivityService && interactivityService.applySelectionStateToData(series), 
                        {
                            columns: columns,
                            series: series,
                            isScalar: isScalar,
                            dataLabelsSettings: dataPointLabelSettings,
                            axesLabels: {
                                x: axesLabels.xAxisLabel,
                                y: axesLabels.yAxisLabel
                            },
                            hasDynamicSeries: hasDynamicSeries,
                            categoryMetadata: timeStampColumn.source,
                            categories: categoryValues,
                            settings: settings,
                            grouped: grouped,
                            hasHighlights: !!columns.Value.highlights,
                            widthOfXAxisLabel: widthOfXAxisLabel,
                            widthOfTooltipValueLabel: widthOfTooltipValueLabel,
                            heightOfTooltipDescriptionTextLine: heightOfTooltipDescriptionTextLine,
                            runnerCounterHeight: TextMeasurementService.measureSvgTextHeight(PulseChart.GetRunnerCounterTextProperties("lj", settings.runnerCounter.fontSize))
                        };
                    }, PulseChart.createAxisY = function(commonYScale, height, formatterOptions, show) {
                        void 0 === show && (show = !0);
                        var formatter = visuals.valueFormatter.create(formatterOptions), ticks = Math.max(2, Math.round(height / 40)), yAxis = d3.svg.axis().scale(commonYScale).ticks(ticks).outerTickSize(0).tickFormat(formatter.format);
                        return yAxis;
                    }, PulseChart.createAxisX = function(isScalar, series, originalScale, formatterOptions, dateFormat, position, widthOfXAxisLabel) {
                        for (var scales = PulseChart.getXAxisScales(series, isScalar, originalScale), xAxisProperties = new Array(scales.length), i = 0, rotate = !1; i < xAxisProperties.length; i++) {
                            var values = PulseChart.getXAxisValuesToDisplay(scales[i], rotate, isScalar, dateFormat, widthOfXAxisLabel);
                            if (!rotate && position === XAxisPosition.Bottom && values.length < PulseChart.MinimumTicksToRotate) {
                                var rotatedValues = PulseChart.getXAxisValuesToDisplay(scales[i], !0, isScalar, dateFormat, widthOfXAxisLabel);
                                if (rotatedValues.length > values.length) {
                                    rotate = !0, i = -1;
                                    continue;
                                }
                            }
                            xAxisProperties[i] = {
                                values: values,
                                scale: scales[i],
                                rotate: rotate
                            };
                        }
                        return formatterOptions.tickCount = xAxisProperties.length && 5 * xAxisProperties.map(function(x) {
                            return x.values.length;
                        }).reduce(function(a, b) {
                            return a + b;
                        }), formatterOptions.value = originalScale.domain()[0], formatterOptions.value2 = originalScale.domain()[1], 
                        xAxisProperties.forEach(function(properties) {
                            var values = properties.values.filter(function(value) {
                                return null !== value;
                            }), formatter = visuals.valueFormatter.create(formatterOptions);
                            properties.axis = d3.svg.axis().scale(properties.scale).tickValues(values).tickFormat(formatter.format).outerTickSize(0);
                        }), xAxisProperties;
                    }, PulseChart.getXAxisScales = function(series, isScalar, originalScale) {
                        return series.map(function(seriesElement) {
                            var dataPoints = seriesElement.data, minValue = dataPoints[0].categoryValue, maxValue = dataPoints[dataPoints.length - 1].categoryValue, minX = originalScale(dataPoints[0].categoryValue), maxX = originalScale(dataPoints[dataPoints.length - 1].categoryValue);
                            return PulseChart.createScale(isScalar, [ minValue, maxValue ], minX, maxX);
                        });
                    }, PulseChart.getXAxisValuesToDisplay = function(scale, rotate, isScalar, dateFormat, widthOfXAxisLabel) {
                        var genScale = scale, tickWidth = rotate ? PulseChart.XAxisTickHeight * (rotate ? Math.abs(Math.sin(PulseChart.AxisTickRotateAngle * Math.PI / 180)) : 0) : widthOfXAxisLabel, tickSpace = PulseChart.XAxisTickSpace;
                        if (scale.range()[1] < tickWidth) return [];
                        var minValue = scale.invert(scale.range()[0] + tickWidth / 2), maxValue = scale.invert(scale.range()[1] - tickWidth / 2), width = scale.range()[1] - scale.range()[0], maxTicks = Math.floor((width + tickSpace) / (tickWidth + tickSpace));
                        rotate && (maxTicks = Math.min(PulseChart.MinimumTicksToRotate, maxTicks));
                        var values = [];
                        if (values = isScalar ? d3.range(minValue, maxValue, (maxValue - minValue) / (100 * maxTicks)) : (dateFormat === PulseChartXAxisDateFormat.TimeOnly ? d3.time.minute : d3.time.day).range(minValue, maxValue), 
                        (!values.length || _.last(values) < maxValue) && values.push(maxValue), !maxTicks) return [];
                        maxTicks = Math.min(values.length, maxTicks);
                        var valuesIndexses = d3.scale.ordinal().domain(d3.range(maxTicks)).rangePoints([ 0, values.length - 1 ]).range();
                        values = valuesIndexses.map(function(x) {
                            return values[Math.round(x)];
                        });
                        for (var i = 1; i < values.length; i++) {
                            var prevXValue = genScale(values[i - 1]), curXValue = genScale(values[i]);
                            curXValue - prevXValue < tickWidth + tickSpace / 3 && values.splice(i--, 1);
                        }
                        return values;
                    }, PulseChart.getGroupIndex = function(index, grouped) {
                        for (var i = 0; i < grouped.length; i++) if (grouped[i].values && grouped[i].values[0] && void 0 !== grouped[i].values[0].values[index] && null !== grouped[i].values[0].values[index]) return i;
                        return 0;
                    }, PulseChart.getGapWidths = function(values) {
                        for (var result = [], i = 0, prevVal = 0, length = values.length; i < length; i++) prevVal && values[i] ? result.push(values[i] - prevVal) : result.push(0), 
                        prevVal = values[i];
                        return result;
                    }, PulseChart.createScale = function(isScalar, domain, minX, maxX) {
                        var scale;
                        return scale = isScalar ? d3.scale.linear() : d3.time.scale(), scale.domain(domain).range([ minX, maxX ]);
                    }, Object.defineProperty(PulseChart.prototype, "runnerCounterPlaybackButtonsHeight", {
                        get: function() {
                            return Math.max(PulseChart.PlaybackButtonsHeight, this.data && this.data.runnerCounterHeight / 2 + 17);
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(PulseChart.prototype, "popupHeight", {
                        get: function() {
                            return this.data && this.data.settings && this.data.settings.popup && this.data.settings.popup.show && this.data.settings.popup.height || 0;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), PulseChart.prototype.init = function(options) {
                        powerbi.formattingService.initialize(), this.host = options.host, this.selectionManager = new SelectionManager({
                            hostServices: this.host
                        });
                        var svg = this.svg = d3.select(options.element.get(0)).append("svg").classed("pulseChart", !0);
                        this.gaps = svg.append("g").classed(PulseChart.Gaps.class, !0), this.yAxis = svg.append("g").attr("class", "y axis"), 
                        this.chart = svg.append("g").attr("class", PulseChart.Chart.class), this.dots = svg.append("g").attr("class", "dots"), 
                        this.animationDot = this.dots.append("circle").classed(PulseChart.AnimationDot.class, !0).attr("display", "none"), 
                        this.animationHandler = new PulseAnimator(this, svg);
                        var style = options.style;
                        this.colors = style && style.colorPalette ? style.colorPalette.dataColors : new visuals.DataColorPalette();
                    }, PulseChart.prototype.update = function(options) {
                        if (options && options.dataViews && options.dataViews[0]) {
                            this.viewport = $.extend({}, options.viewport);
                            var dataView = options.dataViews[0];
                            if (this.updateData(PulseChart.converter(dataView, this.colors)), !this.validateData(this.data)) return void this.clearAll(!0);
                            var width = this.getChartWidth();
                            if (this.calculateXAxisProperties(width), this.data.xScale.ticks(void 0).length < 2) return void this.clearAll(!0);
                            var height = this.getChartHeight(this.data.settings.xAxis.show && this.data.series.some(function(series) {
                                return series.xAxisProperties.rotate;
                            }));
                            this.calculateYAxisProperties(height), this.size = {
                                width: width,
                                height: height
                            }, this.updateElements(), this.render(!0);
                        }
                    }, PulseChart.prototype.updateData = function(data) {
                        if (!this.data) return void (this.data = data);
                        var oldDataObj = this.getDataArrayToCompare(this.data), newDataObj = this.getDataArrayToCompare(data);
                        _.isEqual(oldDataObj, newDataObj) || this.clearAll(!1), this.data = data;
                    }, PulseChart.prototype.getDataArrayToCompare = function(data) {
                        if (!data || !data.series) return null;
                        var dataPoints = _.flatten(data.series.map(function(x) {
                            return x.data;
                        }));
                        return _.flatten(dataPoints.map(function(x) {
                            return x && _.flatten([ [ x.categoryValue, x.eventSize, x.groupIndex, x.runnerCounterValue, x.y, x.seriesIndex ], x.popupInfo && [ x.popupInfo.description, x.popupInfo.title, x.popupInfo.value ] ]);
                        }));
                    }, PulseChart.prototype.validateData = function(data) {
                        return !!data && !data.categories.some(function(x) {
                            return !(x instanceof Date || $.isNumeric(x));
                        });
                    }, PulseChart.prototype.getChartWidth = function() {
                        var marginRight = this.margin.right;
                        this.data.settings.yAxis && this.data.settings.yAxis.show && (marginRight += PulseChart.MaxWidthOfYAxis);
                        var width = this.viewport.width - this.margin.left - marginRight;
                        return Math.max(width, PulseChart.DefaultViewport.width);
                    }, PulseChart.prototype.getChartHeight = function(xAxisRotated) {
                        var marginBottom = 10 + (xAxisRotated ? this.data.widthOfXAxisLabel * Math.abs(Math.sin(PulseChart.AxisTickRotateAngle * Math.PI / 180)) : 3);
                        !this.data.settings.popup.alwaysOnTop && this.popupHeight && (marginBottom = Math.max(this.margin.bottom + this.popupHeight, marginBottom));
                        var height = this.viewport.height - this.margin.top - this.runnerCounterPlaybackButtonsHeight - marginBottom - this.popupHeight;
                        return Math.max(height, PulseChart.DefaultViewport.height);
                    }, PulseChart.prototype.updateElements = function() {
                        var chartMarginTop = this.margin.top + this.runnerCounterPlaybackButtonsHeight + this.popupHeight;
                        this.svg.attr(this.viewport), this.svg.style("display", void 0), this.gaps.attr("transform", visuals.SVGUtil.translate(this.margin.left, chartMarginTop + this.size.height / 2)), 
                        this.chart.attr("transform", visuals.SVGUtil.translate(this.margin.left, chartMarginTop)), 
                        this.yAxis.attr("transform", visuals.SVGUtil.translate(this.size.width + this.margin.left, chartMarginTop)), 
                        this.dots.attr("transform", visuals.SVGUtil.translate(this.margin.left, chartMarginTop));
                    }, PulseChart.prototype.calculateXAxisProperties = function(width) {
                        this.data.xScale = PulseChart.createScale(this.data.isScalar, [ this.data.categories[0], this.data.categories[this.data.categories.length - 1] ], 0, width);
                        var xAxisProperties = PulseChart.createAxisX(this.data.isScalar, this.data.series, this.data.xScale, $.extend({}, this.data.settings.xAxis.formatterOptions), this.data.settings.xAxis.dateFormat, this.data.settings.xAxis.position, this.data.widthOfXAxisLabel);
                        this.data.series.forEach(function(series, index) {
                            series.xAxisProperties = xAxisProperties[index];
                        });
                    }, PulseChart.prototype.calculateYAxisProperties = function(height) {
                        this.data.yScales = this.getYAxisScales(height);
                        var domain = [];
                        this.data.yScales.forEach(function(scale) {
                            return domain = domain.concat(scale.domain());
                        }), this.data.commonYScale = PulseChart.createScale(!0, [ d3.max(domain), d3.min(domain) ], 0, height), 
                        this.data.yAxis = PulseChart.createAxisY(this.data.commonYScale, height, this.data.settings.yAxis.formatterOptions);
                    }, PulseChart.prototype.getYAxisScales = function(height) {
                        var data = this.data, stepOfHeight = height / data.grouped.length;
                        return data.grouped.map(function(group, index) {
                            var values = group.values[0].values.map(function(x) {
                                return x || 0;
                            }), minValue = Number.MAX_VALUE, maxValue = -Number.MAX_VALUE;
                            if (values.forEach(function(value) {
                                value < minValue && (minValue = value), value > maxValue && (maxValue = value);
                            }), maxValue === minValue) {
                                var offset = 0 === maxValue ? 1 : Math.abs(maxValue / 2);
                                maxValue += offset, minValue -= offset;
                            }
                            return PulseChart.createScale(!0, [ maxValue, minValue ], stepOfHeight * index, stepOfHeight * (index + 1));
                        });
                    }, Object.defineProperty(PulseChart.prototype, "autoplayPauseDuration", {
                        get: function() {
                            return 1e3 * (this.data && this.data.settings && this.data.settings.playback ? this.data.settings.playback.autoplayPauseDuration : PulseChart.DefaultSettings.playback.autoplayPauseDuration);
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(PulseChart.prototype, "isAutoPlay", {
                        get: function() {
                            return this.data && this.data.settings && this.data.settings.playback && this.data.settings.playback.autoplay;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), PulseChart.prototype.render = function(suppressAnimations) {
                        var duration = visuals.AnimatorCommon.GetAnimationDuration(this.animator, suppressAnimations), data = this.data;
                        this.lastSelectedPoint = null;
                        var xScale = data.xScale, yScales = data.yScales;
                        this.lineX = d3.svg.line().x(function(d) {
                            return xScale(d.categoryValue);
                        }).y(function(d) {
                            return yScales[d.groupIndex](d.y);
                        }), this.data && this.data.settings && this.data.settings.playback && this.data.settings.playback.color && this.animationHandler.setControlsColor(this.data.settings.playback.color), 
                        this.animationHandler.render(), this.animationHandler.setRunnerCounterValue(), this.renderAxes(data, duration), 
                        this.renderGaps(data, duration);
                    }, PulseChart.prototype.renderAxes = function(data, duration) {
                        this.renderXAxis(data, duration), this.renderYAxis(data, duration);
                    }, PulseChart.prototype.renderXAxis = function(data, duration) {
                        var axisNodeSelection, axisNodeUpdateSelection, axisBoxUpdateSelection, color = PulseChart.DefaultSettings.xAxis.color, fontColor = PulseChart.DefaultSettings.xAxis.fontColor;
                        this.data && this.data.settings && this.data.settings.xAxis && (color = this.data.settings.xAxis.color, 
                        fontColor = this.data.settings.xAxis.fontColor), axisNodeSelection = this.rootSelection.selectAll(PulseChart.XAxisNode.selector), 
                        axisNodeUpdateSelection = axisNodeSelection.data(data.series), axisNodeUpdateSelection.enter().insert("g", "g." + PulseChart.LineContainer.class).classed(PulseChart.XAxisNode.class, !0), 
                        axisNodeUpdateSelection.call(function(selection) {
                            selection.forEach(function(selectionElement, index) {
                                d3.select(selectionElement[0]).call(data.series[index].xAxisProperties.axis.orient("bottom"));
                            });
                        }), axisNodeUpdateSelection.exit().remove(), axisBoxUpdateSelection = axisNodeUpdateSelection.selectAll(".tick").selectAll(".axisBox").data([ [] ]), 
                        axisBoxUpdateSelection.enter().insert("rect", "text").classed("axisBox", !0), axisBoxUpdateSelection.style("display", this.data.settings.xAxis.position === XAxisPosition.Center ? "inherit" : "none").style("fill", this.data.settings.xAxis.backgroundColor);
                        var tickRectY = this.data.settings.xAxis.position === XAxisPosition.Center ? -11 : 0;
                        axisBoxUpdateSelection.attr({
                            x: -(this.data.widthOfXAxisLabel / 2),
                            y: tickRectY + "px",
                            width: this.data.widthOfXAxisLabel,
                            height: PulseChart.XAxisTickHeight + "px"
                        }), axisBoxUpdateSelection.exit().remove(), axisNodeUpdateSelection.style("stroke", this.data.settings.xAxis.position === XAxisPosition.Center ? color : "none").style("display", this.data.settings.xAxis.show ? "inherit" : "none"), 
                        axisNodeUpdateSelection.call(function(selection) {
                            var rotate = selection.datum().xAxisProperties.rotate, rotateCoeff = rotate ? Math.abs(Math.sin(PulseChart.AxisTickRotateAngle * Math.PI / 180)) : 0, dy = tickRectY + 3;
                            selection.selectAll("text").attr("transform", function() {
                                return "translate(0, " + (dy + 9 + $(this).width() / 2 * rotateCoeff) + ") rotate(" + (rotate ? PulseChart.AxisTickRotateAngle : 0) + ")";
                            }).style("fill", fontColor).style("stroke", "none").attr("dy", -9);
                        }), axisNodeUpdateSelection.selectAll(".domain").style("stroke", color), axisNodeUpdateSelection.selectAll(".domain").forEach(function(element) {
                            $(element).insertBefore($(element).parent().children().first());
                        });
                        var xAxisTop = this.size.height;
                        switch (this.data.settings.xAxis.position) {
                          case XAxisPosition.Center:
                            xAxisTop /= 2;
                            break;

                          case XAxisPosition.Bottom:                        }
                        axisNodeUpdateSelection.attr("transform", visuals.SVGUtil.translate(0, xAxisTop));
                    }, PulseChart.prototype.renderYAxis = function(data, duration) {
                        var yAxis = data.yAxis, isShow = !1, color = PulseChart.DefaultSettings.yAxis.color, fontColor = PulseChart.DefaultSettings.yAxis.fontColor;
                        yAxis.orient("right"), this.data && this.data.settings && this.data.settings.yAxis && this.data.settings.yAxis.show && (isShow = !0), 
                        this.data && this.data.settings && this.data.settings.yAxis && this.data.settings.yAxis && (color = this.data.settings.yAxis.color, 
                        fontColor = this.data.settings.yAxis.fontColor), this.yAxis.call(yAxis).attr("display", isShow ? "inline" : "none"), 
                        this.yAxis.selectAll(".domain, path, line").style("stroke", color), this.yAxis.selectAll("text").style("fill", fontColor), 
                        this.yAxis.selectAll("g.tick line").attr("x1", -this.size.width);
                    }, PulseChart.prototype.renderChart = function() {
                        var data = this.data, series = this.data.series, selection = this.rootSelection = this.chart.selectAll(PulseChart.LineNode.selector).data(series), lineNode = selection.enter().append("g").classed(PulseChart.LineNode.class, !0);
                        lineNode.append("g").classed(PulseChart.LineContainer.class, !0), lineNode.append("g").classed(PulseChart.TooltipContainer.class, !0), 
                        lineNode.append("g").classed(PulseChart.DotsContainer.class, !0), this.animationHandler.isAnimated ? this.showAnimationDot() : this.hideAnimationDot(), 
                        this.drawTooltips(data, this.selectionManager.getSelectionIds()), this.drawDots(data), 
                        this.drawLines(data), selection.exit().remove();
                    }, PulseChart.prototype.drawLinesStatic = function(limit, isAnimated) {
                        var _this = this, node = PulseChart.Line, nodeParent = PulseChart.LineContainer, rootSelection = this.rootSelection, selection = rootSelection.filter(function(d, index) {
                            return !isAnimated || index < limit;
                        }).select(nodeParent.selector).selectAll(node.selector).data(function(d) {
                            return [ d ];
                        });
                        selection.enter().append("path").classed(node.class, !0), selection.style({
                            fill: "none",
                            stroke: function(d) {
                                return d.color;
                            },
                            "stroke-width": function(d) {
                                return d.width + "px";
                            }
                        }), selection.attr("d", function(d) {
                            return _this.lineX(d.data);
                        }), selection.exit().remove();
                    }, PulseChart.prototype.drawLinesStaticBeforeAnimation = function(limit) {
                        var _this = this, node = PulseChart.Line, nodeParent = PulseChart.LineContainer, rootSelection = this.rootSelection;
                        this.animationSelection = rootSelection.filter(function(d, index) {
                            return index === limit;
                        }).select(nodeParent.selector).selectAll(node.selector).data(function(d) {
                            return [ d ];
                        }), this.animationSelection.enter().append("path").classed(node.class, !0), this.animationSelection.style({
                            fill: "none",
                            stroke: function(d) {
                                return d.color;
                            },
                            "stroke-width": function(d) {
                                return d.width + "px";
                            }
                        }), this.animationSelection.attr("d", function(d) {
                            var flooredStart = _this.animationHandler.flooredPosition.index;
                            if (0 === flooredStart) return _this.moveAnimationDot(d.data[0]), _this.lineX([]);
                            var dataReduced = d.data.slice(0, flooredStart + 1);
                            return _this.moveAnimationDot(dataReduced[dataReduced.length - 1]), _this.lineX(dataReduced);
                        }), this.animationSelection.exit().remove();
                    }, PulseChart.prototype.moveAnimationDot = function(d) {
                        var xScale = this.data.xScale, yScales = this.data.yScales;
                        this.animationDot.attr("cx", xScale(d.x)).attr("cy", yScales[d.groupIndex](d.y));
                    }, PulseChart.prototype.playAnimation = function(delay) {
                        var _this = this;
                        void 0 === delay && (delay = 0);
                        var flooredStart = this.animationHandler.flooredPosition.index;
                        this.showAnimationDot(), this.animationSelection.transition().delay(delay).duration(this.animationDuration).ease("linear").attrTween("d", function(d, index) {
                            return _this.getInterpolation(d.data, flooredStart);
                        }).each("end", function(series) {
                            return _this.handleSelection(_this.animationHandler.flooredPosition);
                        });
                    }, PulseChart.prototype.pauseAnimation = function() {
                        this.animationSelection && (this.hideAnimationDot(), this.animationSelection.selectAll("path").transition(), 
                        this.animationSelection.transition().duration(0).delay(0));
                    }, PulseChart.prototype.stopAnimation = function() {
                        this.pauseAnimation(), d3.timer.flush();
                    }, PulseChart.prototype.findNextPoint = function(position) {
                        for (var i = position.series; i < this.data.series.length; i++) for (var series = this.data.series[i], j = i === position.series ? Math.floor(position.index + 1) : 0; j < series.data.length; j++) if (series.data[j] && series.data[j].popupInfo) return {
                            series: i,
                            index: j
                        };
                        return null;
                    }, PulseChart.prototype.findPrevPoint = function(position) {
                        for (var i = position.series; i >= 0; i--) for (var series = this.data.series[i], j = i === position.series ? Math.ceil(position.index - 1) : series.data.length; j >= 0; j--) if (series.data[j] && series.data[j].popupInfo) return {
                            series: i,
                            index: j
                        };
                        return null;
                    }, PulseChart.prototype.isAnimationSeriesAndIndexLast = function(position) {
                        return this.isAnimationSeriesLast(position) && this.isAnimationIndexLast(position);
                    }, PulseChart.prototype.isAnimationSeriesLast = function(position) {
                        return position.series >= this.data.series.length - 1;
                    }, PulseChart.prototype.isAnimationIndexLast = function(position) {
                        var series = this.data.series[position.series];
                        return position.index >= series.data.length - 1;
                    }, PulseChart.prototype.drawLines = function(data) {
                        var positionSeries = this.animationHandler.position.series, isAnimated = this.animationHandler.isAnimated;
                        this.drawLinesStatic(positionSeries, isAnimated), isAnimated && this.drawLinesStaticBeforeAnimation(positionSeries);
                    }, PulseChart.prototype.showAnimationDot = function() {
                        if (this.animationHandler.isPlaying) {
                            var size = PulseChart.DefaultSettings.dots.size;
                            this.data && this.data.settings && this.data.settings.dots && this.data.settings.dots.size && (size = this.data.settings.dots.size), 
                            this.animationDot.attr("display", "inline").attr("fill", this.data.settings.dots.color).style("opacity", this.dotOpacity).attr("r", size);
                        }
                    }, PulseChart.prototype.hideAnimationDot = function() {
                        this.animationDot.attr("display", "none");
                    }, PulseChart.prototype.getInterpolation = function(data, start) {
                        var _this = this;
                        if (this.data) {
                            var xScale = this.data.xScale, yScales = this.data.yScales, stop = start + 1;
                            this.showAnimationDot();
                            var lineFunction = d3.svg.line().x(function(d) {
                                return d.x;
                            }).y(function(d) {
                                return d.y;
                            }).interpolate("linear"), interpolatedLine = data.slice(0, start + 1).map(function(d) {
                                return {
                                    x: xScale(d.x),
                                    y: yScales[d.groupIndex](d.y)
                                };
                            }), x0 = xScale(data[start].x), x1 = xScale(data[stop].x), y0 = yScales[data[start].groupIndex](data[start].y), y1 = yScales[data[stop].groupIndex](data[stop].y), interpolateIndex = d3.scale.linear().domain([ 0, 1 ]).range([ start, stop ]), interpolateX = d3.scale.linear().domain([ 0, 1 ]).range([ x0, x1 ]), interpolateY = d3.scale.linear().domain([ 0, 1 ]).range([ y0, y1 ]);
                            return this.animationHandler.setRunnerCounterValue(start), function(t) {
                                if (!_this.animationHandler.isPlaying) return lineFunction(interpolatedLine);
                                var x = interpolateX(t), y = interpolateY(t);
                                return _this.animationDot.attr("cx", x).attr("cy", y), interpolatedLine.push({
                                    x: x,
                                    y: y
                                }), _this.animationHandler.position.index = interpolateIndex(t), lineFunction(interpolatedLine);
                            };
                        }
                    }, PulseChart.prototype.clearSelection = function() {
                        this.data && this.data.hasHighlights || !this.selectionManager.hasSelection() ? this.selectionManager.selectedIds = [] : this.selectionManager.clear(), 
                        this.chart.selectAll(PulseChart.Tooltip.selector).remove();
                    }, PulseChart.prototype.handleSelection = function(position) {
                        var _this = this;
                        if (this.data) {
                            var animationPlayingIndex = this.animationHandler.animationPlayingIndex, dataPoint = this.data.series[position.series].data[position.index], isLastDataPoint = this.animationHandler.isPlaying && this.isAnimationSeriesAndIndexLast(position);
                            if ((!dataPoint || !dataPoint.popupInfo) && this.animationHandler.isPlaying) return void (isLastDataPoint ? setTimeout(function() {
                                return _this.animationHandler.toEnd();
                            }, 0) : this.animationHandler.play(0, !0));
                            isLastDataPoint ? setTimeout(function() {
                                return _this.animationHandler.toEnd();
                            }, 0) : this.animationHandler.pause(), this.selectionManager.select(dataPoint.identity).then(function(selectionIds) {
                                _this.setSelection(selectionIds), clearTimeout(_this.handleSelectionTimeout), _this.handleSelectionTimeout = setTimeout(function() {
                                    _this.animationHandler.animationPlayingIndex === animationPlayingIndex && ((isLastDataPoint || _this.animationHandler.isPaused) && _this.clearSelection(), 
                                    !isLastDataPoint && _this.animationHandler.isPaused && _this.animationHandler.play());
                                }, _this.pauseDuration);
                            });
                        }
                    }, Object.defineProperty(PulseChart.prototype, "animationDuration", {
                        get: function() {
                            return 1e3 / (this.data && this.data.settings && this.data.settings.playback ? this.data.settings.playback.playSpeed : PulseChart.DefaultSettings.playback.playSpeed);
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(PulseChart.prototype, "pauseDuration", {
                        get: function() {
                            return 1e3 * (this.data && this.data.settings && this.data.settings.playback ? this.data.settings.playback.pauseDuration : PulseChart.DefaultSettings.playback.pauseDuration);
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(PulseChart.prototype, "dotOpacity", {
                        get: function() {
                            return 1 - (this.data && this.data.settings && this.data.settings.dots ? this.data.settings.dots.transparency : PulseChart.DefaultSettings.dots.transparency) / 100;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), PulseChart.prototype.drawDots = function(data) {
                        var _this = this;
                        if (data && data.xScale) {
                            var xScale = data.xScale, yScales = data.yScales, node = PulseChart.Dot, nodeParent = PulseChart.DotsContainer, rootSelection = this.rootSelection, dotColor = this.data.settings.dots.color, dotSize = this.data.settings.dots.size, isAnimated = this.animationHandler.isAnimated, position = this.animationHandler.position, selection = rootSelection.filter(function(d, index) {
                                return !isAnimated || index <= position.series;
                            }).select(nodeParent.selector).selectAll(node.selector).data(function(d, seriesIndex) {
                                return _.filter(d.data, function(value, valueIndex) {
                                    return !(isAnimated && seriesIndex === position.series && valueIndex > position.index) && !!value.popupInfo;
                                });
                            });
                            selection.enter().append("circle").classed(node.class, !0), selection.attr("cx", function(d) {
                                return xScale(d.categoryValue);
                            }).attr("cy", function(d) {
                                return yScales[d.groupIndex](d.y);
                            }).attr("r", function(d) {
                                return d.eventSize || dotSize;
                            }).style("fill", dotColor).style("opacity", this.dotOpacity).style("cursor", "pointer").call(PulseChart.AddOnTouchClick, function(d) {
                                d3.event.stopPropagation(), _this.selectionManager.select(d.identity, d3.event.ctrlKey).then(function(selectionIds) {
                                    return _this.setSelection(selectionIds);
                                });
                            }), selection.exit().remove();
                        }
                    }, PulseChart.prototype.renderGaps = function(data, duration) {
                        var gaps, gapsSelection, gapsEnterSelection, gapNodeSelection, series = data.series, isScalar = data.isScalar, xScale = data.xScale;
                        gaps = [ {
                            left: -4.5,
                            top: -5,
                            height: 10,
                            width: 3
                        }, {
                            left: 1.5,
                            top: -5,
                            height: 10,
                            width: 3
                        } ], gapsSelection = this.gaps.selectAll(PulseChart.Gap.selector).data(series.slice(0, series.length - 1)), 
                        gapsEnterSelection = gapsSelection.enter().append("g"), gapsSelection.attr("transform", function(seriesElement, index) {
                            var x, middleOfGap = seriesElement.widthOfGap / 2, categoryValue = seriesElement.data[seriesElement.data.length - 1].categoryValue;
                            return x = xScale(isScalar ? middleOfGap + categoryValue : new Date(middleOfGap + categoryValue.getTime())), 
                            visuals.SVGUtil.translate(x, 0);
                        }), gapNodeSelection = gapsSelection.selectAll(PulseChart.GapNode.selector).data(gaps), 
                        gapNodeSelection.enter().append("rect").attr({
                            x: function(gap) {
                                return gap.left;
                            },
                            y: function(gap) {
                                return gap.top;
                            },
                            height: function(gap) {
                                return gap.height;
                            },
                            width: function(gap) {
                                return gap.width;
                            }
                        }).classed(PulseChart.GapNode.class, !0), gapsEnterSelection.classed(PulseChart.Gap.class, !0), 
                        gapsSelection.exit().remove(), gapNodeSelection.exit().remove();
                    }, PulseChart.prototype.setSelection = function(selectionIds) {
                        this.data && (this.drawDots(this.data), this.drawTooltips(this.data, selectionIds));
                    }, PulseChart.prototype.isPopupShow = function(d, selectionIds) {
                        return !(!this.popupHeight || !d.popupInfo) && (!!selectionIds && SelectionManager.containsSelection(selectionIds, d.identity));
                    }, PulseChart.prototype.drawTooltips = function(data, selectionIds) {
                        var _this = this, xScale = data.xScale, yScales = data.yScales, node = PulseChart.Tooltip, nodeParent = PulseChart.TooltipContainer, rootSelection = this.rootSelection, line = d3.svg.line().x(function(d) {
                            return d.x;
                        }).y(function(d) {
                            return d.y;
                        }), marginTop = PulseChart.DefaultTooltipSettings.marginTop, width = this.data.settings.popup.width, height = this.data.settings.popup.height, topShift = 20, tooltipShiftY = function(y, groupIndex) {
                            return _this.isHigherMiddle(y, groupIndex) ? -1 * marginTop + topShift : _this.size.height + marginTop;
                        }, tooltipRoot = rootSelection.select(nodeParent.selector).selectAll(node.selector).data(function(d) {
                            return _.filter(d.data, function(value) {
                                return _this.isPopupShow(value, selectionIds);
                            });
                        });
                        tooltipRoot.enter().append("g").classed(node.class, !0), tooltipRoot.attr("transform", function(d) {
                            var x = xScale(d.x) - width / 2, y = tooltipShiftY(d.y, d.groupIndex);
                            return d.popupInfo.offsetX = Math.min(_this.viewport.width - _this.margin.right - width, Math.max(-_this.margin.left, x)) - x, 
                            visuals.SVGUtil.translate(x + d.popupInfo.offsetX, y);
                        });
                        var tooltipRect = tooltipRoot.selectAll(PulseChart.TooltipRect.selector).data(function(d) {
                            return [ d ];
                        });
                        tooltipRect.enter().append("path").classed(PulseChart.TooltipRect.class, !0), tooltipRect.attr("display", function(d) {
                            return d.popupInfo ? "inherit" : "none";
                        }).style("fill", this.data.settings.popup.color).attr("d", function(d) {
                            var path = [ {
                                x: -2,
                                y: _this.isHigherMiddle(d.y, d.groupIndex) ? -1 * marginTop : 0
                            }, {
                                x: -2,
                                y: _this.isHigherMiddle(d.y, d.groupIndex) ? -1 * (marginTop + height) : height
                            }, {
                                x: width - 2,
                                y: _this.isHigherMiddle(d.y, d.groupIndex) ? -1 * (marginTop + height) : height
                            }, {
                                x: width - 2,
                                y: _this.isHigherMiddle(d.y, d.groupIndex) ? -1 * marginTop : 0
                            } ];
                            return line(path);
                        });
                        var tooltipTriangle = tooltipRoot.selectAll(PulseChart.TooltipTriangle.selector).data(function(d) {
                            return [ d ];
                        });
                        tooltipTriangle.enter().append("path").classed(PulseChart.TooltipTriangle.class, !0), 
                        tooltipTriangle.style("fill", this.data.settings.popup.color).attr("d", function(d) {
                            var path = [ {
                                x: width / 2 - 5 - d.popupInfo.offsetX,
                                y: _this.isHigherMiddle(d.y, d.groupIndex) ? -1 * marginTop : 0
                            }, {
                                x: width / 2 - d.popupInfo.offsetX,
                                y: _this.isHigherMiddle(d.y, d.groupIndex) ? -1 * (marginTop - 5) : -5
                            }, {
                                x: width / 2 + 5 - d.popupInfo.offsetX,
                                y: _this.isHigherMiddle(d.y, d.groupIndex) ? -1 * marginTop : 0
                            } ];
                            return line(path);
                        }).style("stroke-width", "1px");
                        var tooltipLine = tooltipRoot.selectAll(PulseChart.TooltipLine.selector).data(function(d) {
                            return [ d ];
                        });
                        tooltipLine.enter().append("path").classed(PulseChart.TooltipLine.class, !0), tooltipLine.style("fill", this.data.settings.popup.color).style("stroke", this.data.settings.popup.color).style("stroke-width", "1px").attr("d", function(d) {
                            var path = [ {
                                x: width / 2 - d.popupInfo.offsetX,
                                y: _this.isHigherMiddle(d.y, d.groupIndex) ? yScales[d.groupIndex](d.y) + tooltipShiftY(d.y, d.groupIndex) - d.eventSize : yScales[d.groupIndex](d.y) - tooltipShiftY(d.y, d.groupIndex) + d.eventSize
                            }, {
                                x: width / 2 - d.popupInfo.offsetX,
                                y: _this.isHigherMiddle(d.y, d.groupIndex) ? -1 * marginTop : 0
                            } ];
                            return line(path);
                        });
                        var isShowTime = this.data.settings.popup.showTime, isShowTitle = this.data.settings.popup.showTitle, timeRect = tooltipRoot.selectAll(PulseChart.TooltipTimeRect.selector).data(function(d) {
                            return [ d ];
                        }), timeDisplayStyle = {
                            display: isShowTime ? void 0 : "none"
                        };
                        timeRect.enter().append("path").classed(PulseChart.TooltipTimeRect.class, !0), timeRect.style("fill", this.data.settings.popup.timeFill).style(timeDisplayStyle).attr("d", function(d) {
                            var path = [ {
                                x: width - _this.data.widthOfTooltipValueLabel - 2,
                                y: _this.isHigherMiddle(d.y, d.groupIndex) ? -1 * (marginTop + height) : 0
                            }, {
                                x: width - _this.data.widthOfTooltipValueLabel - 2,
                                y: _this.isHigherMiddle(d.y, d.groupIndex) ? -1 * (marginTop + height - PulseChart.DefaultTooltipSettings.timeHeight) : PulseChart.DefaultTooltipSettings.timeHeight
                            }, {
                                x: width - 2,
                                y: _this.isHigherMiddle(d.y, d.groupIndex) ? -1 * (marginTop + height - PulseChart.DefaultTooltipSettings.timeHeight) : PulseChart.DefaultTooltipSettings.timeHeight
                            }, {
                                x: width - 2,
                                y: _this.isHigherMiddle(d.y, d.groupIndex) ? -1 * (marginTop + height) : 0
                            } ];
                            return line(path);
                        });
                        var time = tooltipRoot.selectAll(PulseChart.TooltipTime.selector).data(function(d) {
                            return [ d ];
                        });
                        time.enter().append("text").classed(PulseChart.TooltipTime.class, !0), time.style(PulseChart.ConvertTextPropertiesToStyle(PulseChart.GetPopupValueTextProperties())).style(timeDisplayStyle).style("fill", this.data.settings.popup.timeColor).attr("x", function(d) {
                            return width - _this.data.widthOfTooltipValueLabel;
                        }).attr("y", function(d) {
                            return _this.isHigherMiddle(d.y, d.groupIndex) ? -1 * (marginTop + height - PulseChart.DefaultTooltipSettings.timeHeight + 3) : PulseChart.DefaultTooltipSettings.timeHeight - 3;
                        }).text(function(d) {
                            return d.popupInfo.value;
                        });
                        var titleDisplayStyle = {
                            display: isShowTitle ? void 0 : "none"
                        }, title = tooltipRoot.selectAll(PulseChart.TooltipTitle.selector).data(function(d) {
                            return [ d ];
                        });
                        title.enter().append("text").classed(PulseChart.TooltipTitle.class, !0), title.style(titleDisplayStyle).style(PulseChart.ConvertTextPropertiesToStyle(PulseChart.GetPopupTitleTextProperties())).style("fill", this.data.settings.popup.fontColor).attr("x", function(d) {
                            return PulseChart.PopupTextPadding;
                        }).attr("y", function(d) {
                            return (_this.isHigherMiddle(d.y, d.groupIndex) ? -1 * (marginTop + height - 12) : 12) + PulseChart.PopupTextPadding;
                        }).text(function(d) {
                            if (!d.popupInfo) return "";
                            var maxWidth = width - 2 * PulseChart.PopupTextPadding - (isShowTime ? _this.data.widthOfTooltipValueLabel - PulseChart.PopupTextPadding : 0) - 10;
                            return TextMeasurementService.getTailoredTextOrDefault(PulseChart.GetPopupTitleTextProperties(d.popupInfo.title), maxWidth);
                        });
                        var getDescriptionDimenstions = function(d) {
                            var shiftY = PulseChart.PopupTextPadding + _this.data.settings.popup.fontSize, descriptionYOffset = shiftY + PulseChart.DefaultTooltipSettings.timeHeight;
                            return d.popupInfo && (shiftY = isShowTitle && d.popupInfo.title || isShowTime && d.popupInfo.value ? descriptionYOffset : shiftY), 
                            {
                                y: _this.isHigherMiddle(d.y, d.groupIndex) ? -1 * (marginTop + height - shiftY) : shiftY,
                                x: PulseChart.PopupTextPadding,
                                width: width - 2 * PulseChart.PopupTextPadding,
                                height: height - shiftY
                            };
                        }, description = tooltipRoot.selectAll(PulseChart.TooltipDescription.selector).data(function(d) {
                            return [ d ];
                        });
                        description.enter().append("text").classed(PulseChart.TooltipDescription.class, !0), 
                        description.style(PulseChart.ConvertTextPropertiesToStyle(PulseChart.GetPopupDescriptionTextProperties(null, this.data.settings.popup.fontSize))).style("fill", this.data.settings.popup.fontColor).text(function(d) {
                            return d.popupInfo && d.popupInfo.description;
                        }).attr("y", function(d) {
                            var descriptionDimenstions = getDescriptionDimenstions(d), el = d3.select(this)[0][0];
                            return TextMeasurementService.wordBreak(el, descriptionDimenstions.width, descriptionDimenstions.height), 
                            0;
                        }).attr("transform", function(d) {
                            var descriptionDimenstions = getDescriptionDimenstions(d);
                            return visuals.SVGUtil.translate(0, descriptionDimenstions.y);
                        }), description.selectAll("tspan").attr("x", PulseChart.PopupTextPadding), tooltipRoot.exit().remove();
                    }, PulseChart.prototype.isHigherMiddle = function(value, groupIndex) {
                        if (this.data.settings.popup.alwaysOnTop) return !0;
                        if (this.data.yScales.length > 1) return 0 === groupIndex;
                        var domain = this.data.commonYScale.domain(), minValue = d3.min(domain), middleValue = Math.abs((d3.max(domain) - minValue) / 2);
                        return middleValue = 0 === middleValue ? middleValue : minValue + middleValue, value >= middleValue;
                    }, PulseChart.getObjectsFromDataView = function(dataView) {
                        return dataView && dataView.metadata && dataView.metadata.columns && dataView.metadata.objects ? dataView.metadata.objects : null;
                    }, PulseChart.parseSettings = function(dataView, colors, columns) {
                        var settings = {}, objects = PulseChart.getObjectsFromDataView(dataView);
                        return settings.xAxis = this.getAxisXSettings(objects, colors), settings.yAxis = this.getAxisYSettings(objects, colors), 
                        settings.popup = this.getPopupSettings(objects, colors), settings.dots = this.getDotsSettings(objects, colors), 
                        settings.series = this.getSeriesSettings(objects, colors), settings.gaps = this.getGapsSettings(objects), 
                        settings.playback = this.getPlaybackSettings(objects, colors), settings.runnerCounter = this.getRunnerCounterSettings(objects, colors, columns), 
                        settings;
                    }, PulseChart.getPopupSettings = function(objects, colors) {
                        var show = powerbi.DataViewObjects.getValue(objects, PulseChart.Properties.popup.show, PulseChart.DefaultSettings.popup.show), alwaysOnTop = powerbi.DataViewObjects.getValue(objects, PulseChart.Properties.popup.alwaysOnTop, PulseChart.DefaultSettings.popup.alwaysOnTop), width = Math.max(PulseChart.PopupMinWidth, Math.min(PulseChart.PopupMaxWidth, powerbi.DataViewObjects.getValue(objects, PulseChart.Properties.popup.width, PulseChart.DefaultSettings.popup.width))), height = Math.max(PulseChart.PopupMinHeight, Math.min(PulseChart.PopupMaxHeight, powerbi.DataViewObjects.getValue(objects, PulseChart.Properties.popup.height, PulseChart.DefaultSettings.popup.height))), colorHelper = new visuals.ColorHelper(colors, PulseChart.Properties.popup.color, PulseChart.DefaultSettings.popup.color), color = colorHelper.getColorForMeasure(objects, ""), fontSize = parseInt(powerbi.DataViewObjects.getValue(objects, PulseChart.Properties.popup.fontSize, PulseChart.DefaultSettings.popup.fontSize), 10), fontColorHelper = new visuals.ColorHelper(colors, PulseChart.Properties.popup.fontColor, PulseChart.DefaultSettings.popup.fontColor), fontColor = fontColorHelper.getColorForMeasure(objects, ""), showTime = powerbi.DataViewObjects.getValue(objects, PulseChart.Properties.popup.showTime, PulseChart.DefaultSettings.popup.showTime), showTitle = powerbi.DataViewObjects.getValue(objects, PulseChart.Properties.popup.showTitle, PulseChart.DefaultSettings.popup.showTitle), timeColorHelper = new visuals.ColorHelper(colors, PulseChart.Properties.popup.timeColor, PulseChart.DefaultSettings.popup.timeColor), timeColor = timeColorHelper.getColorForMeasure(objects, ""), timeFillHelper = new visuals.ColorHelper(colors, PulseChart.Properties.popup.timeFill, PulseChart.DefaultSettings.popup.timeFill), timeFill = timeFillHelper.getColorForMeasure(objects, "");
                        return {
                            show: show,
                            alwaysOnTop: alwaysOnTop,
                            width: width,
                            height: height,
                            color: color,
                            fontSize: fontSize,
                            fontColor: fontColor,
                            showTime: showTime,
                            showTitle: showTitle,
                            timeColor: timeColor,
                            timeFill: timeFill
                        };
                    }, PulseChart.getDotsSettings = function(objects, colors) {
                        var properties = PulseChart.Properties.dots, defaultSettings = PulseChart.DefaultSettings.dots, colorHelper = new visuals.ColorHelper(colors, properties.color, defaultSettings.color), color = colorHelper.getColorForMeasure(objects, ""), minSize = Math.max(0, Math.min(9999, powerbi.DataViewObjects.getValue(objects, properties.minSize, defaultSettings.minSize))), maxSize = Math.max(minSize, Math.min(9999, powerbi.DataViewObjects.getValue(objects, properties.maxSize, defaultSettings.maxSize))), size = Math.max(minSize, Math.min(maxSize, powerbi.DataViewObjects.getValue(objects, properties.size, defaultSettings.size))), transparency = Math.max(0, Math.min(100, powerbi.DataViewObjects.getValue(objects, properties.transparency, defaultSettings.transparency)));
                        return {
                            color: color,
                            size: size,
                            minSize: minSize,
                            maxSize: maxSize,
                            transparency: transparency
                        };
                    }, PulseChart.getSeriesSettings = function(objects, colors) {
                        var width = Math.max(1, Math.min(100, powerbi.DataViewObjects.getValue(objects, PulseChart.Properties.series.width, PulseChart.DefaultSettings.series.width))), colorHelper = new visuals.ColorHelper(colors, PulseChart.Properties.series.fill, PulseChart.DefaultSettings.series.fill), fill = colorHelper.getColorForMeasure(objects, "");
                        return {
                            width: width,
                            fill: fill
                        };
                    }, PulseChart.getGapsSettings = function(objects) {
                        var show = powerbi.DataViewObjects.getValue(objects, PulseChart.Properties.gaps.show, PulseChart.DefaultSettings.gaps.show), visibleGapsPercentage = Math.max(1, Math.min(100, powerbi.DataViewObjects.getValue(objects, PulseChart.Properties.gaps.transparency, PulseChart.DefaultSettings.gaps.visibleGapsPercentage)));
                        return {
                            show: show,
                            visibleGapsPercentage: visibleGapsPercentage
                        };
                    }, PulseChart.getAxisXSettings = function(objects, colors) {
                        var properties = PulseChart.Properties.xAxis, defaultSettings = PulseChart.DefaultSettings.xAxis, color = new visuals.ColorHelper(colors, properties.color, defaultSettings.color).getColorForMeasure(objects, ""), fontColor = new visuals.ColorHelper(colors, properties.fontColor, defaultSettings.fontColor).getColorForMeasure(objects, ""), show = powerbi.DataViewObjects.getValue(objects, properties.show, defaultSettings.show), position = powerbi.DataViewObjects.getValue(objects, properties.position, defaultSettings.position), backgroundColor = new visuals.ColorHelper(colors, properties.backgroundColor, defaultSettings.backgroundColor).getColorForMeasure(objects, "");
                        return {
                            show: show,
                            position: position,
                            color: color,
                            fontColor: fontColor,
                            backgroundColor: backgroundColor
                        };
                    }, PulseChart.getAxisYSettings = function(objects, colors) {
                        var properties = PulseChart.Properties.yAxis, defaultSettings = PulseChart.DefaultSettings.yAxis, colorHelper = new visuals.ColorHelper(colors, properties.color, defaultSettings.color), color = colorHelper.getColorForMeasure(objects, ""), fontColorHelper = new visuals.ColorHelper(colors, properties.fontColor, defaultSettings.fontColor), fontColor = fontColorHelper.getColorForMeasure(objects, ""), show = powerbi.DataViewObjects.getValue(objects, properties.show, defaultSettings.show);
                        return {
                            color: color,
                            fontColor: fontColor,
                            show: show
                        };
                    }, PulseChart.getPlaybackSettings = function(objects, colors) {
                        var playbackSettings = {}, properties = PulseChart.Properties.playback, defaultSettings = PulseChart.DefaultSettings.playback;
                        playbackSettings.autoplay = powerbi.DataViewObjects.getValue(objects, properties.autoplay, defaultSettings.autoplay), 
                        playbackSettings.playSpeed = Math.max(1, Math.min(99999, powerbi.DataViewObjects.getValue(objects, properties.playSpeed, defaultSettings.playSpeed))), 
                        playbackSettings.pauseDuration = Math.max(0, Math.min(9999, powerbi.DataViewObjects.getValue(objects, properties.pauseDuration, defaultSettings.pauseDuration))), 
                        playbackSettings.autoplayPauseDuration = Math.max(1, Math.min(9999, powerbi.DataViewObjects.getValue(objects, properties.autoplayPauseDuration, defaultSettings.autoplayPauseDuration)));
                        var colorHelper = new visuals.ColorHelper(colors, properties.color, defaultSettings.color);
                        playbackSettings.color = colorHelper.getColorForMeasure(objects, "");
                        var position = powerbi.DataViewObjects.getValue(objects, properties.position, "");
                        if (position.length > 3) try {
                            playbackSettings.position = JSON.parse(position);
                        } catch (ex) {}
                        return playbackSettings.position = playbackSettings.position || defaultSettings.position, 
                        playbackSettings;
                    }, PulseChart.getRunnerCounterSettings = function(objects, colors, columns) {
                        var show = powerbi.DataViewObjects.getValue(objects, PulseChart.Properties.runnerCounter.show, PulseChart.DefaultSettings.runnerCounter.show), label = powerbi.DataViewObjects.getValue(objects, PulseChart.Properties.runnerCounter.label, columns.RunnerCounter && columns.RunnerCounter.source && columns.RunnerCounter.source.displayName || PulseChart.DefaultSettings.runnerCounter.label), position = powerbi.DataViewObjects.getValue(objects, PulseChart.Properties.runnerCounter.position, PulseChart.DefaultSettings.runnerCounter.position), fontSize = parseInt(powerbi.DataViewObjects.getValue(objects, PulseChart.Properties.runnerCounter.fontSize, PulseChart.DefaultSettings.runnerCounter.fontSize), 10), fontColor = new visuals.ColorHelper(colors, PulseChart.Properties.runnerCounter.fontColor, PulseChart.DefaultSettings.runnerCounter.fontColor).getColorForMeasure(objects, "");
                        return {
                            show: show,
                            label: label,
                            position: position,
                            fontSize: fontSize,
                            fontColor: fontColor
                        };
                    }, PulseChart.prototype.clearAll = function(hide) {
                        this.gaps.selectAll(PulseChart.Gap.selector).remove(), this.animationHandler && (this.animationHandler.reset(), 
                        this.animationHandler.clear()), hide && this.svg.style("display", "none"), this.clearChart();
                    }, PulseChart.prototype.clearChart = function() {
                        this.clearSelection(), this.hideAnimationDot(), this.chart.selectAll(PulseChart.Line.selector).remove(), 
                        this.chart.selectAll(PulseChart.Dot.selector).remove();
                    }, PulseChart.prototype.clearRedundant = function(position) {
                        var _this = this;
                        if (this.data) {
                            var popups = this.chart.selectAll(PulseChart.Tooltip.selector).filter(function(data) {
                                return data.seriesIndex < position.series || data.seriesIndex === position.series && _this.data.series[data.seriesIndex].data[position.index].value >= data.value;
                            }), selectedPopupsIds = popups.data().map(function(data) {
                                return data.identity;
                            });
                            if (this.clearSelection(), selectedPopupsIds.length) {
                                var popupsSelecting = selectedPopupsIds.map(function(id) {
                                    return _this.selectionManager.select(id, !0);
                                });
                                $.when.apply(null, popupsSelecting).then(function(selectionIds) {
                                    return _this.setSelection(selectionIds);
                                });
                            }
                            this.chart.selectAll(PulseChart.Line.selector).remove(), this.chart.selectAll(PulseChart.Dot.selector).remove();
                        }
                    }, PulseChart.prototype.enumerateObjectInstances = function(options) {
                        var enumeration = new visuals.ObjectEnumerationBuilder();
                        switch (options.objectName) {
                          case "general":
                            this.readGeneralInstance(enumeration);
                            break;

                          case "popup":
                            this.readPopupInstance(enumeration);
                            break;

                          case "dots":
                            this.readDotsInstance(enumeration);
                            break;

                          case "xAxis":
                            this.xAxisInstance(enumeration);
                            break;

                          case "yAxis":
                            this.yAxisInstance(enumeration);
                            break;

                          case "series":
                            this.readSeriesInstance(enumeration);
                            break;

                          case "gaps":
                            this.readGapsInstance(enumeration);
                            break;

                          case "playback":
                            this.readPlaybackInstance(enumeration);
                            break;

                          case "runnerCounter":
                            this.readRunnerCounterInstance(enumeration);
                        }
                        return enumeration.complete();
                    }, PulseChart.prototype.getSettings = function(name) {
                        return this.data && this.data.settings && this.data.settings[name] ? this.data.settings[name] : PulseChart.DefaultSettings[name];
                    }, PulseChart.prototype.readGeneralInstance = function(enumeration) {
                        var instance = {
                            objectName: "general",
                            displayName: "general",
                            selector: null,
                            properties: {}
                        };
                        enumeration.pushInstance(instance);
                    }, PulseChart.prototype.readPopupInstance = function(enumeration) {
                        var settings = this.getSettings("popup"), popup = {
                            objectName: "popup",
                            displayName: "popup",
                            selector: null,
                            properties: {
                                show: settings.show,
                                alwaysOnTop: settings.alwaysOnTop,
                                width: settings.width,
                                height: settings.height,
                                color: settings.color,
                                fontColor: settings.fontColor,
                                fontSize: settings.fontSize,
                                showTime: settings.showTime,
                                showTitle: settings.showTitle,
                                timeColor: settings.timeColor,
                                timeFill: settings.timeFill
                            }
                        };
                        enumeration.pushInstance(popup);
                    }, PulseChart.prototype.readDotsInstance = function(enumeration) {
                        var settings = this.getSettings("dots"), instance = {
                            objectName: "dots",
                            displayName: "Dots",
                            selector: null,
                            properties: {
                                color: settings.color,
                                size: settings.size,
                                minSize: settings.minSize,
                                maxSize: settings.maxSize,
                                transparency: settings.transparency
                            }
                        };
                        enumeration.pushInstance(instance);
                    }, PulseChart.prototype.xAxisInstance = function(enumeration) {
                        var settings = this.getSettings("xAxis");
                        enumeration.pushInstance({
                            objectName: "xAxis",
                            displayName: "xAxis",
                            selector: null,
                            properties: {
                                show: settings.show,
                                position: settings.position,
                                color: settings.color,
                                fontColor: settings.fontColor,
                                backgroundColor: settings.backgroundColor
                            }
                        });
                    }, PulseChart.prototype.yAxisInstance = function(enumeration) {
                        var settings = this.getSettings("yAxis");
                        enumeration.pushInstance({
                            objectName: "yAxis",
                            displayName: "yAxis",
                            selector: null,
                            properties: {
                                color: settings.color,
                                fontColor: settings.fontColor,
                                show: settings.show
                            }
                        });
                    }, PulseChart.prototype.readSeriesInstance = function(enumeration) {
                        var settings = this.getSettings("series"), series = {
                            objectName: "series",
                            displayName: "series",
                            selector: null,
                            properties: {
                                fill: settings.fill,
                                width: settings.width
                            }
                        };
                        enumeration.pushInstance(series);
                    }, PulseChart.prototype.readGapsInstance = function(enumeration) {
                        var settings = this.getSettings("gaps"), gaps = {
                            objectName: "gaps",
                            selector: null,
                            properties: {
                                show: settings.show,
                                transparency: settings.visibleGapsPercentage
                            }
                        };
                        enumeration.pushInstance(gaps);
                    }, PulseChart.prototype.readPlaybackInstance = function(enumeration) {
                        var settings = this.getSettings("playback");
                        enumeration.pushInstance({
                            objectName: "playback",
                            displayName: "playback",
                            selector: null,
                            properties: {
                                autoplay: settings.autoplay,
                                playSpeed: settings.playSpeed,
                                pauseDuration: settings.pauseDuration,
                                autoplayPauseDuration: settings.autoplayPauseDuration,
                                color: settings.color
                            }
                        });
                    }, PulseChart.prototype.readRunnerCounterInstance = function(enumeration) {
                        var runnerCounterSettings = this.getSettings("runnerCounter"), instance = {
                            objectName: "runnerCounter",
                            selector: null,
                            properties: {}
                        };
                        this.data && this.data.columns && this.data.columns.RunnerCounter && (instance.properties = {
                            show: runnerCounterSettings.show,
                            label: runnerCounterSettings.label,
                            position: runnerCounterSettings.position,
                            fontSize: runnerCounterSettings.fontSize,
                            fontColor: runnerCounterSettings.fontColor
                        }), enumeration.pushInstance(instance);
                    }, PulseChart.prototype.destroy = function() {
                        this.data = null, this.clearAll(!0);
                    }, PulseChart.RoleDisplayNames = {
                        Timestamp: "Timestamp",
                        Category: "Category",
                        Value: "Value",
                        EventTitle: "Event Title",
                        EventDescription: "Event Description",
                        EventSize: "Event Size",
                        RunnerCounter: "Runner Counter"
                    }, PulseChart.RoleNames = _.mapValues(PulseChart.RoleDisplayNames, function(x, i) {
                        return i;
                    }), PulseChart.capabilities = {
                        dataRoles: [ {
                            displayName: PulseChart.RoleDisplayNames.Timestamp,
                            name: PulseChart.RoleNames.Timestamp,
                            kind: powerbi.VisualDataRoleKind.Grouping
                        }, {
                            displayName: PulseChart.RoleDisplayNames.Value,
                            name: PulseChart.RoleNames.Value,
                            kind: powerbi.VisualDataRoleKind.Measure
                        }, {
                            displayName: PulseChart.RoleDisplayNames.EventTitle,
                            name: PulseChart.RoleNames.EventTitle,
                            kind: powerbi.VisualDataRoleKind.GroupingOrMeasure
                        }, {
                            displayName: PulseChart.RoleDisplayNames.EventDescription,
                            name: PulseChart.RoleNames.EventDescription,
                            kind: powerbi.VisualDataRoleKind.GroupingOrMeasure
                        }, {
                            displayName: PulseChart.RoleDisplayNames.EventSize,
                            name: PulseChart.RoleNames.EventSize,
                            kind: powerbi.VisualDataRoleKind.GroupingOrMeasure
                        }, {
                            displayName: PulseChart.RoleDisplayNames.RunnerCounter,
                            name: PulseChart.RoleNames.RunnerCounter,
                            kind: powerbi.VisualDataRoleKind.GroupingOrMeasure
                        } ],
                        dataViewMappings: [ {
                            conditions: [ {
                                Timestamp: {
                                    max: 1
                                },
                                Value: {
                                    max: 1
                                },
                                Category: {
                                    max: 1
                                },
                                EventTitle: {
                                    max: 1
                                },
                                EventDescription: {
                                    max: 1
                                },
                                EventSize: {
                                    max: 1
                                },
                                RunnerCounter: {
                                    max: 1
                                }
                            } ],
                            categorical: {
                                categories: {
                                    for: {
                                        in: PulseChart.RoleNames.Timestamp
                                    },
                                    dataReductionAlgorithm: {
                                        top: {
                                            count: 1e4
                                        }
                                    }
                                },
                                values: {
                                    group: {
                                        by: PulseChart.RoleNames.Category,
                                        select: [ {
                                            bind: {
                                                to: PulseChart.RoleNames.Value
                                            }
                                        }, {
                                            bind: {
                                                to: PulseChart.RoleNames.EventTitle
                                            }
                                        }, {
                                            bind: {
                                                to: PulseChart.RoleNames.EventDescription
                                            }
                                        }, {
                                            bind: {
                                                to: PulseChart.RoleNames.EventSize
                                            }
                                        }, {
                                            bind: {
                                                to: PulseChart.RoleNames.RunnerCounter
                                            }
                                        } ],
                                        dataReductionAlgorithm: {
                                            top: {}
                                        }
                                    }
                                }
                            }
                        } ],
                        objects: {
                            series: {
                                displayName: "Series",
                                description: "Series",
                                properties: {
                                    fill: {
                                        displayName: "Fill",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    width: {
                                        displayName: "Width",
                                        type: {
                                            numeric: !0
                                        }
                                    }
                                }
                            },
                            gaps: {
                                displayName: "Gaps",
                                description: "Gaps",
                                properties: {
                                    show: {
                                        displayName: "Show",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    transparency: {
                                        displayName: "Visible gaps",
                                        type: {
                                            numeric: !0
                                        }
                                    }
                                }
                            },
                            general: {
                                displayName: "General",
                                properties: {
                                    formatString: {
                                        type: {
                                            formatting: {
                                                formatString: !0
                                            }
                                        }
                                    },
                                    fill: {
                                        displayName: "Background color",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    }
                                }
                            },
                            popup: {
                                displayName: "Popup",
                                properties: {
                                    show: {
                                        displayName: "Show",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    alwaysOnTop: {
                                        displayName: "Always on top",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    width: {
                                        displayName: "Width",
                                        type: {
                                            numeric: !0
                                        }
                                    },
                                    height: {
                                        displayName: "Height",
                                        type: {
                                            numeric: !0
                                        }
                                    },
                                    color: {
                                        displayName: "Fill",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    fontSize: {
                                        displayName: "Text size",
                                        type: {
                                            formatting: {
                                                fontSize: !0
                                            }
                                        }
                                    },
                                    fontColor: {
                                        displayName: "Text color",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    showTime: {
                                        displayName: "Show time",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    showTitle: {
                                        displayName: "Show title",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    timeColor: {
                                        displayName: "Time color",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    timeFill: {
                                        displayName: "Time fill",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    }
                                }
                            },
                            dots: {
                                displayName: "Dots",
                                properties: {
                                    color: {
                                        displayName: "Fill",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    minSize: {
                                        displayName: "Min Size",
                                        type: {
                                            numeric: !0
                                        }
                                    },
                                    maxSize: {
                                        displayName: "Max Size",
                                        type: {
                                            numeric: !0
                                        }
                                    },
                                    size: {
                                        displayName: "Default Size",
                                        type: {
                                            numeric: !0
                                        }
                                    },
                                    transparency: {
                                        displayName: "Transparency",
                                        type: {
                                            numeric: !0
                                        }
                                    }
                                }
                            },
                            xAxis: {
                                displayName: "X Axis",
                                properties: {
                                    show: {
                                        displayName: "Show",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    position: {
                                        displayName: "Position",
                                        type: {
                                            enumeration: createEnumTypeFromEnum(XAxisPosition)
                                        }
                                    },
                                    fontColor: {
                                        displayName: "Font Color",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    color: {
                                        displayName: "Axis Color",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    backgroundColor: {
                                        displayName: "Background Color",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    }
                                }
                            },
                            yAxis: {
                                displayName: "Y Axis",
                                properties: {
                                    show: {
                                        displayName: "Show",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    fontColor: {
                                        displayName: "Font Color",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    color: {
                                        displayName: "Axis Color",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    }
                                }
                            },
                            playback: {
                                displayName: "Playback",
                                properties: {
                                    autoplay: {
                                        displayName: "Autoplay",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    playSpeed: {
                                        displayName: "Speed (dots/sec)",
                                        type: {
                                            numeric: !0
                                        }
                                    },
                                    pauseDuration: {
                                        displayName: "Pause Duration",
                                        type: {
                                            numeric: !0
                                        }
                                    },
                                    autoplayPauseDuration: {
                                        displayName: "Start Delay",
                                        type: {
                                            numeric: !0
                                        }
                                    },
                                    color: {
                                        displayName: "Buttons Color",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    position: {
                                        displayName: "Position",
                                        type: {
                                            text: !0
                                        }
                                    }
                                }
                            },
                            runnerCounter: {
                                displayName: "Runner Counter",
                                properties: {
                                    show: {
                                        displayName: "Show",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    label: {
                                        displayName: "Label",
                                        type: {
                                            text: !0
                                        }
                                    },
                                    position: {
                                        displayName: "Position",
                                        type: {
                                            enumeration: createEnumTypeFromEnum(RunnerCounterPosition)
                                        }
                                    },
                                    fontSize: {
                                        displayName: "Text Size",
                                        type: {
                                            formatting: {
                                                fontSize: !0
                                            }
                                        }
                                    },
                                    fontColor: {
                                        displayName: "Font Color",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        },
                        sorting: {
                            implicit: {
                                clauses: [ {
                                    role: PulseChart.RoleNames.Timestamp,
                                    direction: 1
                                } ]
                            }
                        },
                        supportsHighlight: !0
                    }, PulseChart.Properties = PulseChart.getProperties(PulseChart.capabilities), PulseChart.DefaultMargin = {
                        top: 20,
                        bottom: 20,
                        right: 25,
                        left: 25
                    }, PulseChart.DefaultViewport = {
                        width: 50,
                        height: 50
                    }, PulseChart.PlaybackButtonsHeight = 26, PulseChart.PopupMinHeight = 20, PulseChart.PopupMinWidth = 20, 
                    PulseChart.PopupMaxHeight = 200, PulseChart.PopupMaxWidth = 2e3, PulseChart.MaxWidthOfYAxis = 50, 
                    PulseChart.PopupTextPadding = 3, PulseChart.XAxisTickSpace = 15, PulseChart.XAxisTickHeight = 16, 
                    PulseChart.MinimumTicksToRotate = 3, PulseChart.AxisTickRotateAngle = -35, PulseChart.DefaultSettings = {
                        precision: 0,
                        popup: {
                            show: !0,
                            alwaysOnTop: !1,
                            width: 100,
                            height: 80,
                            color: "#808181",
                            fontSize: 10,
                            fontColor: "white",
                            showTime: !0,
                            showTitle: !0,
                            timeColor: "white",
                            timeFill: "#010101"
                        },
                        dots: {
                            color: "#808181",
                            size: 5,
                            minSize: 5,
                            maxSize: 20,
                            transparency: 25
                        },
                        gaps: {
                            show: !1,
                            visibleGapsPercentage: 1
                        },
                        series: {
                            fill: "#3779B7",
                            width: 2
                        },
                        xAxis: {
                            color: "#777777",
                            fontColor: "#777777",
                            position: XAxisPosition.Center,
                            show: !0,
                            dateFormat: PulseChartXAxisDateFormat.TimeOnly,
                            backgroundColor: "#E1F2F7"
                        },
                        yAxis: {
                            color: "#777777",
                            fontColor: "#777777",
                            show: !0
                        },
                        playback: {
                            autoplay: !1,
                            playSpeed: 5,
                            pauseDuration: 10,
                            autoplayPauseDuration: 0,
                            color: "#777",
                            position: null
                        },
                        runnerCounter: {
                            show: !0,
                            label: "",
                            position: RunnerCounterPosition.TopRight,
                            fontSize: 13,
                            fontColor: "#777777"
                        },
                        formatStringProperty: PulseChart.Properties.general.formatString
                    }, PulseChart.DefaultTooltipSettings = {
                        dataPointColor: "#808181",
                        marginTop: 20,
                        timeHeight: 15
                    }, PulseChart.MaxGapCount = 100, PulseChart.MinGapWidth = _.object([ [ PulseChartXAxisDateFormat.DateOnly, 144e4 ], [ PulseChartXAxisDateFormat.TimeOnly, 6e4 ] ], void 0), 
                    PulseChart.Chart = createClassAndSelector("chart"), PulseChart.Line = createClassAndSelector("line"), 
                    PulseChart.LineContainer = createClassAndSelector("lineContainer"), PulseChart.LineNode = createClassAndSelector("lineNode"), 
                    PulseChart.XAxisNode = createClassAndSelector("xAxisNode"), PulseChart.Dot = createClassAndSelector("dot"), 
                    PulseChart.DotsContainer = createClassAndSelector("dotsContainer"), PulseChart.Tooltip = createClassAndSelector("Tooltip"), 
                    PulseChart.TooltipRect = createClassAndSelector("tooltipRect"), PulseChart.TooltipTriangle = createClassAndSelector("tooltipTriangle"), 
                    PulseChart.Gaps = createClassAndSelector("gaps"), PulseChart.Gap = createClassAndSelector("gap"), 
                    PulseChart.GapNode = createClassAndSelector("gapNode"), PulseChart.TooltipLine = createClassAndSelector("tooltipLine"), 
                    PulseChart.TooltipTime = createClassAndSelector("tooltipTime"), PulseChart.TooltipTimeRect = createClassAndSelector("tooltipTimeRect"), 
                    PulseChart.TooltipTitle = createClassAndSelector("tooltipTitle"), PulseChart.TooltipDescription = createClassAndSelector("tooltipDescription"), 
                    PulseChart.TooltipContainer = createClassAndSelector("tooltipContainer"), PulseChart.AnimationDot = createClassAndSelector("animationDot"), 
                    PulseChart;
                }();
                samples.PulseChart = PulseChart;
                var PulseAnimatorStates;
                !function(PulseAnimatorStates) {
                    PulseAnimatorStates[PulseAnimatorStates.Ready = 0] = "Ready", PulseAnimatorStates[PulseAnimatorStates.Play = 1] = "Play", 
                    PulseAnimatorStates[PulseAnimatorStates.Paused = 2] = "Paused", PulseAnimatorStates[PulseAnimatorStates.Stopped = 3] = "Stopped";
                }(PulseAnimatorStates || (PulseAnimatorStates = {}));
                var PulseAnimator = function() {
                    function PulseAnimator(chart, svg) {
                        var _this = this;
                        this.animationPlayingIndex = 0, this.runnerCounterTopLeftPosition = 180, this.isAutoPlayed = !1, 
                        this.isPositionWasSaved = !1, this.chart = chart, this.svg = svg, this.setDefaultValues();
                        var container = this.container = this.svg.append("g");
                        this.animationPlay = container.append("g").classed(PulseAnimator.AnimationPlay.class, !0), 
                        this.animationPlay.append("circle").attr("cx", 12).attr("cy", 12).attr("r", 10).attr("fill", "transparent"), 
                        this.animationPlay.call(PulseChart.AddOnTouchClick, function() {
                            return _this.play();
                        }), this.animationPlay.append("path").attr("d", "M12 2c5.514 0 10 4.486 10 10s-4.486 10-10 10-10-4.486-10-10 4.486-10 10-10zm0-2c-6.627 0-12 5.373-12 12s5.373 12 12 12 12-5.373 12-12-5.373-12-12-12zm-3 17v-10l9 5.146-9 4.854z"), 
                        this.animationPause = container.append("g").classed(PulseAnimator.AnimationPause.class, !0), 
                        this.animationPause.append("circle").attr("cx", 12).attr("cy", 12).attr("r", 10).attr("fill", "transparent"), 
                        this.animationPause.call(PulseChart.AddOnTouchClick, function() {
                            return _this.stop();
                        }), this.animationPause.append("path").attr("d", "M12 2c5.514 0 10 4.486 10 10s-4.486 10-10 10-10-4.486-10-10 4.486-10 10-10zm0-2c-6.627 0-12 5.373-12 12s5.373 12 12 12 12-5.373 12-12-5.373-12-12-12zm-1 17h-3v-10h3v10zm5-10h-3v10h3v-10z"), 
                        this.animationReset = container.append("g").classed(PulseAnimator.AnimationReset.class, !0), 
                        this.animationReset.append("circle").attr("cx", 12).attr("cy", 12).attr("r", 10).attr("fill", "transparent"), 
                        this.animationReset.call(PulseChart.AddOnTouchClick, function() {
                            return _this.reset();
                        }), this.animationReset.append("path").attr("d", "M22 12c0 5.514-4.486 10-10 10s-10-4.486-10-10 4.486-10 10-10 10 4.486 10 10zm-22 0c0 6.627 5.373 12 12 12s12-5.373 12-12-5.373-12-12-12-12 5.373-12 12zm13 0l5-4v8l-5-4zm-5 0l5-4v8l-5-4zm-2 4h2v-8h-2v8z"), 
                        this.animationPrev = container.append("g").classed(PulseAnimator.AnimationPrev.class, !0), 
                        this.animationPrev.append("circle").attr("cx", 12).attr("cy", 12).attr("r", 10).attr("fill", "transparent"), 
                        this.animationPrev.call(PulseChart.AddOnTouchClick, function() {
                            return _this.prev();
                        }), this.animationPrev.append("path").attr("d", "M9.5 12l7.5-4.5v9l-7.5-4.5zm-4.5 0l6.5 4v-1.634l-3.943-2.366 3.943-2.366v-1.634l-6.5 4zm17 0c0 5.514-4.486 10-10 10s-10-4.486-10-10 4.486-10 10-10 10 4.486 10 10zm-22 0c0 6.627 5.373 12 12 12s12-5.373 12-12-5.373-12-12-12-12 5.373-12 12z"), 
                        this.animationNext = container.append("g").classed(PulseAnimator.AnimationNext.class, !0), 
                        this.animationNext.append("circle").attr("cx", 12).attr("cy", 12).attr("r", 10).attr("fill", "transparent"), 
                        this.animationNext.call(PulseChart.AddOnTouchClick, function() {
                            return _this.next();
                        }), this.animationNext.append("path").attr("d", "M7 16.5v-9l7.5 4.5-7.5 4.5zm5.5-8.5v1.634l3.943 2.366-3.943 2.366v1.634l6.5-4-6.5-4zm-.5-6c5.514 0 10 4.486 10 10s-4.486 10-10 10-10-4.486-10-10 4.486-10 10-10zm0-2c-6.627 0-12 5.373-12 12s5.373 12 12 12 12-5.373 12-12-5.373-12-12-12z").attr("rotate", 180), 
                        this.animationToEnd = container.append("g").classed(PulseAnimator.AnimationToEnd.class, !0), 
                        this.animationToEnd.append("circle").attr("cx", 12).attr("cy", 12).attr("r", 10).attr("fill", "transparent"), 
                        this.animationToEnd.call(PulseChart.AddOnTouchClick, function() {
                            return _this.toEnd();
                        }), this.animationToEnd.append("path").attr("d", "M12 2c5.514 0 10 4.486 10 10s-4.486 10-10 10-10-4.486-10-10 4.486-10 10-10zm0-2c-6.627 0-12 5.373-12 12s5.373 12 12 12 12-5.373 12-12-5.373-12-12-12zm-6 16v-8l5 4-5 4zm5 0v-8l5 4-5 4zm7-8h-2v8h2v-8z"), 
                        this.runnerCounter = container.append("g").classed(PulseAnimator.RunnerCounter.class, !0), 
                        this.runnerCounterText = this.runnerCounter.append("text"), this.setControlsColor(PulseAnimator.DefaultControlsColor);
                    }
                    return Object.defineProperty(PulseAnimator, "AnimationMinPosition", {
                        get: function() {
                            return {
                                series: 0,
                                index: 0
                            };
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(PulseAnimator.prototype, "runnerCounterPosition", {
                        get: function() {
                            return this.chart.data.settings.runnerCounter.position;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(PulseAnimator.prototype, "maxTextWidthOfRunnerCounterValue", {
                        get: function() {
                            var top = this.runnerCounterPosition === RunnerCounterPosition.TopLeft || this.runnerCounterPosition === RunnerCounterPosition.TopRight;
                            return this.chart.viewport.width - (top ? this.runnerCounterTopLeftPosition : 0);
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(PulseAnimator.prototype, "isAnimated", {
                        get: function() {
                            return this.animatorState === PulseAnimatorStates.Paused || this.animatorState === PulseAnimatorStates.Play || this.animatorState === PulseAnimatorStates.Stopped;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(PulseAnimator.prototype, "isPlaying", {
                        get: function() {
                            return this.animatorState === PulseAnimatorStates.Play;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(PulseAnimator.prototype, "isPaused", {
                        get: function() {
                            return this.animatorState === PulseAnimatorStates.Paused;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(PulseAnimator.prototype, "isStopped", {
                        get: function() {
                            return this.animatorState === PulseAnimatorStates.Stopped;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), PulseAnimator.prototype.setDefaultValues = function() {
                        this.position = PulseAnimator.AnimationMinPosition, this.animatorState = PulseAnimatorStates.Ready, 
                        this.runnerCounterValue = null;
                    }, PulseAnimator.prototype.render = function() {
                        this.renderControls(), this.disableControls(), this.chart.isAutoPlay || (this.isAutoPlayed = !0, 
                        this.savedPosition && (this.savedPosition = null)), this.chart.isAutoPlay && this.isAutoPlayed && this.animatorState === PulseAnimatorStates.Play && !this.isPositionWasSaved && !_.isEqual(this.autoPlayPosition, this.savedPosition) && (this.chart.stopAnimation(), 
                        this.isAutoPlayed = !1, this.isPositionWasSaved = !0, this.animatorState = PulseAnimatorStates.Ready), 
                        this.animatorState === PulseAnimatorStates.Play ? this.play() : this.chart.isAutoPlay && !this.isAutoPlayed && this.animatorState === PulseAnimatorStates.Ready ? (this.autoPlayPosition = this.savedPosition, 
                        this.isAutoPlayed = !0, this.savedPosition && this.savedPosition.series < this.chart.data.series.length && this.savedPosition.index < this.chart.data.series[this.savedPosition.series].data.length && (this.position = this.savedPosition), 
                        this.play(this.chart.autoplayPauseDuration)) : this.chart.renderChart();
                    }, PulseAnimator.prototype.setControlsColor = function(color) {
                        this.color = color;
                    }, PulseAnimator.prototype.renderControls = function() {
                        this.show(), this.animationPlay.attr("transform", visuals.SVGUtil.translate(0, 0)).attr("fill", this.color), 
                        this.animationPause.attr("transform", visuals.SVGUtil.translate(30, 0)).attr("fill", this.color), 
                        this.animationReset.attr("transform", visuals.SVGUtil.translate(60, 0)).attr("fill", this.color), 
                        this.animationPrev.attr("transform", visuals.SVGUtil.translate(90, 0)).attr("fill", this.color), 
                        this.animationNext.attr("transform", visuals.SVGUtil.translate(120, 0)).attr("fill", this.color), 
                        this.animationToEnd.attr("transform", visuals.SVGUtil.translate(150, 0)).attr("fill", this.color), 
                        this.runnerCounter.attr("fill", this.color).attr("transform", visuals.SVGUtil.translate(this.runnerCounterPosition === RunnerCounterPosition.TopLeft ? this.runnerCounterTopLeftPosition : this.chart.viewport.width - 2, this.chart.data.runnerCounterHeight / 2 + 7)), 
                        this.runnerCounterText.style("text-anchor", this.runnerCounterPosition === RunnerCounterPosition.TopLeft ? "start" : "end"), 
                        this.chart.data && this.chart.data.settings && (this.runnerCounterText.style(PulseChart.ConvertTextPropertiesToStyle(PulseChart.GetRunnerCounterTextProperties(null, this.chart.data.settings.runnerCounter.fontSize))), 
                        this.runnerCounterText.style("fill", this.chart.data.settings.runnerCounter.fontColor)), 
                        this.drawCounterValue();
                    }, PulseAnimator.setControlVisiblity = function(element, isVisible, isDisabled) {
                        void 0 === isDisabled && (isDisabled = !1), element.style("opacity", isVisible ? PulseAnimator.DefaultOpacity : PulseAnimator.DimmedOpacity), 
                        isVisible ? element.attr("display", "inline") : isDisabled && element.attr("display", "none");
                    }, PulseAnimator.prototype.disableControls = function() {
                        var showRunner = this.chart.data && this.chart.data.settings && this.chart.data.settings.runnerCounter.show;
                        switch (PulseAnimator.setControlVisiblity(this.animationReset, !0), PulseAnimator.setControlVisiblity(this.animationToEnd, !0), 
                        this.animatorState) {
                          case PulseAnimatorStates.Play:
                            PulseAnimator.setControlVisiblity(this.animationPlay, !1), PulseAnimator.setControlVisiblity(this.animationPrev, !0), 
                            PulseAnimator.setControlVisiblity(this.animationNext, !0), PulseAnimator.setControlVisiblity(this.animationPause, !0), 
                            PulseAnimator.setControlVisiblity(this.runnerCounter, showRunner, !0);
                            break;

                          case PulseAnimatorStates.Paused:
                            PulseAnimator.setControlVisiblity(this.animationPlay, !0), PulseAnimator.setControlVisiblity(this.animationPause, !0), 
                            PulseAnimator.setControlVisiblity(this.animationPrev, !0), PulseAnimator.setControlVisiblity(this.animationNext, !0), 
                            PulseAnimator.setControlVisiblity(this.runnerCounter, showRunner, !0);
                            break;

                          case PulseAnimatorStates.Stopped:
                            PulseAnimator.setControlVisiblity(this.animationPlay, !0), PulseAnimator.setControlVisiblity(this.animationPrev, !0), 
                            PulseAnimator.setControlVisiblity(this.animationNext, !0), PulseAnimator.setControlVisiblity(this.runnerCounter, showRunner, !0), 
                            PulseAnimator.setControlVisiblity(this.animationPause, !1);
                            break;

                          case PulseAnimatorStates.Ready:
                            PulseAnimator.setControlVisiblity(this.animationPlay, !0), PulseAnimator.setControlVisiblity(this.animationPrev, !1), 
                            PulseAnimator.setControlVisiblity(this.animationNext, !1), PulseAnimator.setControlVisiblity(this.animationPause, !1), 
                            PulseAnimator.setControlVisiblity(this.runnerCounter, !1, !0);
                            break;

                          default:
                            PulseAnimator.setControlVisiblity(this.animationPlay, !0), PulseAnimator.setControlVisiblity(this.animationPrev, !1), 
                            PulseAnimator.setControlVisiblity(this.animationNext, !1), PulseAnimator.setControlVisiblity(this.animationPause, !1), 
                            PulseAnimator.setControlVisiblity(this.runnerCounter, !1, !0);
                        }
                    }, PulseAnimator.prototype.show = function() {
                        this.container.style("display", "inline");
                    }, PulseAnimator.prototype.setRunnerCounterValue = function(index) {
                        var dataPoint = this.chart.data && this.chart.data.series && this.chart.data.series[this.position.series] && this.chart.data.series[this.position.series].data && this.chart.data.series[this.position.series].data[$.isNumeric(index) ? index : this.flooredPosition.index], runnerCounterValue = dataPoint && null != dataPoint.runnerCounterValue ? dataPoint.runnerCounterValue : "";
                        if (dataPoint && dataPoint.runnerCounterFormatString) {
                            var runnerCounterformatter = visuals.valueFormatter.create({
                                format: dataPoint.runnerCounterFormatString
                            });
                            runnerCounterValue = runnerCounterformatter.format(runnerCounterValue);
                        }
                        this.runnerCounterValue = this.chart.data.settings.runnerCounter.label + " " + runnerCounterValue, 
                        this.drawCounterValue();
                    }, PulseAnimator.prototype.drawCounterValue = function() {
                        var progressText = "" + this.runnerCounterValue;
                        this.runnerCounterText.text(progressText), TextMeasurementService.svgEllipsis(this.runnerCounterText.node(), this.maxTextWidthOfRunnerCounterValue);
                    }, PulseAnimator.prototype.play = function(delay, renderDuringPlaying) {
                        if (void 0 === delay && (delay = 0), void 0 === renderDuringPlaying && (renderDuringPlaying = !1), 
                        this.animatorState !== PulseAnimatorStates.Play || renderDuringPlaying) {
                            if (this.animatorState === PulseAnimatorStates.Ready && (this.animationPlayingIndex++, 
                            this.chart.clearChart()), this.chart.isAnimationIndexLast(this.position)) return void this.playNext();
                            this.animatorState === PulseAnimatorStates.Paused && this.chart.clearSelection(), 
                            this.animatorState = PulseAnimatorStates.Play, this.chart.renderChart(), this.chart.playAnimation(delay), 
                            this.disableControls();
                        }
                    }, PulseAnimator.prototype.playNext = function() {
                        this.pause(), this.chart.isAnimationSeriesLast(this.position) ? (this.setDefaultValues(), 
                        this.chart.clearSelection()) : (this.position = {
                            series: this.position.series + 1,
                            index: PulseAnimator.AnimationMinPosition.index
                        }, this.play());
                    }, PulseAnimator.prototype.pause = function() {
                        this.animatorState === PulseAnimatorStates.Play && (this.animatorState = PulseAnimatorStates.Paused, 
                        this.chart.pauseAnimation()), this.disableControls();
                    }, PulseAnimator.prototype.reset = function() {
                        this.clearTimeouts(), this.chart.stopAnimation(), this.chart.clearSelection(), this.chart.clearChart(), 
                        this.setDefaultValues(), this.animatorState = PulseAnimatorStates.Stopped, this.disableControls(), 
                        this.savedPosition = null;
                    }, PulseAnimator.prototype.next = function() {
                        if (this.isAnimated) {
                            this.stop();
                            var newPosition = this.chart.findNextPoint(this.position);
                            newPosition ? (this.position = newPosition, this.chart.renderChart()) : this.toEnd();
                        }
                    }, PulseAnimator.prototype.prev = function() {
                        if (this.isAnimated) {
                            this.stop();
                            var newPosition = this.chart.findPrevPoint(this.position);
                            newPosition ? (this.chart.clearRedundant(newPosition), this.position = newPosition, 
                            this.chart.renderChart()) : this.reset();
                        }
                    }, PulseAnimator.prototype.toEnd = function() {
                        this.savedPosition = null, this.chart.stopAnimation(), this.chart.clearSelection(), 
                        this.chart.clearChart(), this.setDefaultValues(), this.disableControls(), this.chart.renderChart();
                    }, PulseAnimator.prototype.stop = function() {
                        this.isAnimated && (this.drawCounterValue(), this.savedPosition = this.position, 
                        this.chart.stopAnimation(), this.animatorState = PulseAnimatorStates.Stopped, this.disableControls());
                    }, Object.defineProperty(PulseAnimator.prototype, "position", {
                        get: function() {
                            return this.positionValue;
                        },
                        set: function(position) {
                            this.positionValue = position;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(PulseAnimator.prototype, "flooredPosition", {
                        get: function() {
                            return this.position && {
                                series: this.position.series,
                                index: Math.floor(this.position.index)
                            };
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(PulseAnimator.prototype, "savedPosition", {
                        get: function() {
                            return this.chart.data && this.chart.data.settings && this.chart.data.settings.playback && this.chart.data.settings.playback.position;
                        },
                        set: function(position) {
                            this.chart.isAutoPlay || (position = null), this.chart.data && this.chart.data.settings && this.chart.data.settings.playback && (this.isPositionWasSaved = !0, 
                            this.chart.data && this.chart.data.settings && this.chart.data.settings.playback && (this.chart.data.settings.playback.position = position), 
                            this.chart.host.persistProperties({
                                merge: [ {
                                    objectName: "playback",
                                    selector: null,
                                    properties: {
                                        position: position && JSON.stringify(position) || ""
                                    }
                                } ]
                            }));
                        },
                        enumerable: !0,
                        configurable: !0
                    }), PulseAnimator.prototype.clear = function() {
                        this.isAnimated && this.chart.stopAnimation(), this.setDefaultValues(), this.container.style("display", "none");
                    }, PulseAnimator.prototype.clearTimeouts = function() {
                        clearTimeout(this.chart.handleSelectionTimeout);
                    }, PulseAnimator.AnimationPlay = createClassAndSelector("animationPlay"), PulseAnimator.AnimationPause = createClassAndSelector("animationPause"), 
                    PulseAnimator.AnimationReset = createClassAndSelector("animationReset"), PulseAnimator.AnimationToEnd = createClassAndSelector("animationToEnd"), 
                    PulseAnimator.AnimationPrev = createClassAndSelector("animationPrev"), PulseAnimator.AnimationNext = createClassAndSelector("animationNext"), 
                    PulseAnimator.RunnerCounter = createClassAndSelector("runnerCounter"), PulseAnimator.DimmedOpacity = .25, 
                    PulseAnimator.DefaultOpacity = 1, PulseAnimator.DefaultControlsColor = "#777", PulseAnimator;
                }();
                samples.PulseAnimator = PulseAnimator;
                var PulseChartDataLabelUtils;
                !function(PulseChartDataLabelUtils) {
                    function getDefaultPulseChartLabelSettings() {
                        return {
                            show: !1,
                            position: 0,
                            displayUnits: 0,
                            precision: defaultLabelPrecision,
                            labelColor: defaultLabelColor,
                            fontSize: DefaultFontSizeInPt,
                            labelDensity: defaultLabelDensity
                        };
                    }
                    PulseChartDataLabelUtils.getDefaultPulseChartLabelSettings = getDefaultPulseChartLabelSettings;
                }(PulseChartDataLabelUtils = samples.PulseChartDataLabelUtils || (samples.PulseChartDataLabelUtils = {}));
                var PulseChartAxisPropertiesHelper;
                !function(PulseChartAxisPropertiesHelper) {
                    function getCategoryAxisProperties(dataViewMetadata, axisTitleOnByDefault) {
                        var toReturn = {};
                        if (!dataViewMetadata) return toReturn;
                        var objects = dataViewMetadata.objects;
                        if (objects) {
                            var categoryAxisObject = objects.categoryAxis;
                            categoryAxisObject && (toReturn = {
                                show: categoryAxisObject.show,
                                axisType: categoryAxisObject.axisType,
                                axisScale: categoryAxisObject.axisScale,
                                start: categoryAxisObject.start,
                                end: categoryAxisObject.end,
                                showAxisTitle: null == categoryAxisObject.showAxisTitle ? axisTitleOnByDefault : categoryAxisObject.showAxisTitle,
                                axisStyle: categoryAxisObject.axisStyle,
                                labelColor: categoryAxisObject.labelColor,
                                labelDisplayUnits: categoryAxisObject.labelDisplayUnits,
                                labelPrecision: categoryAxisObject.labelPrecision,
                                duration: categoryAxisObject.duration
                            });
                        }
                        return toReturn;
                    }
                    function getValueAxisProperties(dataViewMetadata, axisTitleOnByDefault) {
                        var toReturn = {};
                        if (!dataViewMetadata) return toReturn;
                        var objects = dataViewMetadata.objects;
                        if (objects) {
                            var valueAxisObject = objects.valueAxis;
                            valueAxisObject && (toReturn = {
                                show: valueAxisObject.show,
                                position: valueAxisObject.position,
                                axisScale: valueAxisObject.axisScale,
                                start: valueAxisObject.start,
                                end: valueAxisObject.end,
                                showAxisTitle: null == valueAxisObject.showAxisTitle ? axisTitleOnByDefault : valueAxisObject.showAxisTitle,
                                axisStyle: valueAxisObject.axisStyle,
                                labelColor: valueAxisObject.labelColor,
                                labelDisplayUnits: valueAxisObject.labelDisplayUnits,
                                labelPrecision: valueAxisObject.labelPrecision,
                                secShow: valueAxisObject.secShow,
                                secPosition: valueAxisObject.secPosition,
                                secAxisScale: valueAxisObject.secAxisScale,
                                secStart: valueAxisObject.secStart,
                                secEnd: valueAxisObject.secEnd,
                                secShowAxisTitle: valueAxisObject.secShowAxisTitle,
                                secAxisStyle: valueAxisObject.secAxisStyle,
                                secLabelColor: valueAxisObject.secLabelColor,
                                secLabelDisplayUnits: valueAxisObject.secLabelDisplayUnits,
                                secLabelPrecision: valueAxisObject.secLabelPrecision
                            });
                        }
                        return toReturn;
                    }
                    PulseChartAxisPropertiesHelper.getCategoryAxisProperties = getCategoryAxisProperties, 
                    PulseChartAxisPropertiesHelper.getValueAxisProperties = getValueAxisProperties;
                }(PulseChartAxisPropertiesHelper = samples.PulseChartAxisPropertiesHelper || (samples.PulseChartAxisPropertiesHelper = {}));
            }(samples = visuals.samples || (visuals.samples = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi);
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var samples;
            !function(samples) {
                var SelectionManager = visuals.utility.SelectionManager, LineDotChart = function() {
                    function LineDotChart() {
                        this.margin = {
                            top: 10,
                            right: 30,
                            bottom: 10,
                            left: 10
                        }, this.LegendSize = 50, this.AxisSize = 30;
                    }
                    return LineDotChart.prototype.init = function(options) {
                        var _this = this;
                        this.hostServices = options.host, this.selectionManager = new SelectionManager({
                            hostServices: this.hostServices
                        }), this.root = d3.select(options.element.get(0)).append("svg").classed(LineDotChart.Identity.class, !0), 
                        this.root.on("click", function(d) {
                            _this.clearSelection();
                        }), this.main = this.root.append("g"), this.axes = this.main.append("g").classed(LineDotChart.Axes.class, !0), 
                        this.axisX = this.axes.append("g").classed(LineDotChart.Axis.class, !0), this.axisY = this.axes.append("g").classed(LineDotChart.Axis.class, !0), 
                        this.axisY2 = this.axes.append("g").classed(LineDotChart.Axis.class, !0), this.legends = this.main.append("g").classed(LineDotChart.Legends.class, !0), 
                        this.line = this.main.append("g").classed(LineDotChart.Values.class, !0), this.colors = options.style && options.style.colorPalette ? options.style.colorPalette.dataColors : new visuals.DataColorPalette();
                    }, LineDotChart.prototype.update = function(options) {
                        if (options.dataViews && options.dataViews[0]) {
                            var viewport = options.viewport, model = this.model = this.converter(options.dataViews[0], viewport);
                            this.clearSelection(), this.resize(viewport), this.draw(model);
                        }
                    }, LineDotChart.prototype.destroy = function() {
                        this.root = null;
                    }, LineDotChart.prototype.setIsStopped = function(isstopped) {
                        var objects = {
                            merge: [ {
                                objectName: "misc",
                                selector: void 0,
                                properties: {
                                    isstopped: isstopped
                                }
                            } ]
                        };
                        this.hostServices.persistProperties(objects), this.hostServices.onSelect({
                            visualObjects: []
                        });
                    }, LineDotChart.prototype.enumerateObjectInstances = function(options) {
                        var instances = [];
                        if (!this.model || !this.model.settings) return instances;
                        var settings = this.model.settings;
                        switch (options.objectName) {
                          case "lineoptions":
                            var lineoptions = {
                                objectName: "lineoptions",
                                displayName: "lineoptions",
                                selector: null,
                                properties: {
                                    fill: settings.lineFill,
                                    lineThickness: settings.lineThickness
                                }
                            };
                            instances.push(lineoptions);
                            break;

                          case "dotoptions":
                            var dotoptions = {
                                objectName: "dotoptions",
                                displayName: "dotoptions",
                                selector: null,
                                properties: {
                                    color: settings.dotFill,
                                    dotSizeMin: settings.dotSizeMin,
                                    dotSizeMax: settings.dotSizeMax
                                }
                            };
                            instances.push(dotoptions);
                            break;

                          case "counteroptions":
                            var counteroptions = {
                                objectName: "counteroptions",
                                displayName: "counteroptions",
                                selector: null,
                                properties: {
                                    counterTitle: settings.counterTitle
                                }
                            };
                            instances.push(counteroptions);
                            break;

                          case "misc":
                            var misc = {
                                objectName: "misc",
                                displayName: "misc",
                                selector: null,
                                properties: {
                                    isanimated: settings.isanimated,
                                    isstopped: settings.isstopped,
                                    duration: settings.duration
                                }
                            };
                            instances.push(misc);
                        }
                        return instances;
                    }, LineDotChart.prototype.selectDot = function(dotelement, selector) {
                        var dot = d3.select(dotelement);
                        dot.classed("point_selected") ? this.clearSelection() : (selector && this.selectionManager.select(selector), 
                        this.root.classed("filtered", !0), this.line.selectAll("circle.point").classed("point_selected", !1), 
                        d3.select(dotelement).classed("point_selected", !0)), d3.event.stopPropagation();
                    }, LineDotChart.prototype.clearSelection = function() {
                        this.root.classed("filtered", !1), this.root.selectAll("circle.point").classed("point_selected", !1), 
                        this.selectionManager.clear();
                    }, LineDotChart.prototype.converter = function(dataView, viewport) {
                        if (!(dataView.categorical && dataView.categorical.categories && dataView.categorical.categories[0] && dataView.categorical.categories[0].values && dataView.categorical.categories[0].values.length > 0 && dataView.categorical && dataView.categorical.values && dataView.categorical.values[0] && dataView.categorical.values[0].values && dataView.categorical.values[0].values.length > 0)) return null;
                        var metadataColumn, extent, min, max, values = [], that = this, categoryType = visuals.AxisHelper.getCategoryValueType(dataView.categorical.categories[0].source, !0);
                        this.isDateTime = visuals.AxisHelper.isDateTime(categoryType);
                        var formatter, isScalar = !0, settings = this.parseSettings(dataView), effectiveWidth = Math.max(0, viewport.width - this.margin.left - this.margin.right - this.LegendSize - this.AxisSize), effectiveHeight = Math.max(0, viewport.height - this.margin.top - this.margin.bottom - this.LegendSize), format = "";
                        values = dataView.categorical.categories[0].values, metadataColumn = dataView.categorical.categories[0].source, 
                        extent = d3.extent(values), this.isDateTime ? (min = extent[0].getTime(), max = extent[1].getTime(), 
                        min = new Date(min), max = new Date(max + .05 * (max - min)), format = "MMM dd yyyy", 
                        formatter = visuals.valueFormatter.create({
                            format: format
                        })) : (min = extent[0], max = extent[1], max += .05 * (max - min), formatter = visuals.valueFormatter.create({
                            value: 0
                        }));
                        var xAxis = visuals.AxisHelper.createAxis({
                            pixelSpan: effectiveWidth,
                            dataDomain: [ min, max ],
                            metaDataColumn: metadataColumn,
                            formatString: null,
                            outerPadding: 0,
                            isCategoryAxis: !0,
                            isScalar: isScalar,
                            isVertical: !1,
                            forcedTickCount: void 0,
                            useTickIntervalForDisplayUnits: !0,
                            getValueFn: function(index, type) {
                                return that.isDateTime ? formatter.format(new Date(index)) : index;
                            }
                        });
                        xAxis.formatter = formatter, metadataColumn = dataView.categorical.values[0].source, 
                        values = dataView.categorical.values[0].values, extent = d3.extent(values), min = extent[0], 
                        max = extent[1];
                        for (var selector, result = [], value_sum = 0, value = 0, time = 0, i = 0; i < dataView.categorical.categories[0].values.length; i++) value = dataView.categorical.values[0].values[i], 
                        time = dataView.categorical.categories[0].values[i], value_sum += value, selector = visuals.SelectionId.createWithId(dataView.categorical.categories[0].identity[i]), 
                        result.push({
                            dot: (value - min) / (max - min),
                            value: value,
                            sum: value_sum,
                            time: time,
                            selector: selector
                        });
                        value_sum += .1 * (value_sum - min);
                        var yAxis = visuals.AxisHelper.createAxis({
                            pixelSpan: effectiveHeight,
                            dataDomain: [ min, value_sum ],
                            metaDataColumn: metadataColumn,
                            formatString: null,
                            outerPadding: 0,
                            isCategoryAxis: !1,
                            isScalar: !0,
                            isVertical: !0,
                            useTickIntervalForDisplayUnits: !0
                        }), yAxis2 = visuals.AxisHelper.createAxis({
                            pixelSpan: effectiveHeight,
                            dataDomain: [ min, value_sum ],
                            metaDataColumn: metadataColumn,
                            formatString: null,
                            outerPadding: 0,
                            isCategoryAxis: !1,
                            isScalar: !0,
                            isVertical: !0,
                            useTickIntervalForDisplayUnits: !0
                        });
                        return yAxis2.axis.orient("right"), {
                            points: result,
                            settings: settings,
                            xAxis: xAxis,
                            yAxis: yAxis,
                            yAxis2: yAxis2,
                            legends: this.generateAxisLabels(viewport, settings)
                        };
                    }, LineDotChart.prototype.parseSettings = function(dataView) {
                        if (!(dataView && dataView.metadata && dataView.metadata.columns && dataView.metadata.columns[0])) return null;
                        var objects = dataView.metadata.objects, lineFillColorHelper = new visuals.ColorHelper(this.colors, LineDotChart.Properties.lineoptions.fill, LineDotChart.DefaultSettings.lineFill), dotFillColorHelper = new visuals.ColorHelper(this.colors, LineDotChart.Properties.dotoptions.color, LineDotChart.DefaultSettings.dotFill), xAxisTitle = LineDotChart.DefaultSettings.xAxisTitle, yAxisTitle = LineDotChart.DefaultSettings.yAxisTitle;
                        dataView.categorical.categories[0] && dataView.categorical.categories[0].source && dataView.categorical.categories[0].source.displayName && dataView.categorical.values[0] && dataView.categorical.values[0].source && dataView.categorical.values[0].source.displayName && (xAxisTitle = dataView.categorical.categories[0].source.displayName, 
                        yAxisTitle = dataView.categorical.values[0].source.displayName);
                        var lineThickness = LineDotChart.DefaultSettings.lineThickness, dotSizeMin = LineDotChart.DefaultSettings.dotSizeMin, dotSizeMax = LineDotChart.DefaultSettings.dotSizeMax, counterTitle = LineDotChart.DefaultSettings.counterTitle, isanimated = LineDotChart.DefaultSettings.isanimated, isstopped = LineDotChart.DefaultSettings.isstopped, duration = LineDotChart.DefaultSettings.duration;
                        return objects && (lineThickness = powerbi.DataViewObjects.getValue(objects, LineDotChart.Properties.lineoptions.lineThickness, LineDotChart.DefaultSettings.lineThickness), 
                        dotSizeMin = powerbi.DataViewObjects.getValue(objects, LineDotChart.Properties.dotoptions.dotSizeMin, LineDotChart.DefaultSettings.dotSizeMin), 
                        dotSizeMax = powerbi.DataViewObjects.getValue(objects, LineDotChart.Properties.dotoptions.dotSizeMax, LineDotChart.DefaultSettings.dotSizeMax), 
                        counterTitle = powerbi.DataViewObjects.getValue(objects, LineDotChart.Properties.counteroptions.counterTitle, LineDotChart.DefaultSettings.counterTitle), 
                        isanimated = powerbi.DataViewObjects.getValue(objects, LineDotChart.Properties.misc.isanimated, LineDotChart.DefaultSettings.isanimated), 
                        isstopped = powerbi.DataViewObjects.getValue(objects, LineDotChart.Properties.misc.isstopped, LineDotChart.DefaultSettings.isstopped), 
                        duration = powerbi.DataViewObjects.getValue(objects, LineDotChart.Properties.misc.duration, LineDotChart.DefaultSettings.duration)), 
                        {
                            xAxisTitle: xAxisTitle,
                            yAxisTitle: yAxisTitle,
                            lineFill: lineFillColorHelper.getColorForMeasure(objects, ""),
                            lineThickness: lineThickness,
                            dotFill: dotFillColorHelper.getColorForMeasure(objects, ""),
                            dotSizeMin: dotSizeMin,
                            dotSizeMax: dotSizeMax,
                            counterTitle: counterTitle,
                            isstopped: isstopped,
                            isanimated: isanimated,
                            duration: duration
                        };
                    }, LineDotChart.prototype.generateAxisLabels = function(viewport, settings) {
                        return [ {
                            transform: visuals.SVGUtil.translate((viewport.width - this.margin.left - this.margin.right) / 2, viewport.height - this.margin.top - this.margin.bottom),
                            text: settings.xAxisTitle,
                            dx: "1em",
                            dy: "-1em"
                        }, {
                            transform: visuals.SVGUtil.translateAndRotate(0, (viewport.height - this.margin.top - this.margin.bottom) / 2, 0, 0, 270),
                            text: settings.yAxisTitle,
                            dx: "3em"
                        } ];
                    }, LineDotChart.prototype.resize = function(viewport) {
                        this.root.attr({
                            height: Math.max(0, viewport.height),
                            width: Math.max(0, viewport.width)
                        }), this.main.attr("transform", visuals.SVGUtil.translate(this.margin.left, this.margin.top)), 
                        this.legends.attr("transform", visuals.SVGUtil.translate(this.margin.left, this.margin.top)), 
                        this.line.attr("transform", visuals.SVGUtil.translate(this.margin.left + this.LegendSize, 0)), 
                        this.axes.attr("transform", visuals.SVGUtil.translate(this.margin.left + this.LegendSize, 0)), 
                        this.axisX.attr("transform", visuals.SVGUtil.translate(0, viewport.height - this.margin.top - this.margin.bottom - this.LegendSize)), 
                        this.axisY2.attr("transform", visuals.SVGUtil.translate(viewport.width - this.margin.left - this.margin.right - this.LegendSize - this.AxisSize, 0));
                    }, LineDotChart.prototype.draw = function(model) {
                        var _this = this, that = this;
                        if (this.line.selectAll("*").remove(), this.legends.selectAll("*").remove(), this.axisX.selectAll("*").remove(), 
                        this.axisY.selectAll("*").remove(), this.axisY2.selectAll("*").remove(), model && (this.renderLegends(model), 
                        model && model.points && model.points.length)) {
                            if (this.axisX.call(model.xAxis.axis), this.axisY.call(model.yAxis.axis), this.axisY2.call(model.yAxis2.axis), 
                            model.settings.isanimated) {
                                var playBtn = this.line.append("g").classed("lineDotChart__playBtn", !0).attr("transform", "translate(40, 20)");
                                if (playBtn.append("circle").attr("r", 17), model.settings.isstopped) return playBtn.append("path").attr("d", "M0 2l10 6-10 6z").attr("transform", "translate(-4,-8)"), 
                                void playBtn.on("click.lineDotChart__playBt", function() {
                                    that.setIsStopped(!1);
                                });
                                playBtn.append("path").attr("d", "M0 2l10 6-10 6z").attr("transform-origin", "center").attr("transform", "translate(6, 8) rotate(180)"), 
                                playBtn.append("rect").attr("width", "2").attr("height", "12").attr("transform", "translate(-7,-6)"), 
                                playBtn.on("click.lineDotChart__playBt", function() {
                                    that.setIsStopped(!0);
                                });
                            }
                            var clip = this.line.append("clipPath").attr("id", "lineClip").append("rect").attr("x", 0).attr("y", 0).attr("width", 1).attr("height", 1e4), line = d3.svg.line().x(function(d) {
                                return model.xAxis.scale(d.time);
                            }).y(function(d) {
                                return model.yAxis.scale(d.sum);
                            }), lineSelection = this.line.selectAll("path.plot").data([ model.points ]);
                            lineSelection.enter().append("path"), lineSelection.classed("plot", !0).attr("stroke", function(d, i) {
                                return model.settings.lineFill;
                            }).attr("stroke-width", model.settings.lineThickness).attr("d", line);
                            var totalLength = lineSelection.node().getTotalLength(), line_left = lineSelection.node().getPointAtLength(0).x, line_right = lineSelection.node().getPointAtLength(totalLength).x;
                            lineSelection.attr("clip-path", "url(" + location.href + "#lineClip)"), model.settings.isanimated ? clip.attr("x", line_left).interrupt().transition().ease("linear").duration(1e3 * model.settings.duration).attr("width", line_right - line_left) : clip.interrupt().attr("x", line_left).attr("width", line_right - line_left), 
                            lineSelection.exit().remove();
                            var point_time = 300, counter_time = 0, lineTipSelection = this.line.selectAll("circle.point").data(model.points), that = this;
                            lineTipSelection.enter().append("circle").attr("fill", model.settings.dotFill).attr("opacity", .77).attr("r", function(d) {
                                return model.settings.dotSizeMin + d.dot * (model.settings.dotSizeMax - model.settings.dotSizeMin);
                            }).classed("point", !0).on("mouseover.point", this.showDataPoint).on("mouseout.point", this.hideDataPoint).on("click.point", function(d) {
                                that.selectDot(this, d.selector);
                            }), model.settings.isanimated ? lineTipSelection.interrupt().attr("transform", function(d) {
                                return "translate(" + model.xAxis.scale(d.time) + " " + model.yAxis.scale(d.sum) + ") scale(0.005)";
                            }).transition().duration(point_time).delay(function(d, i) {
                                return _this.pointDelay(model.points, i, model.settings.duration);
                            }).ease("linear").attr("transform", function(d) {
                                return "translate(" + model.xAxis.scale(d.time) + " " + model.yAxis.scale(d.sum) + ") scale(3.4)";
                            }).transition().duration(point_time).delay(function(d, i) {
                                return _this.pointDelay(model.points, i, model.settings.duration) + point_time;
                            }).ease("elastic").attr("transform", function(d) {
                                return "translate(" + model.xAxis.scale(d.time) + " " + model.yAxis.scale(d.sum) + ") scale(1)";
                            }) : lineTipSelection.interrupt().attr("transform", function(d) {
                                return "translate(" + model.xAxis.scale(d.time) + " " + model.yAxis.scale(d.sum) + ") scale(1)";
                            }), lineTipSelection.exit().remove();
                            for (var i = 0; i < lineTipSelection[0].length; i++) this.addTooltip(model, lineTipSelection[0][i]);
                            var lineTextSelection = this.line.selectAll("text").data(model.points);
                            lineTextSelection.enter().append("text").classed("text", !0).text(function(d, i) {
                                return model.settings.counterTitle + " " + (i + 1);
                            }).attr("x", line_right - 260).attr("y", 30), model.settings.isanimated ? lineTextSelection.attr("opacity", 0).interrupt().transition().duration(counter_time).delay(function(d, i) {
                                return _this.pointDelay(model.points, i, model.settings.duration);
                            }).attr("transform", "translate(0 0)").attr("opacity", 1).transition().duration(counter_time).delay(function(d, i) {
                                return model.points[i + 1] ? _this.pointDelay(model.points, i + 1, model.settings.duration) : Number.POSITIVE_INFINITY;
                            }).attr("opacity", 0) : lineTextSelection.interrupt().attr("transform", "translate(0 0)").attr("opacity", function(d, i) {
                                return Number(i === model.points.length - 1);
                            }), lineTextSelection.exit().remove();
                        }
                    }, LineDotChart.prototype.pointDelay = function(points, num, animation_duration) {
                        if (!points.length || !points[num] || 0 === num) return 0;
                        if (this.isDateTime) var time = points[num].time, min = points[0].time.getTime(), max = points[points.length - 1].time.getTime(), val = time.getTime(); else var time = points[num].time, min = points[0].time, max = points[points.length - 1].time, val = time;
                        return 1e3 * animation_duration * (val - min) / (max - min);
                    }, LineDotChart.prototype.showDataPoint = function(data, index) {
                        d3.select(this).classed("show", !0);
                    }, LineDotChart.prototype.hideDataPoint = function(data, index) {
                        d3.select(this).classed("show", !1);
                    }, LineDotChart.prototype.addTooltip = function(model, element) {
                        var selection = d3.select(element), data = selection.datum();
                        visuals.TooltipManager.addTooltip(selection, function(event) {
                            return [ {
                                displayName: model.settings.xAxisTitle,
                                value: model.xAxis.formatter.format(data.time)
                            }, {
                                displayName: model.settings.yAxisTitle,
                                value: data.value.toString()
                            } ];
                        });
                    }, LineDotChart.prototype.renderLegends = function(model) {
                        var legendSelection = this.legends.selectAll(LineDotChart.Legend.selector).data(model.legends);
                        legendSelection.enter().append("svg:text"), legendSelection.attr("x", 0).attr("y", 0).attr("dx", function(item) {
                            return item.dx;
                        }).attr("dy", function(item) {
                            return item.dy;
                        }).attr("transform", function(item) {
                            return item.transform;
                        }).text(function(item) {
                            return item.text;
                        }).classed(LineDotChart.Legend.class, !0), legendSelection.exit().remove();
                    }, LineDotChart.DefaultSettings = {
                        lineFill: "rgb(102, 212, 204)",
                        lineThickness: 3,
                        dotFill: "#005c55",
                        dotSizeMin: 4,
                        dotSizeMax: 38,
                        counterTitle: "Total features",
                        xAxisTitle: "",
                        yAxisTitle: "",
                        duration: 20,
                        isanimated: !0,
                        isstopped: !0
                    }, LineDotChart.capabilities = {
                        dataRoles: [ {
                            name: "Date",
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: "Date"
                        }, {
                            name: "Values",
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: "Values"
                        } ],
                        dataViewMappings: [ {
                            conditions: [ {
                                Date: {
                                    min: 0,
                                    max: 1
                                },
                                Values: {
                                    min: 0,
                                    max: 1
                                },
                                Labels: {
                                    min: 0,
                                    max: 1
                                }
                            } ],
                            categorical: {
                                categories: {
                                    for: {
                                        in: "Date"
                                    },
                                    dataReductionAlgorithm: {
                                        sample: {}
                                    }
                                },
                                values: {
                                    for: {
                                        in: "Values"
                                    }
                                }
                            }
                        } ],
                        objects: {
                            general: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_General"),
                                properties: {
                                    formatString: {
                                        type: {
                                            formatting: {
                                                formatString: !0
                                            }
                                        }
                                    }
                                }
                            },
                            lineoptions: {
                                displayName: "Line",
                                properties: {
                                    fill: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Fill"),
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    lineThickness: {
                                        displayName: "Thickness",
                                        type: {
                                            numeric: !0
                                        }
                                    }
                                }
                            },
                            dotoptions: {
                                displayName: "Dot",
                                properties: {
                                    color: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Fill"),
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    dotSizeMin: {
                                        displayName: "Min size",
                                        type: {
                                            numeric: !0
                                        }
                                    },
                                    dotSizeMax: {
                                        displayName: "Min size",
                                        type: {
                                            numeric: !0
                                        }
                                    }
                                }
                            },
                            counteroptions: {
                                displayName: "Counter",
                                properties: {
                                    counterTitle: {
                                        displayName: "Title",
                                        type: {
                                            text: !0
                                        }
                                    }
                                }
                            },
                            misc: {
                                displayName: "Animation",
                                properties: {
                                    isanimated: {
                                        displayName: "Animated",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    isstopped: {
                                        displayName: "Stop on load",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    duration: {
                                        displayName: "Time",
                                        type: {
                                            numeric: !0
                                        }
                                    }
                                }
                            }
                        }
                    }, LineDotChart.Identity = {
                        class: "lineDotChart",
                        selector: ".lineDotChart"
                    }, LineDotChart.Axes = {
                        class: "axes",
                        selector: ".axes"
                    }, LineDotChart.Axis = {
                        class: "axis",
                        selector: ".axis"
                    }, LineDotChart.Legends = {
                        class: "legends",
                        selector: ".legends"
                    }, LineDotChart.Legend = {
                        class: "legend",
                        selector: ".legend"
                    }, LineDotChart.Values = {
                        class: "line",
                        selector: ".line"
                    }, LineDotChart.Properties = {
                        general: {
                            formatString: {
                                objectName: "general",
                                propertyName: "formatString"
                            }
                        },
                        lineoptions: {
                            fill: {
                                objectName: "lineoptions",
                                propertyName: "fill"
                            },
                            lineThickness: {
                                objectName: "lineoptions",
                                propertyName: "lineThickness"
                            }
                        },
                        dotoptions: {
                            color: {
                                objectName: "dotoptions",
                                propertyName: "color"
                            },
                            dotSizeMin: {
                                objectName: "dotoptions",
                                propertyName: "dotSizeMin"
                            },
                            dotSizeMax: {
                                objectName: "dotoptions",
                                propertyName: "dotSizeMax"
                            }
                        },
                        counteroptions: {
                            counterTitle: {
                                objectName: "counteroptions",
                                propertyName: "counterTitle"
                            }
                        },
                        misc: {
                            isanimated: {
                                objectName: "misc",
                                propertyName: "isanimated"
                            },
                            isstopped: {
                                objectName: "misc",
                                propertyName: "isstopped"
                            },
                            duration: {
                                objectName: "misc",
                                propertyName: "duration"
                            }
                        }
                    }, LineDotChart;
                }();
                samples.LineDotChart = LineDotChart;
            }(samples = visuals.samples || (visuals.samples = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi);
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var samples;
            !function(samples) {
                var SelectionManager = visuals.utility.SelectionManager;
                samples.sunburstRoleNames = {
                    nodes: "Nodes",
                    values: "Values"
                };
                var Sunburst = function() {
                    function Sunburst() {
                        this.total = 0;
                    }
                    return Sunburst.prototype.init = function(options) {
                        var _this = this;
                        this.arc = d3.svg.arc().startAngle(function(d) {
                            return d.x;
                        }).endAngle(function(d) {
                            return d.x + d.dx;
                        }).innerRadius(function(d) {
                            return Math.sqrt(d.y);
                        }).outerRadius(function(d) {
                            return Math.sqrt(d.y + d.dy);
                        }), this.colors = options.style.colorPalette.dataColors, this.selectionManager = new SelectionManager({
                            hostServices: options.host
                        }), this.svg = d3.select(options.element.get(0)).append("svg"), this.svg.classed("mainDrawArea", !0), 
                        this.g = this.svg.append("g"), this.g.classed("container", !0), this.svg.append("text").classed("sunBurstPercentageFixed", !0), 
                        this.svg.on("mousedown", function(d) {
                            _this.svg.selectAll("path").style("opacity", 1), _this.svg.select(".sunBurstPercentageFixed").style("opacity", 0), 
                            _this.selectionManager.clear();
                        });
                    }, Sunburst.setAllUnhide = function(selection) {
                        selection.attr("setUnHide", "true");
                    }, Sunburst.prototype.update = function(options) {
                        if (options.dataViews.length > 0) {
                            var data = this.converter(options.dataViews[0], this.colors);
                            this.viewport = options.viewport, this.updateInternal(data);
                        }
                    }, Sunburst.prototype.updateInternal = function(dataRootNode) {
                        var _this = this;
                        this.svg.attr({
                            height: this.viewport.height,
                            width: this.viewport.width
                        }), this.g.attr("transform", visuals.SVGUtil.translate(this.viewport.width / 2, this.viewport.height / 2));
                        var radius = Math.min(this.viewport.width, this.viewport.height) / 2, partition = d3.layout.partition().size([ 2 * Math.PI, radius * radius ]).value(function(d) {
                            return d.value;
                        }), path = this.g.datum(dataRootNode).selectAll("path").data(partition.nodes);
                        path.enter().append("path"), path.attr("display", function(d) {
                            return d.depth ? null : "none";
                        }).attr("d", this.arc).style("stroke", "#fff").style("fill", function(d) {
                            return d.color;
                        }).style("fill-rule", "evenodd").on("mousedown", function(d) {
                            d.selector && _this.selectionManager.select(d.selector), d3.selectAll("path").call(Sunburst.setAllUnhide).attr("setUnHide", null), 
                            _this.highlightPath(d, _this, !0);
                            var percentageFixedText = _this.svg.select(".sunBurstPercentageFixed"), percentage = 0 === _this.total ? 0 : (100 * d.total / _this.total).toPrecision(3);
                            percentageFixedText.text(d ? percentage + "%" : ""), percentageFixedText.style("fill", d.color), 
                            _this.onResize(), event.stopPropagation();
                        }), this.renderTooltip(path), path.exit().remove(), this.onResize();
                    }, Sunburst.getTreePath = function(node) {
                        for (var path = [], current = node; current.parent; ) path.unshift(current), current = current.parent;
                        return path;
                    }, Sunburst.prototype.onResize = function() {
                        var width = this.viewport.width, height = this.viewport.height, percentageFixedText = this.svg.select(".sunBurstPercentageFixed"), textWidth = powerbi.TextMeasurementService.measureSvgTextElementWidth(percentageFixedText[0][0]);
                        percentageFixedText.style("opacity", 1), percentageFixedText.attr("y", height / 2 + 4), 
                        percentageFixedText.attr("x", width / 2 - textWidth / 2);
                    }, Sunburst.prototype.highlightPath = function(d, sunBurst, setUnhide) {
                        var parentsArray = d ? Sunburst.getTreePath(d) : [];
                        sunBurst.svg.selectAll("path").each(function() {
                            "true" !== d3.select(this).attr("setUnHide") && d3.select(this).style("opacity", Sunburst.minOpacity);
                        }), sunBurst.svg.selectAll("path").filter(function(node) {
                            return parentsArray.indexOf(node) >= 0;
                        }).each(function() {
                            d3.select(this).style("opacity", 1), setUnhide === !0 && d3.select(this).attr("setUnHide", "true");
                        });
                    }, Sunburst.prototype.renderTooltip = function(selection) {
                        visuals.TooltipManager.addTooltip(selection, function(tooltipEvent) {
                            return tooltipEvent.data.tooltipInfo;
                        });
                    }, Sunburst.getTooltipData = function(displayName, value) {
                        return [ {
                            displayName: displayName,
                            value: value < 0 ? "" : value.toString()
                        } ];
                    }, Sunburst.prototype.covertTreeNodeToSunBurstNode = function(originParentNode, sunburstParentNode, colors, pathIdentity, color) {
                        var selector;
                        originParentNode.identity && (pathIdentity = pathIdentity.concat([ originParentNode.identity ]), 
                        selector = {
                            data: pathIdentity
                        });
                        var selectionId = 0 === pathIdentity.length ? null : new visuals.SelectionId(selector, (!1)), valueToSet = originParentNode.values ? originParentNode.values[0].value : 0, newSunNode = {
                            name: originParentNode.name,
                            value: Math.max(valueToSet, 0),
                            selector: selectionId,
                            total: valueToSet
                        };
                        if (originParentNode.value && (newSunNode.color = color ? color : colors.getColor(originParentNode.value).value), 
                        this.total += newSunNode.value, originParentNode.children && originParentNode.children.length > 0) {
                            newSunNode.tooltipInfo = Sunburst.getTooltipData(originParentNode.value, -1), newSunNode.children = [];
                            for (var i = 0; i < originParentNode.children.length; i++) {
                                var newChild = this.covertTreeNodeToSunBurstNode(originParentNode.children[i], newSunNode, colors, pathIdentity, newSunNode.color);
                                newSunNode.children.push(newChild), newSunNode.total += newChild.total;
                            }
                        } else newSunNode.tooltipInfo = Sunburst.getTooltipData(originParentNode.value, valueToSet);
                        return sunburstParentNode && (newSunNode.parent = sunburstParentNode), newSunNode;
                    }, Sunburst.prototype.converter = function(dataView, colors) {
                        var colorScale = colors.getNewColorScale();
                        this.total = 0;
                        var root = this.covertTreeNodeToSunBurstNode(dataView.matrix.rows.root, null, colorScale, [], void 0);
                        return root;
                    }, Sunburst.minOpacity = .2, Sunburst.roleNames = {
                        nodes: "Nodes",
                        values: "Values"
                    }, Sunburst.capabilities = {
                        dataRoles: [ {
                            name: Sunburst.roleNames.nodes,
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: "Groups"
                        }, {
                            name: Sunburst.roleNames.values,
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: "Values"
                        } ],
                        objects: {
                            general: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_General"),
                                properties: {
                                    formatString: {
                                        type: {
                                            formatting: {
                                                formatString: !0
                                            }
                                        }
                                    }
                                }
                            }
                        },
                        dataViewMappings: [ {
                            conditions: [ {
                                Groups: {
                                    min: 0
                                },
                                Values: {
                                    max: 1
                                }
                            } ],
                            matrix: {
                                rows: {
                                    for: {
                                        in: Sunburst.roleNames.nodes
                                    }
                                },
                                values: {
                                    for: {
                                        in: Sunburst.roleNames.values
                                    }
                                }
                            }
                        } ]
                    }, Sunburst;
                }();
                samples.Sunburst = Sunburst;
            }(samples = visuals.samples || (visuals.samples = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi);
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var plugins;
            !function(plugins) {
                plugins.sunburstCustom = {
                    name: "sunburstCustom",
                    watermarkKey: "defaultWatermark",
                    capabilities: visuals.samples.Sunburst.capabilities,
                    create: function() {
                        return new visuals.samples.Sunburst();
                    }
                }, plugins.asterPlot = {
                    name: "asterPlot",
                    capabilities: visuals.samples.AsterPlot.capabilities,
                    create: function() {
                        return new visuals.samples.AsterPlot();
                    }
                }, plugins.tornadoChart = {
                    name: "tornadoChart",
                    capabilities: visuals.samples.TornadoChart.capabilities,
                    create: function() {
                        return new visuals.samples.TornadoChart();
                    }
                }, plugins.sankeyDiagram = {
                    name: "sankeyDiagram",
                    capabilities: visuals.samples.SankeyDiagram.capabilities,
                    create: function() {
                        return new visuals.samples.SankeyDiagram();
                    }
                }, plugins.mekkoChart = {
                    name: "mekkoChart",
                    watermarkKey: "mekko",
                    capabilities: visuals.samples.MekkoChart.capabilities,
                    create: function() {
                        return new visuals.samples.MekkoChart({
                            chartType: visuals.samples.MekkoChartType.HundredPercentStackedColumn
                        });
                    },
                    customizeQuery: visuals.ColumnChart.customizeQuery,
                    getSortableRoles: function(visualSortableOptions) {
                        return visuals.ColumnChart.getSortableRoles(visualSortableOptions);
                    }
                }, plugins.bulletChart = {
                    name: "bulletChart",
                    capabilities: visuals.samples.BulletChart.capabilities,
                    create: function() {
                        return new visuals.samples.BulletChart();
                    }
                }, plugins.wordCloud = {
                    name: "wordCloud",
                    capabilities: visuals.samples.WordCloud.capabilities,
                    create: function() {
                        return new visuals.samples.WordCloud();
                    }
                }, plugins.chicletSlicer = {
                    name: "chicletSlicer",
                    capabilities: visuals.samples.ChicletSlicer.capabilities,
                    create: function() {
                        return new visuals.samples.ChicletSlicer();
                    }
                }, plugins.chordChart = {
                    name: "chordChart",
                    capabilities: visuals.samples.ChordChart.capabilities,
                    create: function() {
                        return new visuals.samples.ChordChart();
                    }
                }, plugins.enhancedScatterChart = {
                    name: "enhancedScatterChart",
                    capabilities: visuals.samples.EnhancedScatterChart.capabilities,
                    create: function() {
                        return new visuals.samples.EnhancedScatterChart();
                    }
                }, plugins.radarChart = {
                    name: "radarChart",
                    capabilities: visuals.samples.RadarChart.capabilities,
                    create: function() {
                        return new visuals.samples.RadarChart();
                    }
                }, plugins.dotPlot = {
                    name: "dotPlot",
                    capabilities: visuals.samples.DotPlot.capabilities,
                    create: function() {
                        return new visuals.samples.DotPlot();
                    }
                }, plugins.histogram = {
                    name: "histogram",
                    capabilities: visuals.samples.Histogram.capabilities,
                    create: function() {
                        return new visuals.samples.Histogram();
                    }
                }, plugins.timeline = {
                    name: "timeline",
                    capabilities: visuals.samples.Timeline.capabilities,
                    create: function() {
                        return new visuals.samples.Timeline();
                    }
                }, plugins.forceGraph = {
                    name: "forceGraph",
                    capabilities: visuals.samples.ForceGraph.capabilities,
                    create: function() {
                        return new visuals.samples.ForceGraph();
                    }
                }, plugins.gantt = {
                    name: "gantt",
                    capabilities: visuals.samples.Gantt.capabilities,
                    create: function() {
                        return new visuals.samples.Gantt();
                    }
                }, plugins.streamGraph = {
                    name: "streamGraph",
                    capabilities: visuals.samples.StreamGraph.capabilities,
                    create: function() {
                        return new visuals.samples.StreamGraph();
                    }
                }, plugins.pulseChart = {
                    name: "pulseChart",
                    capabilities: visuals.samples.PulseChart.capabilities,
                    create: function() {
                        return new visuals.samples.PulseChart();
                    }
                }, plugins.lineDotChart = {
                    name: "lineDotChart",
                    capabilities: visuals.samples.LineDotChart.capabilities,
                    create: function() {
                        return new visuals.samples.LineDotChart();
                    }
                };
            }(plugins = visuals.plugins || (visuals.plugins = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
} ]);